// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_field, unused_element

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/flutter_pdfium.h`.
/// Contains all public functions from all public headers of pdfium.
/// The headers are wrapped in this library to enable easy access to the API
/// in macOS and iOS because of treeshaking. The effective calls are renamed
/// to remove the prefix `PDFIUM_FPDF_` and `PDFIUM_FPDF`.
///
class Pdfium {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Pdfium(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Pdfium.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<ffi.Pointer<FILE>> ___stdinp =
      _lookup<ffi.Pointer<FILE>>('__stdinp');

  ffi.Pointer<FILE> get __stdinp => ___stdinp.value;

  set __stdinp(ffi.Pointer<FILE> value) => ___stdinp.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> ___stdoutp =
      _lookup<ffi.Pointer<FILE>>('__stdoutp');

  ffi.Pointer<FILE> get __stdoutp => ___stdoutp.value;

  set __stdoutp(ffi.Pointer<FILE> value) => ___stdoutp.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> ___stderrp =
      _lookup<ffi.Pointer<FILE>>('__stderrp');

  ffi.Pointer<FILE> get __stderrp => ___stderrp.value;

  set __stderrp(ffi.Pointer<FILE> value) => ___stderrp.value = value;

  /// perror(3) external variables
  late final ffi.Pointer<ffi.Int> _sys_nerr = _lookup<ffi.Int>('sys_nerr');

  int get sys_nerr => _sys_nerr.value;

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _sys_errlist =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>('sys_errlist');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get sys_errlist => _sys_errlist.value;

  set sys_errlist(ffi.Pointer<ffi.Pointer<ffi.Char>> value) =>
      _sys_errlist.value = value;

  late final ffi.Pointer<ffi.Int> ___mb_cur_max =
      _lookup<ffi.Int>('__mb_cur_max');

  int get __mb_cur_max => ___mb_cur_max.value;

  set __mb_cur_max(int value) => ___mb_cur_max.value = value;

  /// getsubopt(3) external variable
  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _suboptarg =
      _lookup<ffi.Pointer<ffi.Char>>('suboptarg');

  ffi.Pointer<ffi.Char> get suboptarg => _suboptarg.value;

  set suboptarg(ffi.Pointer<ffi.Char> value) => _suboptarg.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _tzname =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>('tzname');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get tzname => _tzname.value;

  set tzname(ffi.Pointer<ffi.Pointer<ffi.Char>> value) => _tzname.value = value;

  late final ffi.Pointer<ffi.Int> _getdate_err =
      _lookup<ffi.Int>('getdate_err');

  int get getdate_err => _getdate_err.value;

  set getdate_err(int value) => _getdate_err.value = value;

  late final ffi.Pointer<ffi.Long> _timezone = _lookup<ffi.Long>('timezone');

  int get timezone => _timezone.value;

  set timezone(int value) => _timezone.value = value;

  late final ffi.Pointer<ffi.Int> _daylight = _lookup<ffi.Int>('daylight');

  int get daylight => _daylight.value;

  set daylight(int value) => _daylight.value = value;

  /// getopt(3) external variables
  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _optarg =
      _lookup<ffi.Pointer<ffi.Char>>('optarg');

  ffi.Pointer<ffi.Char> get optarg => _optarg.value;

  set optarg(ffi.Pointer<ffi.Char> value) => _optarg.value = value;

  late final ffi.Pointer<ffi.Int> _optind = _lookup<ffi.Int>('optind');

  int get optind => _optind.value;

  set optind(int value) => _optind.value = value;

  late final ffi.Pointer<ffi.Int> _opterr = _lookup<ffi.Int>('opterr');

  int get opterr => _opterr.value;

  set opterr(int value) => _opterr.value = value;

  late final ffi.Pointer<ffi.Int> _optopt = _lookup<ffi.Int>('optopt');

  int get optopt => _optopt.value;

  set optopt(int value) => _optopt.value = value;

  late final ffi.Pointer<ffi.Int> _optreset = _lookup<ffi.Int>('optreset');

  int get optreset => _optreset.value;

  set optreset(int value) => _optreset.value = value;

  /// Set "MediaBox" entry to the page dictionary.
  /// page   - Handle to a page.
  /// left   - The left of the rectangle.
  /// bottom - The bottom of the rectangle.
  /// right  - The right of the rectangle.
  /// top    - The top of the rectangle.
  void Page_SetMediaBox(
    FPDF_PAGE page,
    double left,
    double bottom,
    double right,
    double top,
  ) {
    return _Page_SetMediaBox(
      page,
      left,
      bottom,
      right,
      top,
    );
  }

  late final _Page_SetMediaBoxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FPDF_PAGE, ffi.Float, ffi.Float, ffi.Float,
              ffi.Float)>>('PDFIUM_FPDFPage_SetMediaBox');
  late final _Page_SetMediaBox = _Page_SetMediaBoxPtr.asFunction<
      void Function(FPDF_PAGE, double, double, double, double)>();

  /// Set "CropBox" entry to the page dictionary.
  /// page   - Handle to a page.
  /// left   - The left of the rectangle.
  /// bottom - The bottom of the rectangle.
  /// right  - The right of the rectangle.
  /// top    - The top of the rectangle.
  void Page_SetCropBox(
    FPDF_PAGE page,
    double left,
    double bottom,
    double right,
    double top,
  ) {
    return _Page_SetCropBox(
      page,
      left,
      bottom,
      right,
      top,
    );
  }

  late final _Page_SetCropBoxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FPDF_PAGE, ffi.Float, ffi.Float, ffi.Float,
              ffi.Float)>>('PDFIUM_FPDFPage_SetCropBox');
  late final _Page_SetCropBox = _Page_SetCropBoxPtr.asFunction<
      void Function(FPDF_PAGE, double, double, double, double)>();

  /// Set "BleedBox" entry to the page dictionary.
  /// page   - Handle to a page.
  /// left   - The left of the rectangle.
  /// bottom - The bottom of the rectangle.
  /// right  - The right of the rectangle.
  /// top    - The top of the rectangle.
  void Page_SetBleedBox(
    FPDF_PAGE page,
    double left,
    double bottom,
    double right,
    double top,
  ) {
    return _Page_SetBleedBox(
      page,
      left,
      bottom,
      right,
      top,
    );
  }

  late final _Page_SetBleedBoxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FPDF_PAGE, ffi.Float, ffi.Float, ffi.Float,
              ffi.Float)>>('PDFIUM_FPDFPage_SetBleedBox');
  late final _Page_SetBleedBox = _Page_SetBleedBoxPtr.asFunction<
      void Function(FPDF_PAGE, double, double, double, double)>();

  /// Set "TrimBox" entry to the page dictionary.
  /// page   - Handle to a page.
  /// left   - The left of the rectangle.
  /// bottom - The bottom of the rectangle.
  /// right  - The right of the rectangle.
  /// top    - The top of the rectangle.
  void Page_SetTrimBox(
    FPDF_PAGE page,
    double left,
    double bottom,
    double right,
    double top,
  ) {
    return _Page_SetTrimBox(
      page,
      left,
      bottom,
      right,
      top,
    );
  }

  late final _Page_SetTrimBoxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FPDF_PAGE, ffi.Float, ffi.Float, ffi.Float,
              ffi.Float)>>('PDFIUM_FPDFPage_SetTrimBox');
  late final _Page_SetTrimBox = _Page_SetTrimBoxPtr.asFunction<
      void Function(FPDF_PAGE, double, double, double, double)>();

  /// Set "ArtBox" entry to the page dictionary.
  /// page   - Handle to a page.
  /// left   - The left of the rectangle.
  /// bottom - The bottom of the rectangle.
  /// right  - The right of the rectangle.
  /// top    - The top of the rectangle.
  void Page_SetArtBox(
    FPDF_PAGE page,
    double left,
    double bottom,
    double right,
    double top,
  ) {
    return _Page_SetArtBox(
      page,
      left,
      bottom,
      right,
      top,
    );
  }

  late final _Page_SetArtBoxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FPDF_PAGE, ffi.Float, ffi.Float, ffi.Float,
              ffi.Float)>>('PDFIUM_FPDFPage_SetArtBox');
  late final _Page_SetArtBox = _Page_SetArtBoxPtr.asFunction<
      void Function(FPDF_PAGE, double, double, double, double)>();

  /// Get "MediaBox" entry from the page dictionary.
  /// page   - Handle to a page.
  /// left   - Pointer to a float value receiving the left of the rectangle.
  /// bottom - Pointer to a float value receiving the bottom of the rectangle.
  /// right  - Pointer to a float value receiving the right of the rectangle.
  /// top    - Pointer to a float value receiving the top of the rectangle.
  /// On success, return true and write to the out parameters. Otherwise return
  /// false and leave the out parameters unmodified.
  int Page_GetMediaBox(
    FPDF_PAGE page,
    ffi.Pointer<ffi.Float> left,
    ffi.Pointer<ffi.Float> bottom,
    ffi.Pointer<ffi.Float> right,
    ffi.Pointer<ffi.Float> top,
  ) {
    return _Page_GetMediaBox(
      page,
      left,
      bottom,
      right,
      top,
    );
  }

  late final _Page_GetMediaBoxPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGE,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('PDFIUM_FPDFPage_GetMediaBox');
  late final _Page_GetMediaBox = _Page_GetMediaBoxPtr.asFunction<
      int Function(FPDF_PAGE, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>)>();

  /// Get "CropBox" entry from the page dictionary.
  /// page   - Handle to a page.
  /// left   - Pointer to a float value receiving the left of the rectangle.
  /// bottom - Pointer to a float value receiving the bottom of the rectangle.
  /// right  - Pointer to a float value receiving the right of the rectangle.
  /// top    - Pointer to a float value receiving the top of the rectangle.
  /// On success, return true and write to the out parameters. Otherwise return
  /// false and leave the out parameters unmodified.
  int Page_GetCropBox(
    FPDF_PAGE page,
    ffi.Pointer<ffi.Float> left,
    ffi.Pointer<ffi.Float> bottom,
    ffi.Pointer<ffi.Float> right,
    ffi.Pointer<ffi.Float> top,
  ) {
    return _Page_GetCropBox(
      page,
      left,
      bottom,
      right,
      top,
    );
  }

  late final _Page_GetCropBoxPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGE,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('PDFIUM_FPDFPage_GetCropBox');
  late final _Page_GetCropBox = _Page_GetCropBoxPtr.asFunction<
      int Function(FPDF_PAGE, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>)>();

  /// Get "BleedBox" entry from the page dictionary.
  /// page   - Handle to a page.
  /// left   - Pointer to a float value receiving the left of the rectangle.
  /// bottom - Pointer to a float value receiving the bottom of the rectangle.
  /// right  - Pointer to a float value receiving the right of the rectangle.
  /// top    - Pointer to a float value receiving the top of the rectangle.
  /// On success, return true and write to the out parameters. Otherwise return
  /// false and leave the out parameters unmodified.
  int Page_GetBleedBox(
    FPDF_PAGE page,
    ffi.Pointer<ffi.Float> left,
    ffi.Pointer<ffi.Float> bottom,
    ffi.Pointer<ffi.Float> right,
    ffi.Pointer<ffi.Float> top,
  ) {
    return _Page_GetBleedBox(
      page,
      left,
      bottom,
      right,
      top,
    );
  }

  late final _Page_GetBleedBoxPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGE,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('PDFIUM_FPDFPage_GetBleedBox');
  late final _Page_GetBleedBox = _Page_GetBleedBoxPtr.asFunction<
      int Function(FPDF_PAGE, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>)>();

  /// Get "TrimBox" entry from the page dictionary.
  /// page   - Handle to a page.
  /// left   - Pointer to a float value receiving the left of the rectangle.
  /// bottom - Pointer to a float value receiving the bottom of the rectangle.
  /// right  - Pointer to a float value receiving the right of the rectangle.
  /// top    - Pointer to a float value receiving the top of the rectangle.
  /// On success, return true and write to the out parameters. Otherwise return
  /// false and leave the out parameters unmodified.
  int Page_GetTrimBox(
    FPDF_PAGE page,
    ffi.Pointer<ffi.Float> left,
    ffi.Pointer<ffi.Float> bottom,
    ffi.Pointer<ffi.Float> right,
    ffi.Pointer<ffi.Float> top,
  ) {
    return _Page_GetTrimBox(
      page,
      left,
      bottom,
      right,
      top,
    );
  }

  late final _Page_GetTrimBoxPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGE,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('PDFIUM_FPDFPage_GetTrimBox');
  late final _Page_GetTrimBox = _Page_GetTrimBoxPtr.asFunction<
      int Function(FPDF_PAGE, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>)>();

  /// Get "ArtBox" entry from the page dictionary.
  /// page   - Handle to a page.
  /// left   - Pointer to a float value receiving the left of the rectangle.
  /// bottom - Pointer to a float value receiving the bottom of the rectangle.
  /// right  - Pointer to a float value receiving the right of the rectangle.
  /// top    - Pointer to a float value receiving the top of the rectangle.
  /// On success, return true and write to the out parameters. Otherwise return
  /// false and leave the out parameters unmodified.
  int Page_GetArtBox(
    FPDF_PAGE page,
    ffi.Pointer<ffi.Float> left,
    ffi.Pointer<ffi.Float> bottom,
    ffi.Pointer<ffi.Float> right,
    ffi.Pointer<ffi.Float> top,
  ) {
    return _Page_GetArtBox(
      page,
      left,
      bottom,
      right,
      top,
    );
  }

  late final _Page_GetArtBoxPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGE,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('PDFIUM_FPDFPage_GetArtBox');
  late final _Page_GetArtBox = _Page_GetArtBoxPtr.asFunction<
      int Function(FPDF_PAGE, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>)>();

  /// Apply transforms to |page|.
  /// If |matrix| is provided it will be applied to transform the page.
  /// If |clipRect| is provided it will be used to clip the resulting page.
  /// If neither |matrix| or |clipRect| are provided this method returns |false|.
  /// Returns |true| if transforms are applied.
  /// This function will transform the whole page, and would take effect to all the
  /// objects in the page.
  /// page        - Page handle.
  /// matrix      - Transform matrix.
  /// clipRect    - Clipping rectangle.
  int Page_TransFormWithClip(
    FPDF_PAGE page,
    ffi.Pointer<FS_MATRIX> matrix,
    ffi.Pointer<FS_RECTF> clipRect,
  ) {
    return _Page_TransFormWithClip(
      page,
      matrix,
      clipRect,
    );
  }

  late final _Page_TransFormWithClipPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGE, ffi.Pointer<FS_MATRIX>,
              ffi.Pointer<FS_RECTF>)>>('PDFIUM_FPDFPage_TransFormWithClip');
  late final _Page_TransFormWithClip = _Page_TransFormWithClipPtr.asFunction<
      int Function(FPDF_PAGE, ffi.Pointer<FS_MATRIX>, ffi.Pointer<FS_RECTF>)>();

  /// Transform (scale, rotate, shear, move) the clip path of page object.
  /// page_object - Handle to a page object. Returned by
  /// FPDFPageObj_NewImageObj().
  /// a  - The coefficient "a" of the matrix.
  /// b  - The coefficient "b" of the matrix.
  /// c  - The coefficient "c" of the matrix.
  /// d  - The coefficient "d" of the matrix.
  /// e  - The coefficient "e" of the matrix.
  /// f  - The coefficient "f" of the matrix.
  void PageObj_TransformClipPath(
    FPDF_PAGEOBJECT page_object,
    double a,
    double b,
    double c,
    double d,
    double e,
    double f,
  ) {
    return _PageObj_TransformClipPath(
      page_object,
      a,
      b,
      c,
      d,
      e,
      f,
    );
  }

  late final _PageObj_TransformClipPathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              FPDF_PAGEOBJECT,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Double)>>('PDFIUM_FPDFPageObj_TransformClipPath');
  late final _PageObj_TransformClipPath =
      _PageObj_TransformClipPathPtr.asFunction<
          void Function(FPDF_PAGEOBJECT, double, double, double, double, double,
              double)>();

  /// Experimental API.
  /// Get the clip path of the page object.
  /// page object - Handle to a page object. Returned by e.g.
  /// FPDFPage_GetObject().
  /// Returns the handle to the clip path, or NULL on failure. The caller does not
  /// take ownership of the returned FPDF_CLIPPATH. Instead, it remains valid until
  /// FPDF_ClosePage() is called for the page containing |page_object|.
  FPDF_CLIPPATH PageObj_GetClipPath(
    FPDF_PAGEOBJECT page_object,
  ) {
    return _PageObj_GetClipPath(
      page_object,
    );
  }

  late final _PageObj_GetClipPathPtr =
      _lookup<ffi.NativeFunction<FPDF_CLIPPATH Function(FPDF_PAGEOBJECT)>>(
          'PDFIUM_FPDFPageObj_GetClipPath');
  late final _PageObj_GetClipPath = _PageObj_GetClipPathPtr.asFunction<
      FPDF_CLIPPATH Function(FPDF_PAGEOBJECT)>();

  /// Experimental API.
  /// Get number of paths inside |clip_path|.
  /// clip_path - handle to a clip_path.
  /// Returns the number of objects in |clip_path| or -1 on failure.
  int ClipPath_CountPaths(
    FPDF_CLIPPATH clip_path,
  ) {
    return _ClipPath_CountPaths(
      clip_path,
    );
  }

  late final _ClipPath_CountPathsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_CLIPPATH)>>(
          'PDFIUM_FPDFClipPath_CountPaths');
  late final _ClipPath_CountPaths =
      _ClipPath_CountPathsPtr.asFunction<int Function(FPDF_CLIPPATH)>();

  /// Experimental API.
  /// Get number of segments inside one path of |clip_path|.
  /// clip_path  - handle to a clip_path.
  /// path_index - index into the array of paths of the clip path.
  /// Returns the number of segments or -1 on failure.
  int ClipPath_CountPathSegments(
    FPDF_CLIPPATH clip_path,
    int path_index,
  ) {
    return _ClipPath_CountPathSegments(
      clip_path,
      path_index,
    );
  }

  late final _ClipPath_CountPathSegmentsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_CLIPPATH, ffi.Int)>>(
          'PDFIUM_FPDFClipPath_CountPathSegments');
  late final _ClipPath_CountPathSegments = _ClipPath_CountPathSegmentsPtr
      .asFunction<int Function(FPDF_CLIPPATH, int)>();

  /// Experimental API.
  /// Get segment in one specific path of |clip_path| at index.
  /// clip_path     - handle to a clip_path.
  /// path_index    - the index of a path.
  /// segment_index - the index of a segment.
  /// Returns the handle to the segment, or NULL on failure. The caller does not
  /// take ownership of the returned FPDF_PATHSEGMENT. Instead, it remains valid
  /// until FPDF_ClosePage() is called for the page containing |clip_path|.
  FPDF_PATHSEGMENT ClipPath_GetPathSegment(
    FPDF_CLIPPATH clip_path,
    int path_index,
    int segment_index,
  ) {
    return _ClipPath_GetPathSegment(
      clip_path,
      path_index,
      segment_index,
    );
  }

  late final _ClipPath_GetPathSegmentPtr = _lookup<
      ffi.NativeFunction<
          FPDF_PATHSEGMENT Function(FPDF_CLIPPATH, ffi.Int,
              ffi.Int)>>('PDFIUM_FPDFClipPath_GetPathSegment');
  late final _ClipPath_GetPathSegment = _ClipPath_GetPathSegmentPtr.asFunction<
      FPDF_PATHSEGMENT Function(FPDF_CLIPPATH, int, int)>();

  /// Create a new clip path, with a rectangle inserted.
  /// Caller takes ownership of the returned FPDF_CLIPPATH. It should be freed with
  /// FPDF_DestroyClipPath().
  /// left   - The left of the clip box.
  /// bottom - The bottom of the clip box.
  /// right  - The right of the clip box.
  /// top    - The top of the clip box.
  FPDF_CLIPPATH CreateClipPath(
    double left,
    double bottom,
    double right,
    double top,
  ) {
    return _CreateClipPath(
      left,
      bottom,
      right,
      top,
    );
  }

  late final _CreateClipPathPtr = _lookup<
      ffi.NativeFunction<
          FPDF_CLIPPATH Function(ffi.Float, ffi.Float, ffi.Float,
              ffi.Float)>>('PDFIUM_FPDF_CreateClipPath');
  late final _CreateClipPath = _CreateClipPathPtr.asFunction<
      FPDF_CLIPPATH Function(double, double, double, double)>();

  /// Destroy the clip path.
  /// clipPath - A handle to the clip path. It will be invalid after this call.
  void DestroyClipPath(
    FPDF_CLIPPATH clipPath,
  ) {
    return _DestroyClipPath(
      clipPath,
    );
  }

  late final _DestroyClipPathPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_CLIPPATH)>>(
          'PDFIUM_FPDF_DestroyClipPath');
  late final _DestroyClipPath =
      _DestroyClipPathPtr.asFunction<void Function(FPDF_CLIPPATH)>();

  /// Clip the page content, the page content that outside the clipping region
  /// become invisible.
  /// A clip path will be inserted before the page content stream or content array.
  /// In this way, the page content will be clipped by this clip path.
  /// page        - A page handle.
  /// clipPath    - A handle to the clip path. (Does not take ownership.)
  void Page_InsertClipPath(
    FPDF_PAGE page,
    FPDF_CLIPPATH clipPath,
  ) {
    return _Page_InsertClipPath(
      page,
      clipPath,
    );
  }

  late final _Page_InsertClipPathPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_PAGE, FPDF_CLIPPATH)>>(
          'PDFIUM_FPDFPage_InsertClipPath');
  late final _Page_InsertClipPath = _Page_InsertClipPathPtr.asFunction<
      void Function(FPDF_PAGE, FPDF_CLIPPATH)>();

  /// Experimental API.
  /// Check if an annotation subtype is currently supported for creation.
  /// Currently supported subtypes:
  /// - circle
  /// - fileattachment
  /// - freetext
  /// - highlight
  /// - ink
  /// - link
  /// - popup
  /// - square,
  /// - squiggly
  /// - stamp
  /// - strikeout
  /// - text
  /// - underline
  /// subtype   - the subtype to be checked.
  /// Returns true if this subtype supported.
  int Annot_IsSupportedSubtype(
    int subtype,
  ) {
    return _Annot_IsSupportedSubtype(
      subtype,
    );
  }

  late final _Annot_IsSupportedSubtypePtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_ANNOTATION_SUBTYPE)>>(
          'PDFIUM_FPDFAnnot_IsSupportedSubtype');
  late final _Annot_IsSupportedSubtype =
      _Annot_IsSupportedSubtypePtr.asFunction<int Function(int)>();

  /// Experimental API.
  /// Create an annotation in |page| of the subtype |subtype|. If the specified
  /// subtype is illegal or unsupported, then a new annotation will not be created.
  /// Must call FPDFPage_CloseAnnot() when the annotation returned by this
  /// function is no longer needed.
  /// page      - handle to a page.
  /// subtype   - the subtype of the new annotation.
  /// Returns a handle to the new annotation object, or NULL on failure.
  FPDF_ANNOTATION Page_CreateAnnot(
    FPDF_PAGE page,
    int subtype,
  ) {
    return _Page_CreateAnnot(
      page,
      subtype,
    );
  }

  late final _Page_CreateAnnotPtr = _lookup<
      ffi.NativeFunction<
          FPDF_ANNOTATION Function(FPDF_PAGE,
              FPDF_ANNOTATION_SUBTYPE)>>('PDFIUM_FPDFPage_CreateAnnot');
  late final _Page_CreateAnnot = _Page_CreateAnnotPtr.asFunction<
      FPDF_ANNOTATION Function(FPDF_PAGE, int)>();

  /// Experimental API.
  /// Get the number of annotations in |page|.
  /// page   - handle to a page.
  /// Returns the number of annotations in |page|.
  int Page_GetAnnotCount(
    FPDF_PAGE page,
  ) {
    return _Page_GetAnnotCount(
      page,
    );
  }

  late final _Page_GetAnnotCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGE)>>(
          'PDFIUM_FPDFPage_GetAnnotCount');
  late final _Page_GetAnnotCount =
      _Page_GetAnnotCountPtr.asFunction<int Function(FPDF_PAGE)>();

  /// Experimental API.
  /// Get annotation in |page| at |index|. Must call FPDFPage_CloseAnnot() when the
  /// annotation returned by this function is no longer needed.
  /// page  - handle to a page.
  /// index - the index of the annotation.
  /// Returns a handle to the annotation object, or NULL on failure.
  FPDF_ANNOTATION Page_GetAnnot(
    FPDF_PAGE page,
    int index,
  ) {
    return _Page_GetAnnot(
      page,
      index,
    );
  }

  late final _Page_GetAnnotPtr =
      _lookup<ffi.NativeFunction<FPDF_ANNOTATION Function(FPDF_PAGE, ffi.Int)>>(
          'PDFIUM_FPDFPage_GetAnnot');
  late final _Page_GetAnnot =
      _Page_GetAnnotPtr.asFunction<FPDF_ANNOTATION Function(FPDF_PAGE, int)>();

  /// Experimental API.
  /// Get the index of |annot| in |page|. This is the opposite of
  /// FPDFPage_GetAnnot().
  /// page  - handle to the page that the annotation is on.
  /// annot - handle to an annotation.
  /// Returns the index of |annot|, or -1 on failure.
  int Page_GetAnnotIndex(
    FPDF_PAGE page,
    FPDF_ANNOTATION annot,
  ) {
    return _Page_GetAnnotIndex(
      page,
      annot,
    );
  }

  late final _Page_GetAnnotIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGE, FPDF_ANNOTATION)>>(
          'PDFIUM_FPDFPage_GetAnnotIndex');
  late final _Page_GetAnnotIndex = _Page_GetAnnotIndexPtr.asFunction<
      int Function(FPDF_PAGE, FPDF_ANNOTATION)>();

  /// Experimental API.
  /// Close an annotation. Must be called when the annotation returned by
  /// FPDFPage_CreateAnnot() or FPDFPage_GetAnnot() is no longer needed. This
  /// function does not remove the annotation from the document.
  /// annot  - handle to an annotation.
  void Page_CloseAnnot(
    FPDF_ANNOTATION annot,
  ) {
    return _Page_CloseAnnot(
      annot,
    );
  }

  late final _Page_CloseAnnotPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_ANNOTATION)>>(
          'PDFIUM_FPDFPage_CloseAnnot');
  late final _Page_CloseAnnot =
      _Page_CloseAnnotPtr.asFunction<void Function(FPDF_ANNOTATION)>();

  /// Experimental API.
  /// Remove the annotation in |page| at |index|.
  /// page  - handle to a page.
  /// index - the index of the annotation.
  /// Returns true if successful.
  int Page_RemoveAnnot(
    FPDF_PAGE page,
    int index,
  ) {
    return _Page_RemoveAnnot(
      page,
      index,
    );
  }

  late final _Page_RemoveAnnotPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_PAGE, ffi.Int)>>(
          'PDFIUM_FPDFPage_RemoveAnnot');
  late final _Page_RemoveAnnot =
      _Page_RemoveAnnotPtr.asFunction<int Function(FPDF_PAGE, int)>();

  /// Experimental API.
  /// Get the subtype of an annotation.
  /// annot  - handle to an annotation.
  /// Returns the annotation subtype.
  int Annot_GetSubtype(
    FPDF_ANNOTATION annot,
  ) {
    return _Annot_GetSubtype(
      annot,
    );
  }

  late final _Annot_GetSubtypePtr = _lookup<
          ffi
          .NativeFunction<FPDF_ANNOTATION_SUBTYPE Function(FPDF_ANNOTATION)>>(
      'PDFIUM_FPDFAnnot_GetSubtype');
  late final _Annot_GetSubtype =
      _Annot_GetSubtypePtr.asFunction<int Function(FPDF_ANNOTATION)>();

  /// Experimental API.
  /// Check if an annotation subtype is currently supported for object extraction,
  /// update, and removal.
  /// Currently supported subtypes: ink and stamp.
  /// subtype   - the subtype to be checked.
  /// Returns true if this subtype supported.
  int Annot_IsObjectSupportedSubtype(
    int subtype,
  ) {
    return _Annot_IsObjectSupportedSubtype(
      subtype,
    );
  }

  late final _Annot_IsObjectSupportedSubtypePtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_ANNOTATION_SUBTYPE)>>(
          'PDFIUM_FPDFAnnot_IsObjectSupportedSubtype');
  late final _Annot_IsObjectSupportedSubtype =
      _Annot_IsObjectSupportedSubtypePtr.asFunction<int Function(int)>();

  /// Experimental API.
  /// Update |obj| in |annot|. |obj| must be in |annot| already and must have
  /// been retrieved by FPDFAnnot_GetObject(). Currently, only ink and stamp
  /// annotations are supported by this API. Also note that only path, image, and
  /// text objects have APIs for modification; see FPDFPath_*(), FPDFText_*(), and
  /// FPDFImageObj_*().
  /// annot  - handle to an annotation.
  /// obj    - handle to the object that |annot| needs to update.
  /// Return true if successful.
  int Annot_UpdateObject(
    FPDF_ANNOTATION annot,
    FPDF_PAGEOBJECT obj,
  ) {
    return _Annot_UpdateObject(
      annot,
      obj,
    );
  }

  late final _Annot_UpdateObjectPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_ANNOTATION,
              FPDF_PAGEOBJECT)>>('PDFIUM_FPDFAnnot_UpdateObject');
  late final _Annot_UpdateObject = _Annot_UpdateObjectPtr.asFunction<
      int Function(FPDF_ANNOTATION, FPDF_PAGEOBJECT)>();

  /// Experimental API.
  /// Add a new InkStroke, represented by an array of points, to the InkList of
  /// |annot|. The API creates an InkList if one doesn't already exist in |annot|.
  /// This API works only for ink annotations. Please refer to ISO 32000-1:2008
  /// spec, section 12.5.6.13.
  /// annot       - handle to an annotation.
  /// points      - pointer to a FS_POINTF array representing input points.
  /// point_count - number of elements in |points| array. This should not exceed
  /// the maximum value that can be represented by an int32_t).
  /// Returns the 0-based index at which the new InkStroke is added in the InkList
  /// of the |annot|. Returns -1 on failure.
  int Annot_AddInkStroke(
    FPDF_ANNOTATION annot,
    ffi.Pointer<FS_POINTF> points,
    int point_count,
  ) {
    return _Annot_AddInkStroke(
      annot,
      points,
      point_count,
    );
  }

  late final _Annot_AddInkStrokePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(FPDF_ANNOTATION, ffi.Pointer<FS_POINTF>,
              ffi.Size)>>('PDFIUM_FPDFAnnot_AddInkStroke');
  late final _Annot_AddInkStroke = _Annot_AddInkStrokePtr.asFunction<
      int Function(FPDF_ANNOTATION, ffi.Pointer<FS_POINTF>, int)>();

  /// Experimental API.
  /// Removes an InkList in |annot|.
  /// This API works only for ink annotations.
  /// annot  - handle to an annotation.
  /// Return true on successful removal of /InkList entry from context of the
  /// non-null ink |annot|. Returns false on failure.
  int Annot_RemoveInkList(
    FPDF_ANNOTATION annot,
  ) {
    return _Annot_RemoveInkList(
      annot,
    );
  }

  late final _Annot_RemoveInkListPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_ANNOTATION)>>(
          'PDFIUM_FPDFAnnot_RemoveInkList');
  late final _Annot_RemoveInkList =
      _Annot_RemoveInkListPtr.asFunction<int Function(FPDF_ANNOTATION)>();

  /// Experimental API.
  /// Add |obj| to |annot|. |obj| must have been created by
  /// FPDFPageObj_CreateNew{Path|Rect}() or FPDFPageObj_New{Text|Image}Obj(), and
  /// will be owned by |annot|. Note that an |obj| cannot belong to more than one
  /// |annot|. Currently, only ink and stamp annotations are supported by this API.
  /// Also note that only path, image, and text objects have APIs for creation.
  /// annot  - handle to an annotation.
  /// obj    - handle to the object that is to be added to |annot|.
  /// Return true if successful.
  int Annot_AppendObject(
    FPDF_ANNOTATION annot,
    FPDF_PAGEOBJECT obj,
  ) {
    return _Annot_AppendObject(
      annot,
      obj,
    );
  }

  late final _Annot_AppendObjectPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_ANNOTATION,
              FPDF_PAGEOBJECT)>>('PDFIUM_FPDFAnnot_AppendObject');
  late final _Annot_AppendObject = _Annot_AppendObjectPtr.asFunction<
      int Function(FPDF_ANNOTATION, FPDF_PAGEOBJECT)>();

  /// Experimental API.
  /// Get the total number of objects in |annot|, including path objects, text
  /// objects, external objects, image objects, and shading objects.
  /// annot  - handle to an annotation.
  /// Returns the number of objects in |annot|.
  int Annot_GetObjectCount(
    FPDF_ANNOTATION annot,
  ) {
    return _Annot_GetObjectCount(
      annot,
    );
  }

  late final _Annot_GetObjectCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_ANNOTATION)>>(
          'PDFIUM_FPDFAnnot_GetObjectCount');
  late final _Annot_GetObjectCount =
      _Annot_GetObjectCountPtr.asFunction<int Function(FPDF_ANNOTATION)>();

  /// Experimental API.
  /// Get the object in |annot| at |index|.
  /// annot  - handle to an annotation.
  /// index  - the index of the object.
  /// Return a handle to the object, or NULL on failure.
  FPDF_PAGEOBJECT Annot_GetObject(
    FPDF_ANNOTATION annot,
    int index,
  ) {
    return _Annot_GetObject(
      annot,
      index,
    );
  }

  late final _Annot_GetObjectPtr = _lookup<
          ffi
          .NativeFunction<FPDF_PAGEOBJECT Function(FPDF_ANNOTATION, ffi.Int)>>(
      'PDFIUM_FPDFAnnot_GetObject');
  late final _Annot_GetObject = _Annot_GetObjectPtr.asFunction<
      FPDF_PAGEOBJECT Function(FPDF_ANNOTATION, int)>();

  /// Experimental API.
  /// Remove the object in |annot| at |index|.
  /// annot  - handle to an annotation.
  /// index  - the index of the object to be removed.
  /// Return true if successful.
  int Annot_RemoveObject(
    FPDF_ANNOTATION annot,
    int index,
  ) {
    return _Annot_RemoveObject(
      annot,
      index,
    );
  }

  late final _Annot_RemoveObjectPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_ANNOTATION, ffi.Int)>>(
          'PDFIUM_FPDFAnnot_RemoveObject');
  late final _Annot_RemoveObject =
      _Annot_RemoveObjectPtr.asFunction<int Function(FPDF_ANNOTATION, int)>();

  /// Experimental API.
  /// Set the color of an annotation. Fails when called on annotations with
  /// appearance streams already defined; instead use
  /// FPDFPageObj_Set{Stroke|Fill}Color().
  /// annot    - handle to an annotation.
  /// type     - type of the color to be set.
  /// R, G, B  - buffer to hold the RGB value of the color. Ranges from 0 to 255.
  /// A        - buffer to hold the opacity. Ranges from 0 to 255.
  /// Returns true if successful.
  int Annot_SetColor(
    FPDF_ANNOTATION annot,
    int type,
    int R,
    int G,
    int B,
    int A,
  ) {
    return _Annot_SetColor(
      annot,
      type,
      R,
      G,
      B,
      A,
    );
  }

  late final _Annot_SetColorPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_ANNOTATION,
              ffi.Int32,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('PDFIUM_FPDFAnnot_SetColor');
  late final _Annot_SetColor = _Annot_SetColorPtr.asFunction<
      int Function(FPDF_ANNOTATION, int, int, int, int, int)>();

  /// Experimental API.
  /// Get the color of an annotation. If no color is specified, default to yellow
  /// for highlight annotation, black for all else. Fails when called on
  /// annotations with appearance streams already defined; instead use
  /// FPDFPageObj_Get{Stroke|Fill}Color().
  /// annot    - handle to an annotation.
  /// type     - type of the color requested.
  /// R, G, B  - buffer to hold the RGB value of the color. Ranges from 0 to 255.
  /// A        - buffer to hold the opacity. Ranges from 0 to 255.
  /// Returns true if successful.
  int Annot_GetColor(
    FPDF_ANNOTATION annot,
    int type,
    ffi.Pointer<ffi.UnsignedInt> R,
    ffi.Pointer<ffi.UnsignedInt> G,
    ffi.Pointer<ffi.UnsignedInt> B,
    ffi.Pointer<ffi.UnsignedInt> A,
  ) {
    return _Annot_GetColor(
      annot,
      type,
      R,
      G,
      B,
      A,
    );
  }

  late final _Annot_GetColorPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_ANNOTATION,
              ffi.Int32,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>)>>('PDFIUM_FPDFAnnot_GetColor');
  late final _Annot_GetColor = _Annot_GetColorPtr.asFunction<
      int Function(
          FPDF_ANNOTATION,
          int,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// Experimental API.
  /// Check if the annotation is of a type that has attachment points
  /// (i.e. quadpoints). Quadpoints are the vertices of the rectangle that
  /// encompasses the texts affected by the annotation. They provide the
  /// coordinates in the page where the annotation is attached. Only text markup
  /// annotations (i.e. highlight, strikeout, squiggly, and underline) and link
  /// annotations have quadpoints.
  /// annot  - handle to an annotation.
  /// Returns true if the annotation is of a type that has quadpoints, false
  /// otherwise.
  int Annot_HasAttachmentPoints(
    FPDF_ANNOTATION annot,
  ) {
    return _Annot_HasAttachmentPoints(
      annot,
    );
  }

  late final _Annot_HasAttachmentPointsPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_ANNOTATION)>>(
          'PDFIUM_FPDFAnnot_HasAttachmentPoints');
  late final _Annot_HasAttachmentPoints =
      _Annot_HasAttachmentPointsPtr.asFunction<int Function(FPDF_ANNOTATION)>();

  /// Experimental API.
  /// Replace the attachment points (i.e. quadpoints) set of an annotation at
  /// |quad_index|. This index needs to be within the result of
  /// FPDFAnnot_CountAttachmentPoints().
  /// If the annotation's appearance stream is defined and this annotation is of a
  /// type with quadpoints, then update the bounding box too if the new quadpoints
  /// define a bigger one.
  /// annot       - handle to an annotation.
  /// quad_index  - index of the set of quadpoints.
  /// quad_points - the quadpoints to be set.
  /// Returns true if successful.
  int Annot_SetAttachmentPoints(
    FPDF_ANNOTATION annot,
    int quad_index,
    ffi.Pointer<FS_QUADPOINTSF> quad_points,
  ) {
    return _Annot_SetAttachmentPoints(
      annot,
      quad_index,
      quad_points,
    );
  }

  late final _Annot_SetAttachmentPointsPtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(
                  FPDF_ANNOTATION, ffi.Size, ffi.Pointer<FS_QUADPOINTSF>)>>(
      'PDFIUM_FPDFAnnot_SetAttachmentPoints');
  late final _Annot_SetAttachmentPoints =
      _Annot_SetAttachmentPointsPtr.asFunction<
          int Function(FPDF_ANNOTATION, int, ffi.Pointer<FS_QUADPOINTSF>)>();

  /// Experimental API.
  /// Append to the list of attachment points (i.e. quadpoints) of an annotation.
  /// If the annotation's appearance stream is defined and this annotation is of a
  /// type with quadpoints, then update the bounding box too if the new quadpoints
  /// define a bigger one.
  /// annot       - handle to an annotation.
  /// quad_points - the quadpoints to be set.
  /// Returns true if successful.
  int Annot_AppendAttachmentPoints(
    FPDF_ANNOTATION annot,
    ffi.Pointer<FS_QUADPOINTSF> quad_points,
  ) {
    return _Annot_AppendAttachmentPoints(
      annot,
      quad_points,
    );
  }

  late final _Annot_AppendAttachmentPointsPtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(
                  FPDF_ANNOTATION, ffi.Pointer<FS_QUADPOINTSF>)>>(
      'PDFIUM_FPDFAnnot_AppendAttachmentPoints');
  late final _Annot_AppendAttachmentPoints = _Annot_AppendAttachmentPointsPtr
      .asFunction<int Function(FPDF_ANNOTATION, ffi.Pointer<FS_QUADPOINTSF>)>();

  /// Experimental API.
  /// Get the number of sets of quadpoints of an annotation.
  /// annot  - handle to an annotation.
  /// Returns the number of sets of quadpoints, or 0 on failure.
  int Annot_CountAttachmentPoints(
    FPDF_ANNOTATION annot,
  ) {
    return _Annot_CountAttachmentPoints(
      annot,
    );
  }

  late final _Annot_CountAttachmentPointsPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(FPDF_ANNOTATION)>>(
          'PDFIUM_FPDFAnnot_CountAttachmentPoints');
  late final _Annot_CountAttachmentPoints = _Annot_CountAttachmentPointsPtr
      .asFunction<int Function(FPDF_ANNOTATION)>();

  /// Experimental API.
  /// Get the attachment points (i.e. quadpoints) of an annotation.
  /// annot       - handle to an annotation.
  /// quad_index  - index of the set of quadpoints.
  /// quad_points - receives the quadpoints; must not be NULL.
  /// Returns true if successful.
  int Annot_GetAttachmentPoints(
    FPDF_ANNOTATION annot,
    int quad_index,
    ffi.Pointer<FS_QUADPOINTSF> quad_points,
  ) {
    return _Annot_GetAttachmentPoints(
      annot,
      quad_index,
      quad_points,
    );
  }

  late final _Annot_GetAttachmentPointsPtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(
                  FPDF_ANNOTATION, ffi.Size, ffi.Pointer<FS_QUADPOINTSF>)>>(
      'PDFIUM_FPDFAnnot_GetAttachmentPoints');
  late final _Annot_GetAttachmentPoints =
      _Annot_GetAttachmentPointsPtr.asFunction<
          int Function(FPDF_ANNOTATION, int, ffi.Pointer<FS_QUADPOINTSF>)>();

  /// Experimental API.
  /// Set the annotation rectangle defining the location of the annotation. If the
  /// annotation's appearance stream is defined and this annotation is of a type
  /// without quadpoints, then update the bounding box too if the new rectangle
  /// defines a bigger one.
  /// annot  - handle to an annotation.
  /// rect   - the annotation rectangle to be set.
  /// Returns true if successful.
  int Annot_SetRect(
    FPDF_ANNOTATION annot,
    ffi.Pointer<FS_RECTF> rect,
  ) {
    return _Annot_SetRect(
      annot,
      rect,
    );
  }

  late final _Annot_SetRectPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_ANNOTATION,
              ffi.Pointer<FS_RECTF>)>>('PDFIUM_FPDFAnnot_SetRect');
  late final _Annot_SetRect = _Annot_SetRectPtr.asFunction<
      int Function(FPDF_ANNOTATION, ffi.Pointer<FS_RECTF>)>();

  /// Experimental API.
  /// Get the annotation rectangle defining the location of the annotation.
  /// annot  - handle to an annotation.
  /// rect   - receives the rectangle; must not be NULL.
  /// Returns true if successful.
  int Annot_GetRect(
    FPDF_ANNOTATION annot,
    ffi.Pointer<FS_RECTF> rect,
  ) {
    return _Annot_GetRect(
      annot,
      rect,
    );
  }

  late final _Annot_GetRectPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_ANNOTATION,
              ffi.Pointer<FS_RECTF>)>>('PDFIUM_FPDFAnnot_GetRect');
  late final _Annot_GetRect = _Annot_GetRectPtr.asFunction<
      int Function(FPDF_ANNOTATION, ffi.Pointer<FS_RECTF>)>();

  /// Experimental API.
  /// Get the vertices of a polygon or polyline annotation. |buffer| is an array of
  /// points of the annotation. If |length| is less than the returned length, or
  /// |annot| or |buffer| is NULL, |buffer| will not be modified.
  /// annot  - handle to an annotation, as returned by e.g. FPDFPage_GetAnnot()
  /// buffer - buffer for holding the points.
  /// length - length of the buffer in points.
  /// Returns the number of points if the annotation is of type polygon or
  /// polyline, 0 otherwise.
  int Annot_GetVertices(
    FPDF_ANNOTATION annot,
    ffi.Pointer<FS_POINTF> buffer,
    int length,
  ) {
    return _Annot_GetVertices(
      annot,
      buffer,
      length,
    );
  }

  late final _Annot_GetVerticesPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_ANNOTATION, ffi.Pointer<FS_POINTF>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFAnnot_GetVertices');
  late final _Annot_GetVertices = _Annot_GetVerticesPtr.asFunction<
      int Function(FPDF_ANNOTATION, ffi.Pointer<FS_POINTF>, int)>();

  /// Experimental API.
  /// Get the number of paths in the ink list of an ink annotation.
  /// annot  - handle to an annotation, as returned by e.g. FPDFPage_GetAnnot()
  /// Returns the number of paths in the ink list if the annotation is of type ink,
  /// 0 otherwise.
  int Annot_GetInkListCount(
    FPDF_ANNOTATION annot,
  ) {
    return _Annot_GetInkListCount(
      annot,
    );
  }

  late final _Annot_GetInkListCountPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLong Function(FPDF_ANNOTATION)>>(
          'PDFIUM_FPDFAnnot_GetInkListCount');
  late final _Annot_GetInkListCount =
      _Annot_GetInkListCountPtr.asFunction<int Function(FPDF_ANNOTATION)>();

  /// Experimental API.
  /// Get a path in the ink list of an ink annotation. |buffer| is an array of
  /// points of the path. If |length| is less than the returned length, or |annot|
  /// or |buffer| is NULL, |buffer| will not be modified.
  /// annot  - handle to an annotation, as returned by e.g. FPDFPage_GetAnnot()
  /// path_index - index of the path
  /// buffer - buffer for holding the points.
  /// length - length of the buffer in points.
  /// Returns the number of points of the path if the annotation is of type ink, 0
  /// otherwise.
  int Annot_GetInkListPath(
    FPDF_ANNOTATION annot,
    int path_index,
    ffi.Pointer<FS_POINTF> buffer,
    int length,
  ) {
    return _Annot_GetInkListPath(
      annot,
      path_index,
      buffer,
      length,
    );
  }

  late final _Annot_GetInkListPathPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_ANNOTATION,
              ffi.UnsignedLong,
              ffi.Pointer<FS_POINTF>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFAnnot_GetInkListPath');
  late final _Annot_GetInkListPath = _Annot_GetInkListPathPtr.asFunction<
      int Function(FPDF_ANNOTATION, int, ffi.Pointer<FS_POINTF>, int)>();

  /// Experimental API.
  /// Get the starting and ending coordinates of a line annotation.
  /// annot  - handle to an annotation, as returned by e.g. FPDFPage_GetAnnot()
  /// start - starting point
  /// end - ending point
  /// Returns true if the annotation is of type line, |start| and |end| are not
  /// NULL, false otherwise.
  int Annot_GetLine(
    FPDF_ANNOTATION annot,
    ffi.Pointer<FS_POINTF> start,
    ffi.Pointer<FS_POINTF> end,
  ) {
    return _Annot_GetLine(
      annot,
      start,
      end,
    );
  }

  late final _Annot_GetLinePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_ANNOTATION, ffi.Pointer<FS_POINTF>,
              ffi.Pointer<FS_POINTF>)>>('PDFIUM_FPDFAnnot_GetLine');
  late final _Annot_GetLine = _Annot_GetLinePtr.asFunction<
      int Function(
          FPDF_ANNOTATION, ffi.Pointer<FS_POINTF>, ffi.Pointer<FS_POINTF>)>();

  /// Experimental API.
  /// Set the characteristics of the annotation's border (rounded rectangle).
  /// annot              - handle to an annotation
  /// horizontal_radius  - horizontal corner radius, in default user space units
  /// vertical_radius    - vertical corner radius, in default user space units
  /// border_width       - border width, in default user space units
  /// Returns true if setting the border for |annot| succeeds, false otherwise.
  /// If |annot| contains an appearance stream that overrides the border values,
  /// then the appearance stream will be removed on success.
  int Annot_SetBorder(
    FPDF_ANNOTATION annot,
    double horizontal_radius,
    double vertical_radius,
    double border_width,
  ) {
    return _Annot_SetBorder(
      annot,
      horizontal_radius,
      vertical_radius,
      border_width,
    );
  }

  late final _Annot_SetBorderPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_ANNOTATION, ffi.Float, ffi.Float,
              ffi.Float)>>('PDFIUM_FPDFAnnot_SetBorder');
  late final _Annot_SetBorder = _Annot_SetBorderPtr.asFunction<
      int Function(FPDF_ANNOTATION, double, double, double)>();

  /// Experimental API.
  /// Get the characteristics of the annotation's border (rounded rectangle).
  /// annot              - handle to an annotation
  /// horizontal_radius  - horizontal corner radius, in default user space units
  /// vertical_radius    - vertical corner radius, in default user space units
  /// border_width       - border width, in default user space units
  /// Returns true if |horizontal_radius|, |vertical_radius| and |border_width| are
  /// not NULL, false otherwise.
  int Annot_GetBorder(
    FPDF_ANNOTATION annot,
    ffi.Pointer<ffi.Float> horizontal_radius,
    ffi.Pointer<ffi.Float> vertical_radius,
    ffi.Pointer<ffi.Float> border_width,
  ) {
    return _Annot_GetBorder(
      annot,
      horizontal_radius,
      vertical_radius,
      border_width,
    );
  }

  late final _Annot_GetBorderPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_ANNOTATION,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('PDFIUM_FPDFAnnot_GetBorder');
  late final _Annot_GetBorder = _Annot_GetBorderPtr.asFunction<
      int Function(FPDF_ANNOTATION, ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>)>();

  /// Experimental API.
  /// Get the JavaScript of an event of the annotation's additional actions.
  /// |buffer| is only modified if |buflen| is large enough to hold the whole
  /// JavaScript string. If |buflen| is smaller, the total size of the JavaScript
  /// is still returned, but nothing is copied.  If there is no JavaScript for
  /// |event| in |annot|, an empty string is written to |buf| and 2 is returned,
  /// denoting the size of the null terminator in the buffer.  On other errors,
  /// nothing is written to |buffer| and 0 is returned.
  /// hHandle     -   handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment().
  /// annot       -   handle to an interactive form annotation.
  /// event       -   event type, one of the FPDF_ANNOT_AACTION_* values.
  /// buffer      -   buffer for holding the value string, encoded in UTF-16LE.
  /// buflen      -   length of the buffer in bytes.
  /// Returns the length of the string value in bytes, including the 2-byte
  /// null terminator.
  int Annot_GetFormAdditionalActionJavaScript(
    FPDF_FORMHANDLE hHandle,
    FPDF_ANNOTATION annot,
    int event,
    ffi.Pointer<FPDF_WCHAR> buffer,
    int buflen,
  ) {
    return _Annot_GetFormAdditionalActionJavaScript(
      hHandle,
      annot,
      event,
      buffer,
      buflen,
    );
  }

  late final _Annot_GetFormAdditionalActionJavaScriptPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedLong Function(FPDF_FORMHANDLE, FPDF_ANNOTATION,
                  ffi.Int, ffi.Pointer<FPDF_WCHAR>, ffi.UnsignedLong)>>(
      'PDFIUM_FPDFAnnot_GetFormAdditionalActionJavaScript');
  late final _Annot_GetFormAdditionalActionJavaScript =
      _Annot_GetFormAdditionalActionJavaScriptPtr.asFunction<
          int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION, int,
              ffi.Pointer<FPDF_WCHAR>, int)>();

  /// Experimental API.
  /// Check if |annot|'s dictionary has |key| as a key.
  /// annot  - handle to an annotation.
  /// key    - the key to look for, encoded in UTF-8.
  /// Returns true if |key| exists.
  int Annot_HasKey(
    FPDF_ANNOTATION annot,
    FPDF_BYTESTRING key,
  ) {
    return _Annot_HasKey(
      annot,
      key,
    );
  }

  late final _Annot_HasKeyPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_ANNOTATION, FPDF_BYTESTRING)>>('PDFIUM_FPDFAnnot_HasKey');
  late final _Annot_HasKey = _Annot_HasKeyPtr.asFunction<
      int Function(FPDF_ANNOTATION, FPDF_BYTESTRING)>();

  /// Experimental API.
  /// Get the type of the value corresponding to |key| in |annot|'s dictionary.
  /// annot  - handle to an annotation.
  /// key    - the key to look for, encoded in UTF-8.
  /// Returns the type of the dictionary value.
  int Annot_GetValueType(
    FPDF_ANNOTATION annot,
    FPDF_BYTESTRING key,
  ) {
    return _Annot_GetValueType(
      annot,
      key,
    );
  }

  late final _Annot_GetValueTypePtr = _lookup<
      ffi.NativeFunction<
          FPDF_OBJECT_TYPE Function(FPDF_ANNOTATION,
              FPDF_BYTESTRING)>>('PDFIUM_FPDFAnnot_GetValueType');
  late final _Annot_GetValueType = _Annot_GetValueTypePtr.asFunction<
      int Function(FPDF_ANNOTATION, FPDF_BYTESTRING)>();

  /// Experimental API.
  /// Set the string value corresponding to |key| in |annot|'s dictionary,
  /// overwriting the existing value if any. The value type would be
  /// FPDF_OBJECT_STRING after this function call succeeds.
  /// annot  - handle to an annotation.
  /// key    - the key to the dictionary entry to be set, encoded in UTF-8.
  /// value  - the string value to be set, encoded in UTF-16LE.
  /// Returns true if successful.
  int Annot_SetStringValue(
    FPDF_ANNOTATION annot,
    FPDF_BYTESTRING key,
    FPDF_WIDESTRING value,
  ) {
    return _Annot_SetStringValue(
      annot,
      key,
      value,
    );
  }

  late final _Annot_SetStringValuePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_ANNOTATION, FPDF_BYTESTRING,
              FPDF_WIDESTRING)>>('PDFIUM_FPDFAnnot_SetStringValue');
  late final _Annot_SetStringValue = _Annot_SetStringValuePtr.asFunction<
      int Function(FPDF_ANNOTATION, FPDF_BYTESTRING, FPDF_WIDESTRING)>();

  /// Experimental API.
  /// Get the string value corresponding to |key| in |annot|'s dictionary. |buffer|
  /// is only modified if |buflen| is longer than the length of contents. Note that
  /// if |key| does not exist in the dictionary or if |key|'s corresponding value
  /// in the dictionary is not a string (i.e. the value is not of type
  /// FPDF_OBJECT_STRING or FPDF_OBJECT_NAME), then an empty string would be copied
  /// to |buffer| and the return value would be 2. On other errors, nothing would
  /// be added to |buffer| and the return value would be 0.
  /// annot  - handle to an annotation.
  /// key    - the key to the requested dictionary entry, encoded in UTF-8.
  /// buffer - buffer for holding the value string, encoded in UTF-16LE.
  /// buflen - length of the buffer in bytes.
  /// Returns the length of the string value in bytes.
  int Annot_GetStringValue(
    FPDF_ANNOTATION annot,
    FPDF_BYTESTRING key,
    ffi.Pointer<FPDF_WCHAR> buffer,
    int buflen,
  ) {
    return _Annot_GetStringValue(
      annot,
      key,
      buffer,
      buflen,
    );
  }

  late final _Annot_GetStringValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_ANNOTATION,
              FPDF_BYTESTRING,
              ffi.Pointer<FPDF_WCHAR>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFAnnot_GetStringValue');
  late final _Annot_GetStringValue = _Annot_GetStringValuePtr.asFunction<
      int Function(
          FPDF_ANNOTATION, FPDF_BYTESTRING, ffi.Pointer<FPDF_WCHAR>, int)>();

  /// Experimental API.
  /// Get the float value corresponding to |key| in |annot|'s dictionary. Writes
  /// value to |value| and returns True if |key| exists in the dictionary and
  /// |key|'s corresponding value is a number (FPDF_OBJECT_NUMBER), False
  /// otherwise.
  /// annot  - handle to an annotation.
  /// key    - the key to the requested dictionary entry, encoded in UTF-8.
  /// value  - receives the value, must not be NULL.
  /// Returns True if value found, False otherwise.
  int Annot_GetNumberValue(
    FPDF_ANNOTATION annot,
    FPDF_BYTESTRING key,
    ffi.Pointer<ffi.Float> value,
  ) {
    return _Annot_GetNumberValue(
      annot,
      key,
      value,
    );
  }

  late final _Annot_GetNumberValuePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_ANNOTATION, FPDF_BYTESTRING,
              ffi.Pointer<ffi.Float>)>>('PDFIUM_FPDFAnnot_GetNumberValue');
  late final _Annot_GetNumberValue = _Annot_GetNumberValuePtr.asFunction<
      int Function(FPDF_ANNOTATION, FPDF_BYTESTRING, ffi.Pointer<ffi.Float>)>();

  /// Experimental API.
  /// Set the AP (appearance string) in |annot|'s dictionary for a given
  /// |appearanceMode|.
  /// annot          - handle to an annotation.
  /// appearanceMode - the appearance mode (normal, rollover or down) for which
  /// to get the AP.
  /// value          - the string value to be set, encoded in UTF-16LE. If
  /// nullptr is passed, the AP is cleared for that mode. If the
  /// mode is Normal, APs for all modes are cleared.
  /// Returns true if successful.
  int Annot_SetAP(
    FPDF_ANNOTATION annot,
    int appearanceMode,
    FPDF_WIDESTRING value,
  ) {
    return _Annot_SetAP(
      annot,
      appearanceMode,
      value,
    );
  }

  late final _Annot_SetAPPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_ANNOTATION, FPDF_ANNOT_APPEARANCEMODE,
              FPDF_WIDESTRING)>>('PDFIUM_FPDFAnnot_SetAP');
  late final _Annot_SetAP = _Annot_SetAPPtr.asFunction<
      int Function(FPDF_ANNOTATION, int, FPDF_WIDESTRING)>();

  /// Experimental API.
  /// Get the AP (appearance string) from |annot|'s dictionary for a given
  /// |appearanceMode|.
  /// |buffer| is only modified if |buflen| is large enough to hold the whole AP
  /// string. If |buflen| is smaller, the total size of the AP is still returned,
  /// but nothing is copied.
  /// If there is no appearance stream for |annot| in |appearanceMode|, an empty
  /// string is written to |buf| and 2 is returned.
  /// On other errors, nothing is written to |buffer| and 0 is returned.
  /// annot          - handle to an annotation.
  /// appearanceMode - the appearance mode (normal, rollover or down) for which
  /// to get the AP.
  /// buffer         - buffer for holding the value string, encoded in UTF-16LE.
  /// buflen         - length of the buffer in bytes.
  /// Returns the length of the string value in bytes.
  int Annot_GetAP(
    FPDF_ANNOTATION annot,
    int appearanceMode,
    ffi.Pointer<FPDF_WCHAR> buffer,
    int buflen,
  ) {
    return _Annot_GetAP(
      annot,
      appearanceMode,
      buffer,
      buflen,
    );
  }

  late final _Annot_GetAPPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_ANNOTATION,
              FPDF_ANNOT_APPEARANCEMODE,
              ffi.Pointer<FPDF_WCHAR>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFAnnot_GetAP');
  late final _Annot_GetAP = _Annot_GetAPPtr.asFunction<
      int Function(FPDF_ANNOTATION, int, ffi.Pointer<FPDF_WCHAR>, int)>();

  /// Experimental API.
  /// Get the annotation corresponding to |key| in |annot|'s dictionary. Common
  /// keys for linking annotations include "IRT" and "Popup". Must call
  /// FPDFPage_CloseAnnot() when the annotation returned by this function is no
  /// longer needed.
  /// annot  - handle to an annotation.
  /// key    - the key to the requested dictionary entry, encoded in UTF-8.
  /// Returns a handle to the linked annotation object, or NULL on failure.
  FPDF_ANNOTATION Annot_GetLinkedAnnot(
    FPDF_ANNOTATION annot,
    FPDF_BYTESTRING key,
  ) {
    return _Annot_GetLinkedAnnot(
      annot,
      key,
    );
  }

  late final _Annot_GetLinkedAnnotPtr = _lookup<
      ffi.NativeFunction<
          FPDF_ANNOTATION Function(FPDF_ANNOTATION,
              FPDF_BYTESTRING)>>('PDFIUM_FPDFAnnot_GetLinkedAnnot');
  late final _Annot_GetLinkedAnnot = _Annot_GetLinkedAnnotPtr.asFunction<
      FPDF_ANNOTATION Function(FPDF_ANNOTATION, FPDF_BYTESTRING)>();

  /// Experimental API.
  /// Get the annotation flags of |annot|.
  /// annot    - handle to an annotation.
  /// Returns the annotation flags.
  int Annot_GetFlags(
    FPDF_ANNOTATION annot,
  ) {
    return _Annot_GetFlags(
      annot,
    );
  }

  late final _Annot_GetFlagsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_ANNOTATION)>>(
          'PDFIUM_FPDFAnnot_GetFlags');
  late final _Annot_GetFlags =
      _Annot_GetFlagsPtr.asFunction<int Function(FPDF_ANNOTATION)>();

  /// Experimental API.
  /// Set the |annot|'s flags to be of the value |flags|.
  /// annot      - handle to an annotation.
  /// flags      - the flag values to be set.
  /// Returns true if successful.
  int Annot_SetFlags(
    FPDF_ANNOTATION annot,
    int flags,
  ) {
    return _Annot_SetFlags(
      annot,
      flags,
    );
  }

  late final _Annot_SetFlagsPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_ANNOTATION, ffi.Int)>>(
          'PDFIUM_FPDFAnnot_SetFlags');
  late final _Annot_SetFlags =
      _Annot_SetFlagsPtr.asFunction<int Function(FPDF_ANNOTATION, int)>();

  /// Experimental API.
  /// Get the annotation flags of |annot|.
  /// hHandle     -   handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment().
  /// annot       -   handle to an interactive form annotation.
  /// Returns the annotation flags specific to interactive forms.
  int Annot_GetFormFieldFlags(
    FPDF_FORMHANDLE handle,
    FPDF_ANNOTATION annot,
  ) {
    return _Annot_GetFormFieldFlags(
      handle,
      annot,
    );
  }

  late final _Annot_GetFormFieldFlagsPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION)>>(
      'PDFIUM_FPDFAnnot_GetFormFieldFlags');
  late final _Annot_GetFormFieldFlags = _Annot_GetFormFieldFlagsPtr.asFunction<
      int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION)>();

  /// Experimental API.
  /// Sets the form field flags for an interactive form annotation.
  /// handle       -   the handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment().
  /// annot        -   handle to an interactive form annotation.
  /// flags        -   the form field flags to be set.
  /// Returns true if successful.
  int Annot_SetFormFieldFlags(
    FPDF_FORMHANDLE handle,
    FPDF_ANNOTATION annot,
    int flags,
  ) {
    return _Annot_SetFormFieldFlags(
      handle,
      annot,
      flags,
    );
  }

  late final _Annot_SetFormFieldFlagsPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_FORMHANDLE, FPDF_ANNOTATION,
              ffi.Int)>>('PDFIUM_FPDFAnnot_SetFormFieldFlags');
  late final _Annot_SetFormFieldFlags = _Annot_SetFormFieldFlagsPtr.asFunction<
      int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION, int)>();

  /// Experimental API.
  /// Retrieves an interactive form annotation whose rectangle contains a given
  /// point on a page. Must call FPDFPage_CloseAnnot() when the annotation returned
  /// is no longer needed.
  /// hHandle     -   handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment().
  /// page        -   handle to the page, returned by FPDF_LoadPage function.
  /// point       -   position in PDF "user space".
  /// Returns the interactive form annotation whose rectangle contains the given
  /// coordinates on the page. If there is no such annotation, return NULL.
  FPDF_ANNOTATION Annot_GetFormFieldAtPoint(
    FPDF_FORMHANDLE hHandle,
    FPDF_PAGE page,
    ffi.Pointer<FS_POINTF> point,
  ) {
    return _Annot_GetFormFieldAtPoint(
      hHandle,
      page,
      point,
    );
  }

  late final _Annot_GetFormFieldAtPointPtr = _lookup<
      ffi.NativeFunction<
          FPDF_ANNOTATION Function(FPDF_FORMHANDLE, FPDF_PAGE,
              ffi.Pointer<FS_POINTF>)>>('PDFIUM_FPDFAnnot_GetFormFieldAtPoint');
  late final _Annot_GetFormFieldAtPoint =
      _Annot_GetFormFieldAtPointPtr.asFunction<
          FPDF_ANNOTATION Function(
              FPDF_FORMHANDLE, FPDF_PAGE, ffi.Pointer<FS_POINTF>)>();

  /// Experimental API.
  /// Gets the name of |annot|, which is an interactive form annotation.
  /// |buffer| is only modified if |buflen| is longer than the length of contents.
  /// In case of error, nothing will be added to |buffer| and the return value will
  /// be 0. Note that return value of empty string is 2 for "\0\0".
  /// hHandle     -   handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment().
  /// annot       -   handle to an interactive form annotation.
  /// buffer      -   buffer for holding the name string, encoded in UTF-16LE.
  /// buflen      -   length of the buffer in bytes.
  /// Returns the length of the string value in bytes.
  int Annot_GetFormFieldName(
    FPDF_FORMHANDLE hHandle,
    FPDF_ANNOTATION annot,
    ffi.Pointer<FPDF_WCHAR> buffer,
    int buflen,
  ) {
    return _Annot_GetFormFieldName(
      hHandle,
      annot,
      buffer,
      buflen,
    );
  }

  late final _Annot_GetFormFieldNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_FORMHANDLE,
              FPDF_ANNOTATION,
              ffi.Pointer<FPDF_WCHAR>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFAnnot_GetFormFieldName');
  late final _Annot_GetFormFieldName = _Annot_GetFormFieldNamePtr.asFunction<
      int Function(
          FPDF_FORMHANDLE, FPDF_ANNOTATION, ffi.Pointer<FPDF_WCHAR>, int)>();

  /// Experimental API.
  /// Gets the alternate name of |annot|, which is an interactive form annotation.
  /// |buffer| is only modified if |buflen| is longer than the length of contents.
  /// In case of error, nothing will be added to |buffer| and the return value will
  /// be 0. Note that return value of empty string is 2 for "\0\0".
  /// hHandle     -   handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment().
  /// annot       -   handle to an interactive form annotation.
  /// buffer      -   buffer for holding the alternate name string, encoded in
  /// UTF-16LE.
  /// buflen      -   length of the buffer in bytes.
  /// Returns the length of the string value in bytes.
  int Annot_GetFormFieldAlternateName(
    FPDF_FORMHANDLE hHandle,
    FPDF_ANNOTATION annot,
    ffi.Pointer<FPDF_WCHAR> buffer,
    int buflen,
  ) {
    return _Annot_GetFormFieldAlternateName(
      hHandle,
      annot,
      buffer,
      buflen,
    );
  }

  late final _Annot_GetFormFieldAlternateNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_FORMHANDLE,
              FPDF_ANNOTATION,
              ffi.Pointer<FPDF_WCHAR>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFAnnot_GetFormFieldAlternateName');
  late final _Annot_GetFormFieldAlternateName =
      _Annot_GetFormFieldAlternateNamePtr.asFunction<
          int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION,
              ffi.Pointer<FPDF_WCHAR>, int)>();

  /// Experimental API.
  /// Gets the form field type of |annot|, which is an interactive form annotation.
  /// hHandle     -   handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment().
  /// annot       -   handle to an interactive form annotation.
  /// Returns the type of the form field (one of the FPDF_FORMFIELD_* values) on
  /// success. Returns -1 on error.
  /// See field types in fpdf_formfill.h.
  int Annot_GetFormFieldType(
    FPDF_FORMHANDLE hHandle,
    FPDF_ANNOTATION annot,
  ) {
    return _Annot_GetFormFieldType(
      hHandle,
      annot,
    );
  }

  late final _Annot_GetFormFieldTypePtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION)>>(
      'PDFIUM_FPDFAnnot_GetFormFieldType');
  late final _Annot_GetFormFieldType = _Annot_GetFormFieldTypePtr.asFunction<
      int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION)>();

  /// Experimental API.
  /// Gets the value of |annot|, which is an interactive form annotation.
  /// |buffer| is only modified if |buflen| is longer than the length of contents.
  /// In case of error, nothing will be added to |buffer| and the return value will
  /// be 0. Note that return value of empty string is 2 for "\0\0".
  /// hHandle     -   handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment().
  /// annot       -   handle to an interactive form annotation.
  /// buffer      -   buffer for holding the value string, encoded in UTF-16LE.
  /// buflen      -   length of the buffer in bytes.
  /// Returns the length of the string value in bytes.
  int Annot_GetFormFieldValue(
    FPDF_FORMHANDLE hHandle,
    FPDF_ANNOTATION annot,
    ffi.Pointer<FPDF_WCHAR> buffer,
    int buflen,
  ) {
    return _Annot_GetFormFieldValue(
      hHandle,
      annot,
      buffer,
      buflen,
    );
  }

  late final _Annot_GetFormFieldValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_FORMHANDLE,
              FPDF_ANNOTATION,
              ffi.Pointer<FPDF_WCHAR>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFAnnot_GetFormFieldValue');
  late final _Annot_GetFormFieldValue = _Annot_GetFormFieldValuePtr.asFunction<
      int Function(
          FPDF_FORMHANDLE, FPDF_ANNOTATION, ffi.Pointer<FPDF_WCHAR>, int)>();

  /// Experimental API.
  /// Get the number of options in the |annot|'s "Opt" dictionary. Intended for
  /// use with listbox and combobox widget annotations.
  /// hHandle - handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment.
  /// annot   - handle to an annotation.
  /// Returns the number of options in "Opt" dictionary on success. Return value
  /// will be -1 if annotation does not have an "Opt" dictionary or other error.
  int Annot_GetOptionCount(
    FPDF_FORMHANDLE hHandle,
    FPDF_ANNOTATION annot,
  ) {
    return _Annot_GetOptionCount(
      hHandle,
      annot,
    );
  }

  late final _Annot_GetOptionCountPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION)>>(
      'PDFIUM_FPDFAnnot_GetOptionCount');
  late final _Annot_GetOptionCount = _Annot_GetOptionCountPtr.asFunction<
      int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION)>();

  /// Experimental API.
  /// Get the string value for the label of the option at |index| in |annot|'s
  /// "Opt" dictionary. Intended for use with listbox and combobox widget
  /// annotations. |buffer| is only modified if |buflen| is longer than the length
  /// of contents. If index is out of range or in case of other error, nothing
  /// will be added to |buffer| and the return value will be 0. Note that
  /// return value of empty string is 2 for "\0\0".
  /// hHandle - handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment.
  /// annot   - handle to an annotation.
  /// index   - numeric index of the option in the "Opt" array
  /// buffer  - buffer for holding the value string, encoded in UTF-16LE.
  /// buflen  - length of the buffer in bytes.
  /// Returns the length of the string value in bytes.
  /// If |annot| does not have an "Opt" array, |index| is out of range or if any
  /// other error occurs, returns 0.
  int Annot_GetOptionLabel(
    FPDF_FORMHANDLE hHandle,
    FPDF_ANNOTATION annot,
    int index,
    ffi.Pointer<FPDF_WCHAR> buffer,
    int buflen,
  ) {
    return _Annot_GetOptionLabel(
      hHandle,
      annot,
      index,
      buffer,
      buflen,
    );
  }

  late final _Annot_GetOptionLabelPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_FORMHANDLE,
              FPDF_ANNOTATION,
              ffi.Int,
              ffi.Pointer<FPDF_WCHAR>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFAnnot_GetOptionLabel');
  late final _Annot_GetOptionLabel = _Annot_GetOptionLabelPtr.asFunction<
      int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION, int,
          ffi.Pointer<FPDF_WCHAR>, int)>();

  /// Experimental API.
  /// Determine whether or not the option at |index| in |annot|'s "Opt" dictionary
  /// is selected. Intended for use with listbox and combobox widget annotations.
  /// handle  - handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment.
  /// annot   - handle to an annotation.
  /// index   - numeric index of the option in the "Opt" array.
  /// Returns true if the option at |index| in |annot|'s "Opt" dictionary is
  /// selected, false otherwise.
  int Annot_IsOptionSelected(
    FPDF_FORMHANDLE handle,
    FPDF_ANNOTATION annot,
    int index,
  ) {
    return _Annot_IsOptionSelected(
      handle,
      annot,
      index,
    );
  }

  late final _Annot_IsOptionSelectedPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_FORMHANDLE, FPDF_ANNOTATION,
              ffi.Int)>>('PDFIUM_FPDFAnnot_IsOptionSelected');
  late final _Annot_IsOptionSelected = _Annot_IsOptionSelectedPtr.asFunction<
      int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION, int)>();

  /// Experimental API.
  /// Get the float value of the font size for an |annot| with variable text.
  /// If 0, the font is to be auto-sized: its size is computed as a function of
  /// the height of the annotation rectangle.
  /// hHandle - handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment.
  /// annot   - handle to an annotation.
  /// value   - Required. Float which will be set to font size on success.
  /// Returns true if the font size was set in |value|, false on error or if
  /// |value| not provided.
  int Annot_GetFontSize(
    FPDF_FORMHANDLE hHandle,
    FPDF_ANNOTATION annot,
    ffi.Pointer<ffi.Float> value,
  ) {
    return _Annot_GetFontSize(
      hHandle,
      annot,
      value,
    );
  }

  late final _Annot_GetFontSizePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_FORMHANDLE, FPDF_ANNOTATION,
              ffi.Pointer<ffi.Float>)>>('PDFIUM_FPDFAnnot_GetFontSize');
  late final _Annot_GetFontSize = _Annot_GetFontSizePtr.asFunction<
      int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION, ffi.Pointer<ffi.Float>)>();

  /// Experimental API.
  /// Set the text color of an annotation.
  /// handle   - handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment.
  /// annot    - handle to an annotation.
  /// R        - the red component for the text color.
  /// G        - the green component for the text color.
  /// B        - the blue component for the text color.
  /// Returns true if successful.
  /// Currently supported subtypes: freetext.
  /// The range for the color components is 0 to 255.
  int Annot_SetFontColor(
    FPDF_FORMHANDLE handle,
    FPDF_ANNOTATION annot,
    int R,
    int G,
    int B,
  ) {
    return _Annot_SetFontColor(
      handle,
      annot,
      R,
      G,
      B,
    );
  }

  late final _Annot_SetFontColorPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_FORMHANDLE,
              FPDF_ANNOTATION,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('PDFIUM_FPDFAnnot_SetFontColor');
  late final _Annot_SetFontColor = _Annot_SetFontColorPtr.asFunction<
      int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION, int, int, int)>();

  /// Experimental API.
  /// Get the RGB value of the font color for an |annot| with variable text.
  /// hHandle  - handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment.
  /// annot    - handle to an annotation.
  /// R, G, B  - buffer to hold the RGB value of the color. Ranges from 0 to 255.
  /// Returns true if the font color was set, false on error or if the font
  /// color was not provided.
  int Annot_GetFontColor(
    FPDF_FORMHANDLE hHandle,
    FPDF_ANNOTATION annot,
    ffi.Pointer<ffi.UnsignedInt> R,
    ffi.Pointer<ffi.UnsignedInt> G,
    ffi.Pointer<ffi.UnsignedInt> B,
  ) {
    return _Annot_GetFontColor(
      hHandle,
      annot,
      R,
      G,
      B,
    );
  }

  late final _Annot_GetFontColorPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_FORMHANDLE,
              FPDF_ANNOTATION,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>)>>('PDFIUM_FPDFAnnot_GetFontColor');
  late final _Annot_GetFontColor = _Annot_GetFontColorPtr.asFunction<
      int Function(
          FPDF_FORMHANDLE,
          FPDF_ANNOTATION,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// Experimental API.
  /// Determine if |annot| is a form widget that is checked. Intended for use with
  /// checkbox and radio button widgets.
  /// hHandle - handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment.
  /// annot   - handle to an annotation.
  /// Returns true if |annot| is a form widget and is checked, false otherwise.
  int Annot_IsChecked(
    FPDF_FORMHANDLE hHandle,
    FPDF_ANNOTATION annot,
  ) {
    return _Annot_IsChecked(
      hHandle,
      annot,
    );
  }

  late final _Annot_IsCheckedPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_FORMHANDLE, FPDF_ANNOTATION)>>('PDFIUM_FPDFAnnot_IsChecked');
  late final _Annot_IsChecked = _Annot_IsCheckedPtr.asFunction<
      int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION)>();

  /// Experimental API.
  /// Set the list of focusable annotation subtypes. Annotations of subtype
  /// FPDF_ANNOT_WIDGET are by default focusable. New subtypes set using this API
  /// will override the existing subtypes.
  /// hHandle  - handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment.
  /// subtypes - list of annotation subtype which can be tabbed over.
  /// count    - total number of annotation subtype in list.
  /// Returns true if list of annotation subtype is set successfully, false
  /// otherwise.
  int Annot_SetFocusableSubtypes(
    FPDF_FORMHANDLE hHandle,
    ffi.Pointer<FPDF_ANNOTATION_SUBTYPE> subtypes,
    int count,
  ) {
    return _Annot_SetFocusableSubtypes(
      hHandle,
      subtypes,
      count,
    );
  }

  late final _Annot_SetFocusableSubtypesPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_FORMHANDLE,
              ffi.Pointer<FPDF_ANNOTATION_SUBTYPE>,
              ffi.Size)>>('PDFIUM_FPDFAnnot_SetFocusableSubtypes');
  late final _Annot_SetFocusableSubtypes =
      _Annot_SetFocusableSubtypesPtr.asFunction<
          int Function(
              FPDF_FORMHANDLE, ffi.Pointer<FPDF_ANNOTATION_SUBTYPE>, int)>();

  /// Experimental API.
  /// Get the count of focusable annotation subtypes as set by host
  /// for a |hHandle|.
  /// hHandle  - handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment.
  /// Returns the count of focusable annotation subtypes or -1 on error.
  /// Note : Annotations of type FPDF_ANNOT_WIDGET are by default focusable.
  int Annot_GetFocusableSubtypesCount(
    FPDF_FORMHANDLE hHandle,
  ) {
    return _Annot_GetFocusableSubtypesCount(
      hHandle,
    );
  }

  late final _Annot_GetFocusableSubtypesCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_FORMHANDLE)>>(
          'PDFIUM_FPDFAnnot_GetFocusableSubtypesCount');
  late final _Annot_GetFocusableSubtypesCount =
      _Annot_GetFocusableSubtypesCountPtr.asFunction<
          int Function(FPDF_FORMHANDLE)>();

  /// Experimental API.
  /// Get the list of focusable annotation subtype as set by host.
  /// hHandle  - handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment.
  /// subtypes - receives the list of annotation subtype which can be tabbed
  /// over. Caller must have allocated |subtypes| more than or
  /// equal to the count obtained from
  /// FPDFAnnot_GetFocusableSubtypesCount() API.
  /// count    - size of |subtypes|.
  /// Returns true on success and set list of annotation subtype to |subtypes|,
  /// false otherwise.
  /// Note : Annotations of type FPDF_ANNOT_WIDGET are by default focusable.
  int Annot_GetFocusableSubtypes(
    FPDF_FORMHANDLE hHandle,
    ffi.Pointer<FPDF_ANNOTATION_SUBTYPE> subtypes,
    int count,
  ) {
    return _Annot_GetFocusableSubtypes(
      hHandle,
      subtypes,
      count,
    );
  }

  late final _Annot_GetFocusableSubtypesPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_FORMHANDLE,
              ffi.Pointer<FPDF_ANNOTATION_SUBTYPE>,
              ffi.Size)>>('PDFIUM_FPDFAnnot_GetFocusableSubtypes');
  late final _Annot_GetFocusableSubtypes =
      _Annot_GetFocusableSubtypesPtr.asFunction<
          int Function(
              FPDF_FORMHANDLE, ffi.Pointer<FPDF_ANNOTATION_SUBTYPE>, int)>();

  /// Experimental API.
  /// Gets FPDF_LINK object for |annot|. Intended to use for link annotations.
  /// annot   - handle to an annotation.
  /// Returns FPDF_LINK from the FPDF_ANNOTATION and NULL on failure,
  /// if the input annot is NULL or input annot's subtype is not link.
  FPDF_LINK Annot_GetLink(
    FPDF_ANNOTATION annot,
  ) {
    return _Annot_GetLink(
      annot,
    );
  }

  late final _Annot_GetLinkPtr =
      _lookup<ffi.NativeFunction<FPDF_LINK Function(FPDF_ANNOTATION)>>(
          'PDFIUM_FPDFAnnot_GetLink');
  late final _Annot_GetLink =
      _Annot_GetLinkPtr.asFunction<FPDF_LINK Function(FPDF_ANNOTATION)>();

  /// Experimental API.
  /// Gets the count of annotations in the |annot|'s control group.
  /// A group of interactive form annotations is collectively called a form
  /// control group. Here, |annot|, an interactive form annotation, should be
  /// either a radio button or a checkbox.
  /// hHandle - handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment.
  /// annot   - handle to an annotation.
  /// Returns number of controls in its control group or -1 on error.
  int Annot_GetFormControlCount(
    FPDF_FORMHANDLE hHandle,
    FPDF_ANNOTATION annot,
  ) {
    return _Annot_GetFormControlCount(
      hHandle,
      annot,
    );
  }

  late final _Annot_GetFormControlCountPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION)>>(
      'PDFIUM_FPDFAnnot_GetFormControlCount');
  late final _Annot_GetFormControlCount = _Annot_GetFormControlCountPtr
      .asFunction<int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION)>();

  /// Experimental API.
  /// Gets the index of |annot| in |annot|'s control group.
  /// A group of interactive form annotations is collectively called a form
  /// control group. Here, |annot|, an interactive form annotation, should be
  /// either a radio button or a checkbox.
  /// hHandle - handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment.
  /// annot   - handle to an annotation.
  /// Returns index of a given |annot| in its control group or -1 on error.
  int Annot_GetFormControlIndex(
    FPDF_FORMHANDLE hHandle,
    FPDF_ANNOTATION annot,
  ) {
    return _Annot_GetFormControlIndex(
      hHandle,
      annot,
    );
  }

  late final _Annot_GetFormControlIndexPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION)>>(
      'PDFIUM_FPDFAnnot_GetFormControlIndex');
  late final _Annot_GetFormControlIndex = _Annot_GetFormControlIndexPtr
      .asFunction<int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION)>();

  /// Experimental API.
  /// Gets the export value of |annot| which is an interactive form annotation.
  /// Intended for use with radio button and checkbox widget annotations.
  /// |buffer| is only modified if |buflen| is longer than the length of contents.
  /// In case of error, nothing will be added to |buffer| and the return value
  /// will be 0. Note that return value of empty string is 2 for "\0\0".
  /// hHandle     -   handle to the form fill module, returned by
  /// FPDFDOC_InitFormFillEnvironment().
  /// annot       -   handle to an interactive form annotation.
  /// buffer      -   buffer for holding the value string, encoded in UTF-16LE.
  /// buflen      -   length of the buffer in bytes.
  /// Returns the length of the string value in bytes.
  int Annot_GetFormFieldExportValue(
    FPDF_FORMHANDLE hHandle,
    FPDF_ANNOTATION annot,
    ffi.Pointer<FPDF_WCHAR> buffer,
    int buflen,
  ) {
    return _Annot_GetFormFieldExportValue(
      hHandle,
      annot,
      buffer,
      buflen,
    );
  }

  late final _Annot_GetFormFieldExportValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_FORMHANDLE,
              FPDF_ANNOTATION,
              ffi.Pointer<FPDF_WCHAR>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFAnnot_GetFormFieldExportValue');
  late final _Annot_GetFormFieldExportValue =
      _Annot_GetFormFieldExportValuePtr.asFunction<
          int Function(FPDF_FORMHANDLE, FPDF_ANNOTATION,
              ffi.Pointer<FPDF_WCHAR>, int)>();

  /// Experimental API.
  /// Add a URI action to |annot|, overwriting the existing action, if any.
  /// annot  - handle to a link annotation.
  /// uri    - the URI to be set, encoded in 7-bit ASCII.
  /// Returns true if successful.
  int Annot_SetURI(
    FPDF_ANNOTATION annot,
    ffi.Pointer<ffi.Char> uri,
  ) {
    return _Annot_SetURI(
      annot,
      uri,
    );
  }

  late final _Annot_SetURIPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_ANNOTATION,
              ffi.Pointer<ffi.Char>)>>('PDFIUM_FPDFAnnot_SetURI');
  late final _Annot_SetURI = _Annot_SetURIPtr.asFunction<
      int Function(FPDF_ANNOTATION, ffi.Pointer<ffi.Char>)>();

  /// Experimental API.
  /// Get the attachment from |annot|.
  /// annot - handle to a file annotation.
  /// Returns the handle to the attachment object, or NULL on failure.
  FPDF_ATTACHMENT Annot_GetFileAttachment(
    FPDF_ANNOTATION annot,
  ) {
    return _Annot_GetFileAttachment(
      annot,
    );
  }

  late final _Annot_GetFileAttachmentPtr =
      _lookup<ffi.NativeFunction<FPDF_ATTACHMENT Function(FPDF_ANNOTATION)>>(
          'PDFIUM_FPDFAnnot_GetFileAttachment');
  late final _Annot_GetFileAttachment = _Annot_GetFileAttachmentPtr.asFunction<
      FPDF_ATTACHMENT Function(FPDF_ANNOTATION)>();

  /// Experimental API.
  /// Add an embedded file with |name| to |annot|.
  /// annot    - handle to a file annotation.
  /// name     - name of the new attachment.
  /// Returns a handle to the new attachment object, or NULL on failure.
  FPDF_ATTACHMENT Annot_AddFileAttachment(
    FPDF_ANNOTATION annot,
    FPDF_WIDESTRING name,
  ) {
    return _Annot_AddFileAttachment(
      annot,
      name,
    );
  }

  late final _Annot_AddFileAttachmentPtr = _lookup<
      ffi.NativeFunction<
          FPDF_ATTACHMENT Function(FPDF_ANNOTATION,
              FPDF_WIDESTRING)>>('PDFIUM_FPDFAnnot_AddFileAttachment');
  late final _Annot_AddFileAttachment = _Annot_AddFileAttachmentPtr.asFunction<
      FPDF_ATTACHMENT Function(FPDF_ANNOTATION, FPDF_WIDESTRING)>();

  /// Flatten annotations and form fields into the page contents.
  /// page  - handle to the page.
  /// nFlag - One of the |FLAT_*| values denoting the page usage.
  /// Returns one of the |FLATTEN_*| values.
  /// Currently, all failures return |FLATTEN_FAIL| with no indication of the
  /// cause.
  int Page_Flatten(
    FPDF_PAGE page,
    int nFlag,
  ) {
    return _Page_Flatten(
      page,
      nFlag,
    );
  }

  late final _Page_FlattenPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGE, ffi.Int)>>(
          'PDFIUM_FPDFPage_Flatten');
  late final _Page_Flatten =
      _Page_FlattenPtr.asFunction<int Function(FPDF_PAGE, int)>();

  /// Get the character index in |text_page| internal character list.
  /// text_page  - a text page information structure.
  /// nTextIndex - index of the text returned from FPDFText_GetText().
  /// Returns the index of the character in internal character list. -1 for error.
  int Text_GetCharIndexFromTextIndex(
    FPDF_TEXTPAGE text_page,
    int nTextIndex,
  ) {
    return _Text_GetCharIndexFromTextIndex(
      text_page,
      nTextIndex,
    );
  }

  late final _Text_GetCharIndexFromTextIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_TEXTPAGE, ffi.Int)>>(
          'PDFIUM_FPDFText_GetCharIndexFromTextIndex');
  late final _Text_GetCharIndexFromTextIndex =
      _Text_GetCharIndexFromTextIndexPtr.asFunction<
          int Function(FPDF_TEXTPAGE, int)>();

  /// Get the text index in |text_page| internal character list.
  /// text_page  - a text page information structure.
  /// nCharIndex - index of the character in internal character list.
  /// Returns the index of the text returned from FPDFText_GetText(). -1 for error.
  int Text_GetTextIndexFromCharIndex(
    FPDF_TEXTPAGE text_page,
    int nCharIndex,
  ) {
    return _Text_GetTextIndexFromCharIndex(
      text_page,
      nCharIndex,
    );
  }

  late final _Text_GetTextIndexFromCharIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_TEXTPAGE, ffi.Int)>>(
          'PDFIUM_FPDFText_GetTextIndexFromCharIndex');
  late final _Text_GetTextIndexFromCharIndex =
      _Text_GetTextIndexFromCharIndexPtr.asFunction<
          int Function(FPDF_TEXTPAGE, int)>();

  /// Function: FPDF_SaveAsCopy
  /// Saves the copy of specified document in custom way.
  /// Parameters:
  /// document        -   Handle to document, as returned by
  /// FPDF_LoadDocument() or FPDF_CreateNewDocument().
  /// pFileWrite      -   A pointer to a custom file write structure.
  /// flags           -   Flags above that affect how the PDF gets saved.
  /// Pass in 0 when there are no flags.
  /// Return value:
  /// TRUE for succeed, FALSE for failed.
  int SaveAsCopy(
    FPDF_DOCUMENT document,
    ffi.Pointer<FPDF_FILEWRITE> pFileWrite,
    int flags,
  ) {
    return _SaveAsCopy(
      document,
      pFileWrite,
      flags,
    );
  }

  late final _SaveAsCopyPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_DOCUMENT, ffi.Pointer<FPDF_FILEWRITE>,
              FPDF_DWORD)>>('PDFIUM_FPDF_SaveAsCopy');
  late final _SaveAsCopy = _SaveAsCopyPtr.asFunction<
      int Function(FPDF_DOCUMENT, ffi.Pointer<FPDF_FILEWRITE>, int)>();

  /// Function: FPDF_SaveWithVersion
  /// Same as FPDF_SaveAsCopy(), except the file version of the
  /// saved document can be specified by the caller.
  /// Parameters:
  /// document        -   Handle to document.
  /// pFileWrite      -   A pointer to a custom file write structure.
  /// flags           -   The creating flags.
  /// fileVersion     -   The PDF file version. File version: 14 for 1.4,
  /// 15 for 1.5, ...
  /// Return value:
  /// TRUE if succeed, FALSE if failed.
  int SaveWithVersion(
    FPDF_DOCUMENT document,
    ffi.Pointer<FPDF_FILEWRITE> pFileWrite,
    int flags,
    int fileVersion,
  ) {
    return _SaveWithVersion(
      document,
      pFileWrite,
      flags,
      fileVersion,
    );
  }

  late final _SaveWithVersionPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_DOCUMENT, ffi.Pointer<FPDF_FILEWRITE>,
              FPDF_DWORD, ffi.Int)>>('PDFIUM_FPDF_SaveWithVersion');
  late final _SaveWithVersion = _SaveWithVersionPtr.asFunction<
      int Function(FPDF_DOCUMENT, ffi.Pointer<FPDF_FILEWRITE>, int, int)>();

  /// Get the first child of |bookmark|, or the first top-level bookmark item.
  /// document - handle to the document.
  /// bookmark - handle to the current bookmark. Pass NULL for the first top
  /// level item.
  /// Returns a handle to the first child of |bookmark| or the first top-level
  /// bookmark item. NULL if no child or top-level bookmark found.
  /// Note that another name for the bookmarks is the document outline, as
  /// described in ISO 32000-1:2008, section 12.3.3.
  FPDF_BOOKMARK Bookmark_GetFirstChild(
    FPDF_DOCUMENT document,
    FPDF_BOOKMARK bookmark,
  ) {
    return _Bookmark_GetFirstChild(
      document,
      bookmark,
    );
  }

  late final _Bookmark_GetFirstChildPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOKMARK Function(FPDF_DOCUMENT,
              FPDF_BOOKMARK)>>('PDFIUM_FPDFBookmark_GetFirstChild');
  late final _Bookmark_GetFirstChild = _Bookmark_GetFirstChildPtr.asFunction<
      FPDF_BOOKMARK Function(FPDF_DOCUMENT, FPDF_BOOKMARK)>();

  /// Get the next sibling of |bookmark|.
  /// document - handle to the document.
  /// bookmark - handle to the current bookmark.
  /// Returns a handle to the next sibling of |bookmark|, or NULL if this is the
  /// last bookmark at this level.
  /// Note that the caller is responsible for handling circular bookmark
  /// references, as may arise from malformed documents.
  FPDF_BOOKMARK Bookmark_GetNextSibling(
    FPDF_DOCUMENT document,
    FPDF_BOOKMARK bookmark,
  ) {
    return _Bookmark_GetNextSibling(
      document,
      bookmark,
    );
  }

  late final _Bookmark_GetNextSiblingPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOKMARK Function(FPDF_DOCUMENT,
              FPDF_BOOKMARK)>>('PDFIUM_FPDFBookmark_GetNextSibling');
  late final _Bookmark_GetNextSibling = _Bookmark_GetNextSiblingPtr.asFunction<
      FPDF_BOOKMARK Function(FPDF_DOCUMENT, FPDF_BOOKMARK)>();

  /// Get the title of |bookmark|.
  /// bookmark - handle to the bookmark.
  /// buffer   - buffer for the title. May be NULL.
  /// buflen   - the length of the buffer in bytes. May be 0.
  /// Returns the number of bytes in the title, including the terminating NUL
  /// character. The number of bytes is returned regardless of the |buffer| and
  /// |buflen| parameters.
  /// Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The
  /// string is terminated by a UTF16 NUL character. If |buflen| is less than the
  /// required length, or |buffer| is NULL, |buffer| will not be modified.
  int Bookmark_GetTitle(
    FPDF_BOOKMARK bookmark,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _Bookmark_GetTitle(
      bookmark,
      buffer,
      buflen,
    );
  }

  late final _Bookmark_GetTitlePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_BOOKMARK, ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFBookmark_GetTitle');
  late final _Bookmark_GetTitle = _Bookmark_GetTitlePtr.asFunction<
      int Function(FPDF_BOOKMARK, ffi.Pointer<ffi.Void>, int)>();

  /// Experimental API.
  /// Get the number of chlidren of |bookmark|.
  /// bookmark - handle to the bookmark.
  /// Returns a signed integer that represents the number of sub-items the given
  /// bookmark has. If the value is positive, child items shall be shown by default
  /// (open state). If the value is negative, child items shall be hidden by
  /// default (closed state). Please refer to PDF 32000-1:2008, Table 153.
  /// Returns 0 if the bookmark has no children or is invalid.
  int Bookmark_GetCount(
    FPDF_BOOKMARK bookmark,
  ) {
    return _Bookmark_GetCount(
      bookmark,
    );
  }

  late final _Bookmark_GetCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_BOOKMARK)>>(
          'PDFIUM_FPDFBookmark_GetCount');
  late final _Bookmark_GetCount =
      _Bookmark_GetCountPtr.asFunction<int Function(FPDF_BOOKMARK)>();

  /// Find the bookmark with |title| in |document|.
  /// document - handle to the document.
  /// title    - the UTF-16LE encoded Unicode title for which to search.
  /// Returns the handle to the bookmark, or NULL if |title| can't be found.
  /// FPDFBookmark_Find() will always return the first bookmark found even if
  /// multiple bookmarks have the same |title|.
  FPDF_BOOKMARK Bookmark_Find(
    FPDF_DOCUMENT document,
    FPDF_WIDESTRING title,
  ) {
    return _Bookmark_Find(
      document,
      title,
    );
  }

  late final _Bookmark_FindPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOKMARK Function(
              FPDF_DOCUMENT, FPDF_WIDESTRING)>>('PDFIUM_FPDFBookmark_Find');
  late final _Bookmark_Find = _Bookmark_FindPtr.asFunction<
      FPDF_BOOKMARK Function(FPDF_DOCUMENT, FPDF_WIDESTRING)>();

  /// Get the destination associated with |bookmark|.
  /// document - handle to the document.
  /// bookmark - handle to the bookmark.
  /// Returns the handle to the destination data, or NULL if no destination is
  /// associated with |bookmark|.
  FPDF_DEST Bookmark_GetDest(
    FPDF_DOCUMENT document,
    FPDF_BOOKMARK bookmark,
  ) {
    return _Bookmark_GetDest(
      document,
      bookmark,
    );
  }

  late final _Bookmark_GetDestPtr = _lookup<
          ffi.NativeFunction<FPDF_DEST Function(FPDF_DOCUMENT, FPDF_BOOKMARK)>>(
      'PDFIUM_FPDFBookmark_GetDest');
  late final _Bookmark_GetDest = _Bookmark_GetDestPtr.asFunction<
      FPDF_DEST Function(FPDF_DOCUMENT, FPDF_BOOKMARK)>();

  /// Get the action associated with |bookmark|.
  /// bookmark - handle to the bookmark.
  /// Returns the handle to the action data, or NULL if no action is associated
  /// with |bookmark|.
  /// If this function returns a valid handle, it is valid as long as |bookmark| is
  /// valid.
  /// If this function returns NULL, FPDFBookmark_GetDest() should be called to get
  /// the |bookmark| destination data.
  FPDF_ACTION Bookmark_GetAction(
    FPDF_BOOKMARK bookmark,
  ) {
    return _Bookmark_GetAction(
      bookmark,
    );
  }

  late final _Bookmark_GetActionPtr =
      _lookup<ffi.NativeFunction<FPDF_ACTION Function(FPDF_BOOKMARK)>>(
          'PDFIUM_FPDFBookmark_GetAction');
  late final _Bookmark_GetAction =
      _Bookmark_GetActionPtr.asFunction<FPDF_ACTION Function(FPDF_BOOKMARK)>();

  /// Get the type of |action|.
  /// action - handle to the action.
  /// Returns one of:
  /// PDFACTION_UNSUPPORTED
  /// PDFACTION_GOTO
  /// PDFACTION_REMOTEGOTO
  /// PDFACTION_URI
  /// PDFACTION_LAUNCH
  int Action_GetType(
    FPDF_ACTION action,
  ) {
    return _Action_GetType(
      action,
    );
  }

  late final _Action_GetTypePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLong Function(FPDF_ACTION)>>(
          'PDFIUM_FPDFAction_GetType');
  late final _Action_GetType =
      _Action_GetTypePtr.asFunction<int Function(FPDF_ACTION)>();

  /// Get the destination of |action|.
  /// document - handle to the document.
  /// action   - handle to the action. |action| must be a |PDFACTION_GOTO| or
  /// |PDFACTION_REMOTEGOTO|.
  /// Returns a handle to the destination data, or NULL on error, typically
  /// because the arguments were bad or the action was of the wrong type.
  /// In the case of |PDFACTION_REMOTEGOTO|, you must first call
  /// FPDFAction_GetFilePath(), then load the document at that path, then pass
  /// the document handle from that document as |document| to FPDFAction_GetDest().
  FPDF_DEST Action_GetDest(
    FPDF_DOCUMENT document,
    FPDF_ACTION action,
  ) {
    return _Action_GetDest(
      document,
      action,
    );
  }

  late final _Action_GetDestPtr = _lookup<
          ffi.NativeFunction<FPDF_DEST Function(FPDF_DOCUMENT, FPDF_ACTION)>>(
      'PDFIUM_FPDFAction_GetDest');
  late final _Action_GetDest = _Action_GetDestPtr.asFunction<
      FPDF_DEST Function(FPDF_DOCUMENT, FPDF_ACTION)>();

  /// Get the file path of |action|.
  /// action - handle to the action. |action| must be a |PDFACTION_LAUNCH| or
  /// |PDFACTION_REMOTEGOTO|.
  /// buffer - a buffer for output the path string. May be NULL.
  /// buflen - the length of the buffer, in bytes. May be 0.
  /// Returns the number of bytes in the file path, including the trailing NUL
  /// character, or 0 on error, typically because the arguments were bad or the
  /// action was of the wrong type.
  /// Regardless of the platform, the |buffer| is always in UTF-8 encoding.
  /// If |buflen| is less than the returned length, or |buffer| is NULL, |buffer|
  /// will not be modified.
  int Action_GetFilePath(
    FPDF_ACTION action,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _Action_GetFilePath(
      action,
      buffer,
      buflen,
    );
  }

  late final _Action_GetFilePathPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_ACTION, ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFAction_GetFilePath');
  late final _Action_GetFilePath = _Action_GetFilePathPtr.asFunction<
      int Function(FPDF_ACTION, ffi.Pointer<ffi.Void>, int)>();

  /// Get the URI path of |action|.
  /// document - handle to the document.
  /// action   - handle to the action. Must be a |PDFACTION_URI|.
  /// buffer   - a buffer for the path string. May be NULL.
  /// buflen   - the length of the buffer, in bytes. May be 0.
  /// Returns the number of bytes in the URI path, including the trailing NUL
  /// character, or 0 on error, typically because the arguments were bad or the
  /// action was of the wrong type.
  /// The |buffer| may contain badly encoded data. The caller should validate the
  /// output. e.g. Check to see if it is UTF-8.
  /// If |buflen| is less than the returned length, or |buffer| is NULL, |buffer|
  /// will not be modified.
  /// Historically, the documentation for this API claimed |buffer| is always
  /// encoded in 7-bit ASCII, but did not actually enforce it.
  /// https://pdfium.googlesource.com/pdfium.git/+/d609e84cee2e14a18333247485af91df48a40592
  /// added that enforcement, but that did not work well for real world PDFs that
  /// used UTF-8. As of this writing, this API reverted back to its original
  /// behavior prior to commit d609e84cee.
  int Action_GetURIPath(
    FPDF_DOCUMENT document,
    FPDF_ACTION action,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _Action_GetURIPath(
      document,
      action,
      buffer,
      buflen,
    );
  }

  late final _Action_GetURIPathPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_DOCUMENT,
              FPDF_ACTION,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFAction_GetURIPath');
  late final _Action_GetURIPath = _Action_GetURIPathPtr.asFunction<
      int Function(FPDF_DOCUMENT, FPDF_ACTION, ffi.Pointer<ffi.Void>, int)>();

  /// Get the page index of |dest|.
  /// document - handle to the document.
  /// dest     - handle to the destination.
  /// Returns the 0-based page index containing |dest|. Returns -1 on error.
  int Dest_GetDestPageIndex(
    FPDF_DOCUMENT document,
    FPDF_DEST dest,
  ) {
    return _Dest_GetDestPageIndex(
      document,
      dest,
    );
  }

  late final _Dest_GetDestPageIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT, FPDF_DEST)>>(
          'PDFIUM_FPDFDest_GetDestPageIndex');
  late final _Dest_GetDestPageIndex = _Dest_GetDestPageIndexPtr.asFunction<
      int Function(FPDF_DOCUMENT, FPDF_DEST)>();

  /// Experimental API.
  /// Get the view (fit type) specified by |dest|.
  /// dest         - handle to the destination.
  /// pNumParams   - receives the number of view parameters, which is at most 4.
  /// pParams      - buffer to write the view parameters. Must be at least 4
  /// FS_FLOATs long.
  /// Returns one of the PDFDEST_VIEW_* constants, PDFDEST_VIEW_UNKNOWN_MODE if
  /// |dest| does not specify a view.
  int Dest_GetView(
    FPDF_DEST dest,
    ffi.Pointer<ffi.UnsignedLong> pNumParams,
    ffi.Pointer<FS_FLOAT> pParams,
  ) {
    return _Dest_GetView(
      dest,
      pNumParams,
      pParams,
    );
  }

  late final _Dest_GetViewPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_DEST, ffi.Pointer<ffi.UnsignedLong>,
              ffi.Pointer<FS_FLOAT>)>>('PDFIUM_FPDFDest_GetView');
  late final _Dest_GetView = _Dest_GetViewPtr.asFunction<
      int Function(
          FPDF_DEST, ffi.Pointer<ffi.UnsignedLong>, ffi.Pointer<FS_FLOAT>)>();

  /// Get the (x, y, zoom) location of |dest| in the destination page, if the
  /// destination is in [page /XYZ x y zoom] syntax.
  /// dest       - handle to the destination.
  /// hasXVal    - out parameter; true if the x value is not null
  /// hasYVal    - out parameter; true if the y value is not null
  /// hasZoomVal - out parameter; true if the zoom value is not null
  /// x          - out parameter; the x coordinate, in page coordinates.
  /// y          - out parameter; the y coordinate, in page coordinates.
  /// zoom       - out parameter; the zoom value.
  /// Returns TRUE on successfully reading the /XYZ value.
  /// Note the [x, y, zoom] values are only set if the corresponding hasXVal,
  /// hasYVal or hasZoomVal flags are true.
  int Dest_GetLocationInPage(
    FPDF_DEST dest,
    ffi.Pointer<FPDF_BOOL> hasXVal,
    ffi.Pointer<FPDF_BOOL> hasYVal,
    ffi.Pointer<FPDF_BOOL> hasZoomVal,
    ffi.Pointer<FS_FLOAT> x,
    ffi.Pointer<FS_FLOAT> y,
    ffi.Pointer<FS_FLOAT> zoom,
  ) {
    return _Dest_GetLocationInPage(
      dest,
      hasXVal,
      hasYVal,
      hasZoomVal,
      x,
      y,
      zoom,
    );
  }

  late final _Dest_GetLocationInPagePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_DEST,
              ffi.Pointer<FPDF_BOOL>,
              ffi.Pointer<FPDF_BOOL>,
              ffi.Pointer<FPDF_BOOL>,
              ffi.Pointer<FS_FLOAT>,
              ffi.Pointer<FS_FLOAT>,
              ffi.Pointer<FS_FLOAT>)>>('PDFIUM_FPDFDest_GetLocationInPage');
  late final _Dest_GetLocationInPage = _Dest_GetLocationInPagePtr.asFunction<
      int Function(
          FPDF_DEST,
          ffi.Pointer<FPDF_BOOL>,
          ffi.Pointer<FPDF_BOOL>,
          ffi.Pointer<FPDF_BOOL>,
          ffi.Pointer<FS_FLOAT>,
          ffi.Pointer<FS_FLOAT>,
          ffi.Pointer<FS_FLOAT>)>();

  /// Find a link at point (|x|,|y|) on |page|.
  /// page - handle to the document page.
  /// x    - the x coordinate, in the page coordinate system.
  /// y    - the y coordinate, in the page coordinate system.
  /// Returns a handle to the link, or NULL if no link found at the given point.
  /// You can convert coordinates from screen coordinates to page coordinates using
  /// FPDF_DeviceToPage().
  FPDF_LINK Link_GetLinkAtPoint(
    FPDF_PAGE page,
    double x,
    double y,
  ) {
    return _Link_GetLinkAtPoint(
      page,
      x,
      y,
    );
  }

  late final _Link_GetLinkAtPointPtr = _lookup<
      ffi.NativeFunction<
          FPDF_LINK Function(FPDF_PAGE, ffi.Double,
              ffi.Double)>>('PDFIUM_FPDFLink_GetLinkAtPoint');
  late final _Link_GetLinkAtPoint = _Link_GetLinkAtPointPtr.asFunction<
      FPDF_LINK Function(FPDF_PAGE, double, double)>();

  /// Find the Z-order of link at point (|x|,|y|) on |page|.
  /// page - handle to the document page.
  /// x    - the x coordinate, in the page coordinate system.
  /// y    - the y coordinate, in the page coordinate system.
  /// Returns the Z-order of the link, or -1 if no link found at the given point.
  /// Larger Z-order numbers are closer to the front.
  /// You can convert coordinates from screen coordinates to page coordinates using
  /// FPDF_DeviceToPage().
  int Link_GetLinkZOrderAtPoint(
    FPDF_PAGE page,
    double x,
    double y,
  ) {
    return _Link_GetLinkZOrderAtPoint(
      page,
      x,
      y,
    );
  }

  late final _Link_GetLinkZOrderAtPointPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(FPDF_PAGE, ffi.Double, ffi.Double)>>(
      'PDFIUM_FPDFLink_GetLinkZOrderAtPoint');
  late final _Link_GetLinkZOrderAtPoint = _Link_GetLinkZOrderAtPointPtr
      .asFunction<int Function(FPDF_PAGE, double, double)>();

  /// Get destination info for |link|.
  /// document - handle to the document.
  /// link     - handle to the link.
  /// Returns a handle to the destination, or NULL if there is no destination
  /// associated with the link. In this case, you should call FPDFLink_GetAction()
  /// to retrieve the action associated with |link|.
  FPDF_DEST Link_GetDest(
    FPDF_DOCUMENT document,
    FPDF_LINK link,
  ) {
    return _Link_GetDest(
      document,
      link,
    );
  }

  late final _Link_GetDestPtr =
      _lookup<ffi.NativeFunction<FPDF_DEST Function(FPDF_DOCUMENT, FPDF_LINK)>>(
          'PDFIUM_FPDFLink_GetDest');
  late final _Link_GetDest = _Link_GetDestPtr.asFunction<
      FPDF_DEST Function(FPDF_DOCUMENT, FPDF_LINK)>();

  /// Get action info for |link|.
  /// link - handle to the link.
  /// Returns a handle to the action associated to |link|, or NULL if no action.
  /// If this function returns a valid handle, it is valid as long as |link| is
  /// valid.
  FPDF_ACTION Link_GetAction(
    FPDF_LINK link,
  ) {
    return _Link_GetAction(
      link,
    );
  }

  late final _Link_GetActionPtr =
      _lookup<ffi.NativeFunction<FPDF_ACTION Function(FPDF_LINK)>>(
          'PDFIUM_FPDFLink_GetAction');
  late final _Link_GetAction =
      _Link_GetActionPtr.asFunction<FPDF_ACTION Function(FPDF_LINK)>();

  /// Enumerates all the link annotations in |page|.
  /// page       - handle to the page.
  /// start_pos  - the start position, should initially be 0 and is updated with
  /// the next start position on return.
  /// link_annot - the link handle for |startPos|.
  /// Returns TRUE on success.
  int Link_Enumerate(
    FPDF_PAGE page,
    ffi.Pointer<ffi.Int> start_pos,
    ffi.Pointer<FPDF_LINK> link_annot,
  ) {
    return _Link_Enumerate(
      page,
      start_pos,
      link_annot,
    );
  }

  late final _Link_EnumeratePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGE, ffi.Pointer<ffi.Int>,
              ffi.Pointer<FPDF_LINK>)>>('PDFIUM_FPDFLink_Enumerate');
  late final _Link_Enumerate = _Link_EnumeratePtr.asFunction<
      int Function(FPDF_PAGE, ffi.Pointer<ffi.Int>, ffi.Pointer<FPDF_LINK>)>();

  /// Experimental API.
  /// Gets FPDF_ANNOTATION object for |link_annot|.
  /// page       - handle to the page in which FPDF_LINK object is present.
  /// link_annot - handle to link annotation.
  /// Returns FPDF_ANNOTATION from the FPDF_LINK and NULL on failure,
  /// if the input link annot or page is NULL.
  FPDF_ANNOTATION Link_GetAnnot(
    FPDF_PAGE page,
    FPDF_LINK link_annot,
  ) {
    return _Link_GetAnnot(
      page,
      link_annot,
    );
  }

  late final _Link_GetAnnotPtr = _lookup<
          ffi.NativeFunction<FPDF_ANNOTATION Function(FPDF_PAGE, FPDF_LINK)>>(
      'PDFIUM_FPDFLink_GetAnnot');
  late final _Link_GetAnnot = _Link_GetAnnotPtr.asFunction<
      FPDF_ANNOTATION Function(FPDF_PAGE, FPDF_LINK)>();

  /// Get the rectangle for |link_annot|.
  /// link_annot - handle to the link annotation.
  /// rect       - the annotation rectangle.
  /// Returns true on success.
  int Link_GetAnnotRect(
    FPDF_LINK link_annot,
    ffi.Pointer<FS_RECTF> rect,
  ) {
    return _Link_GetAnnotRect(
      link_annot,
      rect,
    );
  }

  late final _Link_GetAnnotRectPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_LINK,
              ffi.Pointer<FS_RECTF>)>>('PDFIUM_FPDFLink_GetAnnotRect');
  late final _Link_GetAnnotRect = _Link_GetAnnotRectPtr.asFunction<
      int Function(FPDF_LINK, ffi.Pointer<FS_RECTF>)>();

  /// Get the count of quadrilateral points to the |link_annot|.
  /// link_annot - handle to the link annotation.
  /// Returns the count of quadrilateral points.
  int Link_CountQuadPoints(
    FPDF_LINK link_annot,
  ) {
    return _Link_CountQuadPoints(
      link_annot,
    );
  }

  late final _Link_CountQuadPointsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_LINK)>>(
          'PDFIUM_FPDFLink_CountQuadPoints');
  late final _Link_CountQuadPoints =
      _Link_CountQuadPointsPtr.asFunction<int Function(FPDF_LINK)>();

  /// Get the quadrilateral points for the specified |quad_index| in |link_annot|.
  /// link_annot  - handle to the link annotation.
  /// quad_index  - the specified quad point index.
  /// quad_points - receives the quadrilateral points.
  /// Returns true on success.
  int Link_GetQuadPoints(
    FPDF_LINK link_annot,
    int quad_index,
    ffi.Pointer<FS_QUADPOINTSF> quad_points,
  ) {
    return _Link_GetQuadPoints(
      link_annot,
      quad_index,
      quad_points,
    );
  }

  late final _Link_GetQuadPointsPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_LINK, ffi.Int,
              ffi.Pointer<FS_QUADPOINTSF>)>>('PDFIUM_FPDFLink_GetQuadPoints');
  late final _Link_GetQuadPoints = _Link_GetQuadPointsPtr.asFunction<
      int Function(FPDF_LINK, int, ffi.Pointer<FS_QUADPOINTSF>)>();

  /// Experimental API
  /// Gets an additional-action from |page|.
  /// page      - handle to the page, as returned by FPDF_LoadPage().
  /// aa_type   - the type of the page object's addtional-action, defined
  /// in public/fpdf_formfill.h
  /// Returns the handle to the action data, or NULL if there is no
  /// additional-action of type |aa_type|.
  /// If this function returns a valid handle, it is valid as long as |page| is
  /// valid.
  FPDF_ACTION GetPageAAction(
    FPDF_PAGE page,
    int aa_type,
  ) {
    return _GetPageAAction(
      page,
      aa_type,
    );
  }

  late final _GetPageAActionPtr =
      _lookup<ffi.NativeFunction<FPDF_ACTION Function(FPDF_PAGE, ffi.Int)>>(
          'PDFIUM_FPDF_GetPageAAction');
  late final _GetPageAAction =
      _GetPageAActionPtr.asFunction<FPDF_ACTION Function(FPDF_PAGE, int)>();

  /// Experimental API.
  /// Get the file identifer defined in the trailer of |document|.
  /// document - handle to the document.
  /// id_type  - the file identifier type to retrieve.
  /// buffer   - a buffer for the file identifier. May be NULL.
  /// buflen   - the length of the buffer, in bytes. May be 0.
  /// Returns the number of bytes in the file identifier, including the NUL
  /// terminator.
  /// The |buffer| is always a byte string. The |buffer| is followed by a NUL
  /// terminator.  If |buflen| is less than the returned length, or |buffer| is
  /// NULL, |buffer| will not be modified.
  int GetFileIdentifier(
    FPDF_DOCUMENT document,
    int id_type,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _GetFileIdentifier(
      document,
      id_type,
      buffer,
      buflen,
    );
  }

  late final _GetFileIdentifierPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_DOCUMENT,
              ffi.Int32,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDF_GetFileIdentifier');
  late final _GetFileIdentifier = _GetFileIdentifierPtr.asFunction<
      int Function(FPDF_DOCUMENT, int, ffi.Pointer<ffi.Void>, int)>();

  /// Get meta-data |tag| content from |document|.
  /// document - handle to the document.
  /// tag      - the tag to retrieve. The tag can be one of:
  /// Title, Author, Subject, Keywords, Creator, Producer,
  /// CreationDate, or ModDate.
  /// For detailed explanations of these tags and their respective
  /// values, please refer to PDF Reference 1.6, section 10.2.1,
  /// 'Document Information Dictionary'.
  /// buffer   - a buffer for the tag. May be NULL.
  /// buflen   - the length of the buffer, in bytes. May be 0.
  /// Returns the number of bytes in the tag, including trailing zeros.
  /// The |buffer| is always encoded in UTF-16LE. The |buffer| is followed by two
  /// bytes of zeros indicating the end of the string.  If |buflen| is less than
  /// the returned length, or |buffer| is NULL, |buffer| will not be modified.
  /// For linearized files, FPDFAvail_IsFormAvail must be called before this, and
  /// it must have returned PDF_FORM_AVAIL or PDF_FORM_NOTEXIST. Before that, there
  /// is no guarantee the metadata has been loaded.
  int GetMetaText(
    FPDF_DOCUMENT document,
    FPDF_BYTESTRING tag,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _GetMetaText(
      document,
      tag,
      buffer,
      buflen,
    );
  }

  late final _GetMetaTextPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_DOCUMENT,
              FPDF_BYTESTRING,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDF_GetMetaText');
  late final _GetMetaText = _GetMetaTextPtr.asFunction<
      int Function(
          FPDF_DOCUMENT, FPDF_BYTESTRING, ffi.Pointer<ffi.Void>, int)>();

  /// Get the page label for |page_index| from |document|.
  /// document    - handle to the document.
  /// page_index  - the 0-based index of the page.
  /// buffer      - a buffer for the page label. May be NULL.
  /// buflen      - the length of the buffer, in bytes. May be 0.
  /// Returns the number of bytes in the page label, including trailing zeros.
  /// The |buffer| is always encoded in UTF-16LE. The |buffer| is followed by two
  /// bytes of zeros indicating the end of the string.  If |buflen| is less than
  /// the returned length, or |buffer| is NULL, |buffer| will not be modified.
  int GetPageLabel(
    FPDF_DOCUMENT document,
    int page_index,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _GetPageLabel(
      document,
      page_index,
      buffer,
      buflen,
    );
  }

  late final _GetPageLabelPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_DOCUMENT,
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDF_GetPageLabel');
  late final _GetPageLabel = _GetPageLabelPtr.asFunction<
      int Function(FPDF_DOCUMENT, int, ffi.Pointer<ffi.Void>, int)>();

  /// Function: FPDFDOC_InitFormFillEnvironment
  /// Initialize form fill environment.
  /// Parameters:
  /// document        -   Handle to document from FPDF_LoadDocument().
  /// formInfo        -   Pointer to a FPDF_FORMFILLINFO structure.
  /// Return Value:
  /// Handle to the form fill module, or NULL on failure.
  /// Comments:
  /// This function should be called before any form fill operation.
  /// The FPDF_FORMFILLINFO passed in via |formInfo| must remain valid until
  /// the returned FPDF_FORMHANDLE is closed.
  FPDF_FORMHANDLE DOC_InitFormFillEnvironment(
    FPDF_DOCUMENT document,
    ffi.Pointer<FPDF_FORMFILLINFO> formInfo,
  ) {
    return _DOC_InitFormFillEnvironment(
      document,
      formInfo,
    );
  }

  late final _DOC_InitFormFillEnvironmentPtr = _lookup<
          ffi.NativeFunction<
              FPDF_FORMHANDLE Function(
                  FPDF_DOCUMENT, ffi.Pointer<FPDF_FORMFILLINFO>)>>(
      'PDFIUM_FPDFDOC_InitFormFillEnvironment');
  late final _DOC_InitFormFillEnvironment =
      _DOC_InitFormFillEnvironmentPtr.asFunction<
          FPDF_FORMHANDLE Function(
              FPDF_DOCUMENT, ffi.Pointer<FPDF_FORMFILLINFO>)>();

  /// Function: FPDFDOC_ExitFormFillEnvironment
  /// Take ownership of |hHandle| and exit form fill environment.
  /// Parameters:
  /// hHandle     -   Handle to the form fill module, as returned by
  /// FPDFDOC_InitFormFillEnvironment().
  /// Return Value:
  /// None.
  /// Comments:
  /// This function is a no-op when |hHandle| is null.
  void DOC_ExitFormFillEnvironment(
    FPDF_FORMHANDLE hHandle,
  ) {
    return _DOC_ExitFormFillEnvironment(
      hHandle,
    );
  }

  late final _DOC_ExitFormFillEnvironmentPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_FORMHANDLE)>>(
          'PDFIUM_FPDFDOC_ExitFormFillEnvironment');
  late final _DOC_ExitFormFillEnvironment = _DOC_ExitFormFillEnvironmentPtr
      .asFunction<void Function(FPDF_FORMHANDLE)>();

  /// Function: FPDFPage_HasFormFieldAtPoint
  /// Get the form field type by point.
  /// Parameters:
  /// hHandle     -   Handle to the form fill module. Returned by
  /// FPDFDOC_InitFormFillEnvironment().
  /// page        -   Handle to the page. Returned by FPDF_LoadPage().
  /// page_x      -   X position in PDF "user space".
  /// page_y      -   Y position in PDF "user space".
  /// Return Value:
  /// Return the type of the form field; -1 indicates no field.
  /// See field types above.
  int Page_HasFormFieldAtPoint(
    FPDF_FORMHANDLE hHandle,
    FPDF_PAGE page,
    double page_x,
    double page_y,
  ) {
    return _Page_HasFormFieldAtPoint(
      hHandle,
      page,
      page_x,
      page_y,
    );
  }

  late final _Page_HasFormFieldAtPointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(FPDF_FORMHANDLE, FPDF_PAGE, ffi.Double,
              ffi.Double)>>('PDFIUM_FPDFPage_HasFormFieldAtPoint');
  late final _Page_HasFormFieldAtPoint = _Page_HasFormFieldAtPointPtr
      .asFunction<int Function(FPDF_FORMHANDLE, FPDF_PAGE, double, double)>();

  /// Function: FPDFPage_FormFieldZOrderAtPoint
  /// Get the form field z-order by point.
  /// Parameters:
  /// hHandle     -   Handle to the form fill module. Returned by
  /// FPDFDOC_InitFormFillEnvironment().
  /// page        -   Handle to the page. Returned by FPDF_LoadPage().
  /// page_x      -   X position in PDF "user space".
  /// page_y      -   Y position in PDF "user space".
  /// Return Value:
  /// Return the z-order of the form field; -1 indicates no field.
  /// Higher numbers are closer to the front.
  int Page_FormFieldZOrderAtPoint(
    FPDF_FORMHANDLE hHandle,
    FPDF_PAGE page,
    double page_x,
    double page_y,
  ) {
    return _Page_FormFieldZOrderAtPoint(
      hHandle,
      page,
      page_x,
      page_y,
    );
  }

  late final _Page_FormFieldZOrderAtPointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(FPDF_FORMHANDLE, FPDF_PAGE, ffi.Double,
              ffi.Double)>>('PDFIUM_FPDFPage_FormFieldZOrderAtPoint');
  late final _Page_FormFieldZOrderAtPoint = _Page_FormFieldZOrderAtPointPtr
      .asFunction<int Function(FPDF_FORMHANDLE, FPDF_PAGE, double, double)>();

  /// Function: FPDF_SetFormFieldHighlightColor
  /// Set the highlight color of the specified (or all) form fields
  /// in the document.
  /// Parameters:
  /// hHandle     -   Handle to the form fill module, as returned by
  /// FPDFDOC_InitFormFillEnvironment().
  /// doc         -   Handle to the document, as returned by
  /// FPDF_LoadDocument().
  /// fieldType   -   A 32-bit integer indicating the type of a form
  /// field (defined above).
  /// color       -   The highlight color of the form field. Constructed by
  /// 0xxxrrggbb.
  /// Return Value:
  /// None.
  /// Comments:
  /// When the parameter fieldType is set to FPDF_FORMFIELD_UNKNOWN, the
  /// highlight color will be applied to all the form fields in the
  /// document.
  /// Please refresh the client window to show the highlight immediately
  /// if necessary.
  void SetFormFieldHighlightColor(
    FPDF_FORMHANDLE hHandle,
    int fieldType,
    int color,
  ) {
    return _SetFormFieldHighlightColor(
      hHandle,
      fieldType,
      color,
    );
  }

  late final _SetFormFieldHighlightColorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FPDF_FORMHANDLE, ffi.Int,
              ffi.UnsignedLong)>>('PDFIUM_FPDF_SetFormFieldHighlightColor');
  late final _SetFormFieldHighlightColor = _SetFormFieldHighlightColorPtr
      .asFunction<void Function(FPDF_FORMHANDLE, int, int)>();

  /// Function: FPDF_SetFormFieldHighlightAlpha
  /// Set the transparency of the form field highlight color in the
  /// document.
  /// Parameters:
  /// hHandle     -   Handle to the form fill module, as returned by
  /// FPDFDOC_InitFormFillEnvironment().
  /// doc         -   Handle to the document, as returaned by
  /// FPDF_LoadDocument().
  /// alpha       -   The transparency of the form field highlight color,
  /// between 0-255.
  /// Return Value:
  /// None.
  void SetFormFieldHighlightAlpha(
    FPDF_FORMHANDLE hHandle,
    int alpha,
  ) {
    return _SetFormFieldHighlightAlpha(
      hHandle,
      alpha,
    );
  }

  late final _SetFormFieldHighlightAlphaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FPDF_FORMHANDLE,
              ffi.UnsignedChar)>>('PDFIUM_FPDF_SetFormFieldHighlightAlpha');
  late final _SetFormFieldHighlightAlpha = _SetFormFieldHighlightAlphaPtr
      .asFunction<void Function(FPDF_FORMHANDLE, int)>();

  /// Function: FPDF_RemoveFormFieldHighlight
  /// Remove the form field highlight color in the document.
  /// Parameters:
  /// hHandle     -   Handle to the form fill module, as returned by
  /// FPDFDOC_InitFormFillEnvironment().
  /// Return Value:
  /// None.
  /// Comments:
  /// Please refresh the client window to remove the highlight immediately
  /// if necessary.
  void RemoveFormFieldHighlight(
    FPDF_FORMHANDLE hHandle,
  ) {
    return _RemoveFormFieldHighlight(
      hHandle,
    );
  }

  late final _RemoveFormFieldHighlightPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_FORMHANDLE)>>(
          'PDFIUM_FPDF_RemoveFormFieldHighlight');
  late final _RemoveFormFieldHighlight =
      _RemoveFormFieldHighlightPtr.asFunction<void Function(FPDF_FORMHANDLE)>();

  /// Function: FPDF_FFLDraw
  /// Render FormFields and popup window on a page to a device independent
  /// bitmap.
  /// Parameters:
  /// hHandle      -   Handle to the form fill module, as returned by
  /// FPDFDOC_InitFormFillEnvironment().
  /// bitmap       -   Handle to the device independent bitmap (as the
  /// output buffer). Bitmap handles can be created by
  /// FPDFBitmap_Create().
  /// page         -   Handle to the page, as returned by FPDF_LoadPage().
  /// start_x      -   Left pixel position of the display area in the
  /// device coordinates.
  /// start_y      -   Top pixel position of the display area in the device
  /// coordinates.
  /// size_x       -   Horizontal size (in pixels) for displaying the page.
  /// size_y       -   Vertical size (in pixels) for displaying the page.
  /// rotate       -   Page orientation: 0 (normal), 1 (rotated 90 degrees
  /// clockwise), 2 (rotated 180 degrees), 3 (rotated 90
  /// degrees counter-clockwise).
  /// flags        -   0 for normal display, or combination of flags
  /// defined above.
  /// Return Value:
  /// None.
  /// Comments:
  /// This function is designed to render annotations that are
  /// user-interactive, which are widget annotations (for FormFields) and
  /// popup annotations.
  /// With the FPDF_ANNOT flag, this function will render a popup annotation
  /// when users mouse-hover on a non-widget annotation. Regardless of
  /// FPDF_ANNOT flag, this function will always render widget annotations
  /// for FormFields.
  /// In order to implement the FormFill functions, implementation should
  /// call this function after rendering functions, such as
  /// FPDF_RenderPageBitmap() or FPDF_RenderPageBitmap_Start(), have
  /// finished rendering the page contents.
  void FFLDraw(
    FPDF_FORMHANDLE hHandle,
    FPDF_BITMAP bitmap,
    FPDF_PAGE page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    int flags,
  ) {
    return _FFLDraw(
      hHandle,
      bitmap,
      page,
      start_x,
      start_y,
      size_x,
      size_y,
      rotate,
      flags,
    );
  }

  late final _FFLDrawPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              FPDF_FORMHANDLE,
              FPDF_BITMAP,
              FPDF_PAGE,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('PDFIUM_FPDF_FFLDraw');
  late final _FFLDraw = _FFLDrawPtr.asFunction<
      void Function(FPDF_FORMHANDLE, FPDF_BITMAP, FPDF_PAGE, int, int, int, int,
          int, int)>();

  /// Experimental API
  /// Function: FPDF_GetFormType
  /// Returns the type of form contained in the PDF document.
  /// Parameters:
  /// document - Handle to document.
  /// Return Value:
  /// Integer value representing one of the FORMTYPE_ values.
  /// Comments:
  /// If |document| is NULL, then the return value is FORMTYPE_NONE.
  int GetFormType(
    FPDF_DOCUMENT document,
  ) {
    return _GetFormType(
      document,
    );
  }

  late final _GetFormTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDF_GetFormType');
  late final _GetFormType =
      _GetFormTypePtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_LoadXFA
  /// If the document consists of XFA fields, call this method to
  /// attempt to load XFA fields.
  /// Parameters:
  /// document     -   Handle to document from FPDF_LoadDocument().
  /// Return Value:
  /// TRUE upon success, otherwise FALSE. If XFA support is not built
  /// into PDFium, performs no action and always returns FALSE.
  int LoadXFA(
    FPDF_DOCUMENT document,
  ) {
    return _LoadXFA(
      document,
    );
  }

  late final _LoadXFAPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDF_LoadXFA');
  late final _LoadXFA = _LoadXFAPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Experimental API.
  /// Function: FPDF_GetSignatureCount
  /// Get total number of signatures in the document.
  /// Parameters:
  /// document    -   Handle to document. Returned by FPDF_LoadDocument().
  /// Return value:
  /// Total number of signatures in the document on success, -1 on error.
  int GetSignatureCount(
    FPDF_DOCUMENT document,
  ) {
    return _GetSignatureCount(
      document,
    );
  }

  late final _GetSignatureCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDF_GetSignatureCount');
  late final _GetSignatureCount =
      _GetSignatureCountPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Experimental API.
  /// Function: FPDF_GetSignatureObject
  /// Get the Nth signature of the document.
  /// Parameters:
  /// document    -   Handle to document. Returned by FPDF_LoadDocument().
  /// index       -   Index into the array of signatures of the document.
  /// Return value:
  /// Returns the handle to the signature, or NULL on failure. The caller
  /// does not take ownership of the returned FPDF_SIGNATURE. Instead, it
  /// remains valid until FPDF_CloseDocument() is called for the document.
  FPDF_SIGNATURE GetSignatureObject(
    FPDF_DOCUMENT document,
    int index,
  ) {
    return _GetSignatureObject(
      document,
      index,
    );
  }

  late final _GetSignatureObjectPtr = _lookup<
          ffi.NativeFunction<FPDF_SIGNATURE Function(FPDF_DOCUMENT, ffi.Int)>>(
      'PDFIUM_FPDF_GetSignatureObject');
  late final _GetSignatureObject = _GetSignatureObjectPtr.asFunction<
      FPDF_SIGNATURE Function(FPDF_DOCUMENT, int)>();

  /// Experimental API.
  /// Function: FPDFSignatureObj_GetContents
  /// Get the contents of a signature object.
  /// Parameters:
  /// signature   -   Handle to the signature object. Returned by
  /// FPDF_GetSignatureObject().
  /// buffer      -   The address of a buffer that receives the contents.
  /// length      -   The size, in bytes, of |buffer|.
  /// Return value:
  /// Returns the number of bytes in the contents on success, 0 on error.
  /// For public-key signatures, |buffer| is either a DER-encoded PKCS#1 binary or
  /// a DER-encoded PKCS#7 binary. If |length| is less than the returned length, or
  /// |buffer| is NULL, |buffer| will not be modified.
  int SignatureObj_GetContents(
    FPDF_SIGNATURE signature,
    ffi.Pointer<ffi.Void> buffer,
    int length,
  ) {
    return _SignatureObj_GetContents(
      signature,
      buffer,
      length,
    );
  }

  late final _SignatureObj_GetContentsPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_SIGNATURE, ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFSignatureObj_GetContents');
  late final _SignatureObj_GetContents = _SignatureObj_GetContentsPtr
      .asFunction<int Function(FPDF_SIGNATURE, ffi.Pointer<ffi.Void>, int)>();

  /// Experimental API.
  /// Function: FPDFSignatureObj_GetByteRange
  /// Get the byte range of a signature object.
  /// Parameters:
  /// signature   -   Handle to the signature object. Returned by
  /// FPDF_GetSignatureObject().
  /// buffer      -   The address of a buffer that receives the
  /// byte range.
  /// length      -   The size, in ints, of |buffer|.
  /// Return value:
  /// Returns the number of ints in the byte range on
  /// success, 0 on error.
  /// |buffer| is an array of pairs of integers (starting byte offset,
  /// length in bytes) that describes the exact byte range for the digest
  /// calculation. If |length| is less than the returned length, or
  /// |buffer| is NULL, |buffer| will not be modified.
  int SignatureObj_GetByteRange(
    FPDF_SIGNATURE signature,
    ffi.Pointer<ffi.Int> buffer,
    int length,
  ) {
    return _SignatureObj_GetByteRange(
      signature,
      buffer,
      length,
    );
  }

  late final _SignatureObj_GetByteRangePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_SIGNATURE, ffi.Pointer<ffi.Int>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFSignatureObj_GetByteRange');
  late final _SignatureObj_GetByteRange = _SignatureObj_GetByteRangePtr
      .asFunction<int Function(FPDF_SIGNATURE, ffi.Pointer<ffi.Int>, int)>();

  /// Experimental API.
  /// Function: FPDFSignatureObj_GetSubFilter
  /// Get the encoding of the value of a signature object.
  /// Parameters:
  /// signature   -   Handle to the signature object. Returned by
  /// FPDF_GetSignatureObject().
  /// buffer      -   The address of a buffer that receives the encoding.
  /// length      -   The size, in bytes, of |buffer|.
  /// Return value:
  /// Returns the number of bytes in the encoding name (including the
  /// trailing NUL character) on success, 0 on error.
  /// The |buffer| is always encoded in 7-bit ASCII. If |length| is less than the
  /// returned length, or |buffer| is NULL, |buffer| will not be modified.
  int SignatureObj_GetSubFilter(
    FPDF_SIGNATURE signature,
    ffi.Pointer<ffi.Char> buffer,
    int length,
  ) {
    return _SignatureObj_GetSubFilter(
      signature,
      buffer,
      length,
    );
  }

  late final _SignatureObj_GetSubFilterPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_SIGNATURE, ffi.Pointer<ffi.Char>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFSignatureObj_GetSubFilter');
  late final _SignatureObj_GetSubFilter = _SignatureObj_GetSubFilterPtr
      .asFunction<int Function(FPDF_SIGNATURE, ffi.Pointer<ffi.Char>, int)>();

  /// Experimental API.
  /// Function: FPDFSignatureObj_GetReason
  /// Get the reason (comment) of the signature object.
  /// Parameters:
  /// signature   -   Handle to the signature object. Returned by
  /// FPDF_GetSignatureObject().
  /// buffer      -   The address of a buffer that receives the reason.
  /// length      -   The size, in bytes, of |buffer|.
  /// Return value:
  /// Returns the number of bytes in the reason on success, 0 on error.
  /// Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The
  /// string is terminated by a UTF16 NUL character. If |length| is less than the
  /// returned length, or |buffer| is NULL, |buffer| will not be modified.
  int SignatureObj_GetReason(
    FPDF_SIGNATURE signature,
    ffi.Pointer<ffi.Void> buffer,
    int length,
  ) {
    return _SignatureObj_GetReason(
      signature,
      buffer,
      length,
    );
  }

  late final _SignatureObj_GetReasonPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_SIGNATURE, ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFSignatureObj_GetReason');
  late final _SignatureObj_GetReason = _SignatureObj_GetReasonPtr.asFunction<
      int Function(FPDF_SIGNATURE, ffi.Pointer<ffi.Void>, int)>();

  /// Experimental API.
  /// Function: FPDFSignatureObj_GetTime
  /// Get the time of signing of a signature object.
  /// Parameters:
  /// signature   -   Handle to the signature object. Returned by
  /// FPDF_GetSignatureObject().
  /// buffer      -   The address of a buffer that receives the time.
  /// length      -   The size, in bytes, of |buffer|.
  /// Return value:
  /// Returns the number of bytes in the encoding name (including the
  /// trailing NUL character) on success, 0 on error.
  /// The |buffer| is always encoded in 7-bit ASCII. If |length| is less than the
  /// returned length, or |buffer| is NULL, |buffer| will not be modified.
  /// The format of time is expected to be D:YYYYMMDDHHMMSS+XX'YY', i.e. it's
  /// percision is seconds, with timezone information. This value should be used
  /// only when the time of signing is not available in the (PKCS#7 binary)
  /// signature.
  int SignatureObj_GetTime(
    FPDF_SIGNATURE signature,
    ffi.Pointer<ffi.Char> buffer,
    int length,
  ) {
    return _SignatureObj_GetTime(
      signature,
      buffer,
      length,
    );
  }

  late final _SignatureObj_GetTimePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_SIGNATURE, ffi.Pointer<ffi.Char>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFSignatureObj_GetTime');
  late final _SignatureObj_GetTime = _SignatureObj_GetTimePtr.asFunction<
      int Function(FPDF_SIGNATURE, ffi.Pointer<ffi.Char>, int)>();

  /// Experimental API.
  /// Function: FPDFSignatureObj_GetDocMDPPermission
  /// Get the DocMDP permission of a signature object.
  /// Parameters:
  /// signature   -   Handle to the signature object. Returned by
  /// FPDF_GetSignatureObject().
  /// Return value:
  /// Returns the permission (1, 2 or 3) on success, 0 on error.
  int SignatureObj_GetDocMDPPermission(
    FPDF_SIGNATURE signature,
  ) {
    return _SignatureObj_GetDocMDPPermission(
      signature,
    );
  }

  late final _SignatureObj_GetDocMDPPermissionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(FPDF_SIGNATURE)>>(
          'PDFIUM_FPDFSignatureObj_GetDocMDPPermission');
  late final _SignatureObj_GetDocMDPPermission =
      _SignatureObj_GetDocMDPPermissionPtr.asFunction<
          int Function(FPDF_SIGNATURE)>();

  /// Function: FPDF_StructTree_GetForPage
  /// Get the structure tree for a page.
  /// Parameters:
  /// page        -   Handle to the page, as returned by FPDF_LoadPage().
  /// Return value:
  /// A handle to the structure tree or NULL on error. The caller owns the
  /// returned handle and must use FPDF_StructTree_Close() to release it.
  /// The handle should be released before |page| gets released.
  FPDF_STRUCTTREE StructTree_GetForPage(
    FPDF_PAGE page,
  ) {
    return _StructTree_GetForPage(
      page,
    );
  }

  late final _StructTree_GetForPagePtr =
      _lookup<ffi.NativeFunction<FPDF_STRUCTTREE Function(FPDF_PAGE)>>(
          'PDFIUM_FPDF_StructTree_GetForPage');
  late final _StructTree_GetForPage = _StructTree_GetForPagePtr.asFunction<
      FPDF_STRUCTTREE Function(FPDF_PAGE)>();

  /// Function: FPDF_StructTree_Close
  /// Release a resource allocated by FPDF_StructTree_GetForPage().
  /// Parameters:
  /// struct_tree -   Handle to the structure tree, as returned by
  /// FPDF_StructTree_LoadPage().
  /// Return value:
  /// None.
  void StructTree_Close(
    FPDF_STRUCTTREE struct_tree,
  ) {
    return _StructTree_Close(
      struct_tree,
    );
  }

  late final _StructTree_ClosePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_STRUCTTREE)>>(
          'PDFIUM_FPDF_StructTree_Close');
  late final _StructTree_Close =
      _StructTree_ClosePtr.asFunction<void Function(FPDF_STRUCTTREE)>();

  /// Function: FPDF_StructTree_CountChildren
  /// Count the number of children for the structure tree.
  /// Parameters:
  /// struct_tree -   Handle to the structure tree, as returned by
  /// FPDF_StructTree_LoadPage().
  /// Return value:
  /// The number of children, or -1 on error.
  int StructTree_CountChildren(
    FPDF_STRUCTTREE struct_tree,
  ) {
    return _StructTree_CountChildren(
      struct_tree,
    );
  }

  late final _StructTree_CountChildrenPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_STRUCTTREE)>>(
          'PDFIUM_FPDF_StructTree_CountChildren');
  late final _StructTree_CountChildren =
      _StructTree_CountChildrenPtr.asFunction<int Function(FPDF_STRUCTTREE)>();

  /// Function: FPDF_StructTree_GetChildAtIndex
  /// Get a child in the structure tree.
  /// Parameters:
  /// struct_tree -   Handle to the structure tree, as returned by
  /// FPDF_StructTree_LoadPage().
  /// index       -   The index for the child, 0-based.
  /// Return value:
  /// The child at the n-th index or NULL on error. The caller does not
  /// own the handle. The handle remains valid as long as |struct_tree|
  /// remains valid.
  /// Comments:
  /// The |index| must be less than the FPDF_StructTree_CountChildren()
  /// return value.
  FPDF_STRUCTELEMENT StructTree_GetChildAtIndex(
    FPDF_STRUCTTREE struct_tree,
    int index,
  ) {
    return _StructTree_GetChildAtIndex(
      struct_tree,
      index,
    );
  }

  late final _StructTree_GetChildAtIndexPtr = _lookup<
      ffi.NativeFunction<
          FPDF_STRUCTELEMENT Function(FPDF_STRUCTTREE,
              ffi.Int)>>('PDFIUM_FPDF_StructTree_GetChildAtIndex');
  late final _StructTree_GetChildAtIndex = _StructTree_GetChildAtIndexPtr
      .asFunction<FPDF_STRUCTELEMENT Function(FPDF_STRUCTTREE, int)>();

  /// Function: FPDF_StructElement_GetAltText
  /// Get the alt text for a given element.
  /// Parameters:
  /// struct_element -   Handle to the struct element.
  /// buffer         -   A buffer for output the alt text. May be NULL.
  /// buflen         -   The length of the buffer, in bytes. May be 0.
  /// Return value:
  /// The number of bytes in the alt text, including the terminating NUL
  /// character. The number of bytes is returned regardless of the
  /// |buffer| and |buflen| parameters.
  /// Comments:
  /// Regardless of the platform, the |buffer| is always in UTF-16LE
  /// encoding. The string is terminated by a UTF16 NUL character. If
  /// |buflen| is less than the required length, or |buffer| is NULL,
  /// |buffer| will not be modified.
  int StructElement_GetAltText(
    FPDF_STRUCTELEMENT struct_element,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _StructElement_GetAltText(
      struct_element,
      buffer,
      buflen,
    );
  }

  late final _StructElement_GetAltTextPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_STRUCTELEMENT, ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDF_StructElement_GetAltText');
  late final _StructElement_GetAltText =
      _StructElement_GetAltTextPtr.asFunction<
          int Function(FPDF_STRUCTELEMENT, ffi.Pointer<ffi.Void>, int)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_GetActualText
  /// Get the actual text for a given element.
  /// Parameters:
  /// struct_element -   Handle to the struct element.
  /// buffer         -   A buffer for output the actual text. May be NULL.
  /// buflen         -   The length of the buffer, in bytes. May be 0.
  /// Return value:
  /// The number of bytes in the actual text, including the terminating
  /// NUL character. The number of bytes is returned regardless of the
  /// |buffer| and |buflen| parameters.
  /// Comments:
  /// Regardless of the platform, the |buffer| is always in UTF-16LE
  /// encoding. The string is terminated by a UTF16 NUL character. If
  /// |buflen| is less than the required length, or |buffer| is NULL,
  /// |buffer| will not be modified.
  int StructElement_GetActualText(
    FPDF_STRUCTELEMENT struct_element,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _StructElement_GetActualText(
      struct_element,
      buffer,
      buflen,
    );
  }

  late final _StructElement_GetActualTextPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_STRUCTELEMENT, ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDF_StructElement_GetActualText');
  late final _StructElement_GetActualText =
      _StructElement_GetActualTextPtr.asFunction<
          int Function(FPDF_STRUCTELEMENT, ffi.Pointer<ffi.Void>, int)>();

  /// Function: FPDF_StructElement_GetID
  /// Get the ID for a given element.
  /// Parameters:
  /// struct_element -   Handle to the struct element.
  /// buffer         -   A buffer for output the ID string. May be NULL.
  /// buflen         -   The length of the buffer, in bytes. May be 0.
  /// Return value:
  /// The number of bytes in the ID string, including the terminating NUL
  /// character. The number of bytes is returned regardless of the
  /// |buffer| and |buflen| parameters.
  /// Comments:
  /// Regardless of the platform, the |buffer| is always in UTF-16LE
  /// encoding. The string is terminated by a UTF16 NUL character. If
  /// |buflen| is less than the required length, or |buffer| is NULL,
  /// |buffer| will not be modified.
  int StructElement_GetID(
    FPDF_STRUCTELEMENT struct_element,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _StructElement_GetID(
      struct_element,
      buffer,
      buflen,
    );
  }

  late final _StructElement_GetIDPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_STRUCTELEMENT, ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDF_StructElement_GetID');
  late final _StructElement_GetID = _StructElement_GetIDPtr.asFunction<
      int Function(FPDF_STRUCTELEMENT, ffi.Pointer<ffi.Void>, int)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_GetLang
  /// Get the case-insensitive IETF BCP 47 language code for an element.
  /// Parameters:
  /// struct_element -   Handle to the struct element.
  /// buffer         -   A buffer for output the lang string. May be NULL.
  /// buflen         -   The length of the buffer, in bytes. May be 0.
  /// Return value:
  /// The number of bytes in the ID string, including the terminating NUL
  /// character. The number of bytes is returned regardless of the
  /// |buffer| and |buflen| parameters.
  /// Comments:
  /// Regardless of the platform, the |buffer| is always in UTF-16LE
  /// encoding. The string is terminated by a UTF16 NUL character. If
  /// |buflen| is less than the required length, or |buffer| is NULL,
  /// |buffer| will not be modified.
  int StructElement_GetLang(
    FPDF_STRUCTELEMENT struct_element,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _StructElement_GetLang(
      struct_element,
      buffer,
      buflen,
    );
  }

  late final _StructElement_GetLangPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_STRUCTELEMENT, ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDF_StructElement_GetLang');
  late final _StructElement_GetLang = _StructElement_GetLangPtr.asFunction<
      int Function(FPDF_STRUCTELEMENT, ffi.Pointer<ffi.Void>, int)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_GetStringAttribute
  /// Get a struct element attribute of type "name" or "string".
  /// Parameters:
  /// struct_element -   Handle to the struct element.
  /// attr_name      -   The name of the attribute to retrieve.
  /// buffer         -   A buffer for output. May be NULL.
  /// buflen         -   The length of the buffer, in bytes. May be 0.
  /// Return value:
  /// The number of bytes in the attribute value, including the
  /// terminating NUL character. The number of bytes is returned
  /// regardless of the |buffer| and |buflen| parameters.
  /// Comments:
  /// Regardless of the platform, the |buffer| is always in UTF-16LE
  /// encoding. The string is terminated by a UTF16 NUL character. If
  /// |buflen| is less than the required length, or |buffer| is NULL,
  /// |buffer| will not be modified.
  int StructElement_GetStringAttribute(
    FPDF_STRUCTELEMENT struct_element,
    FPDF_BYTESTRING attr_name,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _StructElement_GetStringAttribute(
      struct_element,
      attr_name,
      buffer,
      buflen,
    );
  }

  late final _StructElement_GetStringAttributePtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedLong Function(FPDF_STRUCTELEMENT, FPDF_BYTESTRING,
                  ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>>(
      'PDFIUM_FPDF_StructElement_GetStringAttribute');
  late final _StructElement_GetStringAttribute =
      _StructElement_GetStringAttributePtr.asFunction<
          int Function(FPDF_STRUCTELEMENT, FPDF_BYTESTRING,
              ffi.Pointer<ffi.Void>, int)>();

  /// Function: FPDF_StructElement_GetMarkedContentID
  /// Get the marked content ID for a given element.
  /// Parameters:
  /// struct_element -   Handle to the struct element.
  /// Return value:
  /// The marked content ID of the element. If no ID exists, returns
  /// -1.
  /// Comments:
  /// FPDF_StructElement_GetMarkedContentIdAtIndex() may be able to
  /// extract more marked content IDs out of |struct_element|. This API
  /// may be deprecated in the future.
  int StructElement_GetMarkedContentID(
    FPDF_STRUCTELEMENT struct_element,
  ) {
    return _StructElement_GetMarkedContentID(
      struct_element,
    );
  }

  late final _StructElement_GetMarkedContentIDPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_STRUCTELEMENT)>>(
          'PDFIUM_FPDF_StructElement_GetMarkedContentID');
  late final _StructElement_GetMarkedContentID =
      _StructElement_GetMarkedContentIDPtr.asFunction<
          int Function(FPDF_STRUCTELEMENT)>();

  /// Function: FPDF_StructElement_GetType
  /// Get the type (/S) for a given element.
  /// Parameters:
  /// struct_element - Handle to the struct element.
  /// buffer         - A buffer for output. May be NULL.
  /// buflen         - The length of the buffer, in bytes. May be 0.
  /// Return value:
  /// The number of bytes in the type, including the terminating NUL
  /// character. The number of bytes is returned regardless of the
  /// |buffer| and |buflen| parameters.
  /// Comments:
  /// Regardless of the platform, the |buffer| is always in UTF-16LE
  /// encoding. The string is terminated by a UTF16 NUL character. If
  /// |buflen| is less than the required length, or |buffer| is NULL,
  /// |buffer| will not be modified.
  int StructElement_GetType(
    FPDF_STRUCTELEMENT struct_element,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _StructElement_GetType(
      struct_element,
      buffer,
      buflen,
    );
  }

  late final _StructElement_GetTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_STRUCTELEMENT, ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDF_StructElement_GetType');
  late final _StructElement_GetType = _StructElement_GetTypePtr.asFunction<
      int Function(FPDF_STRUCTELEMENT, ffi.Pointer<ffi.Void>, int)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_GetObjType
  /// Get the object type (/Type) for a given element.
  /// Parameters:
  /// struct_element - Handle to the struct element.
  /// buffer         - A buffer for output. May be NULL.
  /// buflen         - The length of the buffer, in bytes. May be 0.
  /// Return value:
  /// The number of bytes in the object type, including the terminating
  /// NUL character. The number of bytes is returned regardless of the
  /// |buffer| and |buflen| parameters.
  /// Comments:
  /// Regardless of the platform, the |buffer| is always in UTF-16LE
  /// encoding. The string is terminated by a UTF16 NUL character. If
  /// |buflen| is less than the required length, or |buffer| is NULL,
  /// |buffer| will not be modified.
  int StructElement_GetObjType(
    FPDF_STRUCTELEMENT struct_element,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _StructElement_GetObjType(
      struct_element,
      buffer,
      buflen,
    );
  }

  late final _StructElement_GetObjTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_STRUCTELEMENT, ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDF_StructElement_GetObjType');
  late final _StructElement_GetObjType =
      _StructElement_GetObjTypePtr.asFunction<
          int Function(FPDF_STRUCTELEMENT, ffi.Pointer<ffi.Void>, int)>();

  /// Function: FPDF_StructElement_GetTitle
  /// Get the title (/T) for a given element.
  /// Parameters:
  /// struct_element - Handle to the struct element.
  /// buffer         - A buffer for output. May be NULL.
  /// buflen         - The length of the buffer, in bytes. May be 0.
  /// Return value:
  /// The number of bytes in the title, including the terminating NUL
  /// character. The number of bytes is returned regardless of the
  /// |buffer| and |buflen| parameters.
  /// Comments:
  /// Regardless of the platform, the |buffer| is always in UTF-16LE
  /// encoding. The string is terminated by a UTF16 NUL character. If
  /// |buflen| is less than the required length, or |buffer| is NULL,
  /// |buffer| will not be modified.
  int StructElement_GetTitle(
    FPDF_STRUCTELEMENT struct_element,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _StructElement_GetTitle(
      struct_element,
      buffer,
      buflen,
    );
  }

  late final _StructElement_GetTitlePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_STRUCTELEMENT, ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDF_StructElement_GetTitle');
  late final _StructElement_GetTitle = _StructElement_GetTitlePtr.asFunction<
      int Function(FPDF_STRUCTELEMENT, ffi.Pointer<ffi.Void>, int)>();

  /// Function: FPDF_StructElement_CountChildren
  /// Count the number of children for the structure element.
  /// Parameters:
  /// struct_element -   Handle to the struct element.
  /// Return value:
  /// The number of children, or -1 on error.
  int StructElement_CountChildren(
    FPDF_STRUCTELEMENT struct_element,
  ) {
    return _StructElement_CountChildren(
      struct_element,
    );
  }

  late final _StructElement_CountChildrenPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_STRUCTELEMENT)>>(
          'PDFIUM_FPDF_StructElement_CountChildren');
  late final _StructElement_CountChildren = _StructElement_CountChildrenPtr
      .asFunction<int Function(FPDF_STRUCTELEMENT)>();

  /// Function: FPDF_StructElement_GetChildAtIndex
  /// Get a child in the structure element.
  /// Parameters:
  /// struct_element -   Handle to the struct element.
  /// index          -   The index for the child, 0-based.
  /// Return value:
  /// The child at the n-th index or NULL on error.
  /// Comments:
  /// If the child exists but is not an element, then this function will
  /// return NULL. This will also return NULL for out of bounds indices.
  /// The |index| must be less than the FPDF_StructElement_CountChildren()
  /// return value.
  FPDF_STRUCTELEMENT StructElement_GetChildAtIndex(
    FPDF_STRUCTELEMENT struct_element,
    int index,
  ) {
    return _StructElement_GetChildAtIndex(
      struct_element,
      index,
    );
  }

  late final _StructElement_GetChildAtIndexPtr = _lookup<
      ffi.NativeFunction<
          FPDF_STRUCTELEMENT Function(FPDF_STRUCTELEMENT,
              ffi.Int)>>('PDFIUM_FPDF_StructElement_GetChildAtIndex');
  late final _StructElement_GetChildAtIndex = _StructElement_GetChildAtIndexPtr
      .asFunction<FPDF_STRUCTELEMENT Function(FPDF_STRUCTELEMENT, int)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_GetChildMarkedContentID
  /// Get the child's content id
  /// Parameters:
  /// struct_element -   Handle to the struct element.
  /// index          -   The index for the child, 0-based.
  /// Return value:
  /// The marked content ID of the child. If no ID exists, returns -1.
  /// Comments:
  /// If the child exists but is not a stream or object, then this
  /// function will return -1. This will also return -1 for out of bounds
  /// indices. Compared to FPDF_StructElement_GetMarkedContentIdAtIndex,
  /// it is scoped to the current page.
  /// The |index| must be less than the FPDF_StructElement_CountChildren()
  /// return value.
  int StructElement_GetChildMarkedContentID(
    FPDF_STRUCTELEMENT struct_element,
    int index,
  ) {
    return _StructElement_GetChildMarkedContentID(
      struct_element,
      index,
    );
  }

  late final _StructElement_GetChildMarkedContentIDPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(FPDF_STRUCTELEMENT, ffi.Int)>>(
      'PDFIUM_FPDF_StructElement_GetChildMarkedContentID');
  late final _StructElement_GetChildMarkedContentID =
      _StructElement_GetChildMarkedContentIDPtr.asFunction<
          int Function(FPDF_STRUCTELEMENT, int)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_GetParent
  /// Get the parent of the structure element.
  /// Parameters:
  /// struct_element -   Handle to the struct element.
  /// Return value:
  /// The parent structure element or NULL on error.
  /// Comments:
  /// If structure element is StructTreeRoot, then this function will
  /// return NULL.
  FPDF_STRUCTELEMENT StructElement_GetParent(
    FPDF_STRUCTELEMENT struct_element,
  ) {
    return _StructElement_GetParent(
      struct_element,
    );
  }

  late final _StructElement_GetParentPtr = _lookup<
          ffi.NativeFunction<FPDF_STRUCTELEMENT Function(FPDF_STRUCTELEMENT)>>(
      'PDFIUM_FPDF_StructElement_GetParent');
  late final _StructElement_GetParent = _StructElement_GetParentPtr.asFunction<
      FPDF_STRUCTELEMENT Function(FPDF_STRUCTELEMENT)>();

  /// Function: FPDF_StructElement_GetAttributeCount
  /// Count the number of attributes for the structure element.
  /// Parameters:
  /// struct_element -   Handle to the struct element.
  /// Return value:
  /// The number of attributes, or -1 on error.
  int StructElement_GetAttributeCount(
    FPDF_STRUCTELEMENT struct_element,
  ) {
    return _StructElement_GetAttributeCount(
      struct_element,
    );
  }

  late final _StructElement_GetAttributeCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_STRUCTELEMENT)>>(
          'PDFIUM_FPDF_StructElement_GetAttributeCount');
  late final _StructElement_GetAttributeCount =
      _StructElement_GetAttributeCountPtr.asFunction<
          int Function(FPDF_STRUCTELEMENT)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_GetAttributeAtIndex
  /// Get an attribute object in the structure element.
  /// Parameters:
  /// struct_element -   Handle to the struct element.
  /// index          -   The index for the attribute object, 0-based.
  /// Return value:
  /// The attribute object at the n-th index or NULL on error.
  /// Comments:
  /// If the attribute object exists but is not a dict, then this
  /// function will return NULL. This will also return NULL for out of
  /// bounds indices. The caller does not own the handle. The handle
  /// remains valid as long as |struct_element| remains valid.
  /// The |index| must be less than the
  /// FPDF_StructElement_GetAttributeCount() return value.
  FPDF_STRUCTELEMENT_ATTR StructElement_GetAttributeAtIndex(
    FPDF_STRUCTELEMENT struct_element,
    int index,
  ) {
    return _StructElement_GetAttributeAtIndex(
      struct_element,
      index,
    );
  }

  late final _StructElement_GetAttributeAtIndexPtr = _lookup<
      ffi.NativeFunction<
          FPDF_STRUCTELEMENT_ATTR Function(FPDF_STRUCTELEMENT,
              ffi.Int)>>('PDFIUM_FPDF_StructElement_GetAttributeAtIndex');
  late final _StructElement_GetAttributeAtIndex =
      _StructElement_GetAttributeAtIndexPtr.asFunction<
          FPDF_STRUCTELEMENT_ATTR Function(FPDF_STRUCTELEMENT, int)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_Attr_GetCount
  /// Count the number of attributes in a structure element attribute map.
  /// Parameters:
  /// struct_attribute - Handle to the struct element attribute.
  /// Return value:
  /// The number of attributes, or -1 on error.
  int StructElement_Attr_GetCount(
    FPDF_STRUCTELEMENT_ATTR struct_attribute,
  ) {
    return _StructElement_Attr_GetCount(
      struct_attribute,
    );
  }

  late final _StructElement_Attr_GetCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_STRUCTELEMENT_ATTR)>>(
          'PDFIUM_FPDF_StructElement_Attr_GetCount');
  late final _StructElement_Attr_GetCount = _StructElement_Attr_GetCountPtr
      .asFunction<int Function(FPDF_STRUCTELEMENT_ATTR)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_Attr_GetName
  /// Get the name of an attribute in a structure element attribute map.
  /// Parameters:
  /// struct_attribute   - Handle to the struct element attribute.
  /// index              - The index of attribute in the map.
  /// buffer             - A buffer for output. May be NULL. This is only
  /// modified if |buflen| is longer than the length
  /// of the key. Optional, pass null to just
  /// retrieve the size of the buffer needed.
  /// buflen             - The length of the buffer.
  /// out_buflen         - A pointer to variable that will receive the
  /// minimum buffer size to contain the key. Not
  /// filled if FALSE is returned.
  /// Return value:
  /// TRUE if the operation was successful, FALSE otherwise.
  int StructElement_Attr_GetName(
    FPDF_STRUCTELEMENT_ATTR struct_attribute,
    int index,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
    ffi.Pointer<ffi.UnsignedLong> out_buflen,
  ) {
    return _StructElement_Attr_GetName(
      struct_attribute,
      index,
      buffer,
      buflen,
      out_buflen,
    );
  }

  late final _StructElement_Attr_GetNamePtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(
                  FPDF_STRUCTELEMENT_ATTR,
                  ffi.Int,
                  ffi.Pointer<ffi.Void>,
                  ffi.UnsignedLong,
                  ffi.Pointer<ffi.UnsignedLong>)>>(
      'PDFIUM_FPDF_StructElement_Attr_GetName');
  late final _StructElement_Attr_GetName =
      _StructElement_Attr_GetNamePtr.asFunction<
          int Function(FPDF_STRUCTELEMENT_ATTR, int, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.UnsignedLong>)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_Attr_GetValue
  /// Get a handle to a value for an attribute in a structure element
  /// attribute map.
  /// Parameters:
  /// struct_attribute   - Handle to the struct element attribute.
  /// name               - The attribute name.
  /// Return value:
  /// Returns a handle to the value associated with the input, if any.
  /// Returns NULL on failure. The caller does not own the handle.
  /// The handle remains valid as long as |struct_attribute| remains
  /// valid.
  FPDF_STRUCTELEMENT_ATTR_VALUE StructElement_Attr_GetValue(
    FPDF_STRUCTELEMENT_ATTR struct_attribute,
    FPDF_BYTESTRING name,
  ) {
    return _StructElement_Attr_GetValue(
      struct_attribute,
      name,
    );
  }

  late final _StructElement_Attr_GetValuePtr = _lookup<
      ffi.NativeFunction<
          FPDF_STRUCTELEMENT_ATTR_VALUE Function(FPDF_STRUCTELEMENT_ATTR,
              FPDF_BYTESTRING)>>('PDFIUM_FPDF_StructElement_Attr_GetValue');
  late final _StructElement_Attr_GetValue =
      _StructElement_Attr_GetValuePtr.asFunction<
          FPDF_STRUCTELEMENT_ATTR_VALUE Function(
              FPDF_STRUCTELEMENT_ATTR, FPDF_BYTESTRING)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_Attr_GetType
  /// Get the type of an attribute in a structure element attribute map.
  /// Parameters:
  /// value - Handle to the value.
  /// Return value:
  /// Returns the type of the value, or FPDF_OBJECT_UNKNOWN in case of
  /// failure. Note that this will never return FPDF_OBJECT_REFERENCE, as
  /// references are always dereferenced.
  int StructElement_Attr_GetType(
    FPDF_STRUCTELEMENT_ATTR_VALUE value,
  ) {
    return _StructElement_Attr_GetType(
      value,
    );
  }

  late final _StructElement_Attr_GetTypePtr = _lookup<
          ffi.NativeFunction<
              FPDF_OBJECT_TYPE Function(FPDF_STRUCTELEMENT_ATTR_VALUE)>>(
      'PDFIUM_FPDF_StructElement_Attr_GetType');
  late final _StructElement_Attr_GetType = _StructElement_Attr_GetTypePtr
      .asFunction<int Function(FPDF_STRUCTELEMENT_ATTR_VALUE)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_Attr_GetBooleanValue
  /// Get the value of a boolean attribute in an attribute map as
  /// FPDF_BOOL. FPDF_StructElement_Attr_GetType() should have returned
  /// FPDF_OBJECT_BOOLEAN for this property.
  /// Parameters:
  /// value     - Handle to the value.
  /// out_value - A pointer to variable that will receive the value. Not
  /// filled if false is returned.
  /// Return value:
  /// Returns TRUE if the attribute maps to a boolean value, FALSE
  /// otherwise.
  int StructElement_Attr_GetBooleanValue(
    FPDF_STRUCTELEMENT_ATTR_VALUE value,
    ffi.Pointer<FPDF_BOOL> out_value,
  ) {
    return _StructElement_Attr_GetBooleanValue(
      value,
      out_value,
    );
  }

  late final _StructElement_Attr_GetBooleanValuePtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(
                  FPDF_STRUCTELEMENT_ATTR_VALUE, ffi.Pointer<FPDF_BOOL>)>>(
      'PDFIUM_FPDF_StructElement_Attr_GetBooleanValue');
  late final _StructElement_Attr_GetBooleanValue =
      _StructElement_Attr_GetBooleanValuePtr.asFunction<
          int Function(
              FPDF_STRUCTELEMENT_ATTR_VALUE, ffi.Pointer<FPDF_BOOL>)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_Attr_GetNumberValue
  /// Get the value of a number attribute in an attribute map as float.
  /// FPDF_StructElement_Attr_GetType() should have returned
  /// FPDF_OBJECT_NUMBER for this property.
  /// Parameters:
  /// value     - Handle to the value.
  /// out_value - A pointer to variable that will receive the value. Not
  /// filled if false is returned.
  /// Return value:
  /// Returns TRUE if the attribute maps to a number value, FALSE
  /// otherwise.
  int StructElement_Attr_GetNumberValue(
    FPDF_STRUCTELEMENT_ATTR_VALUE value,
    ffi.Pointer<ffi.Float> out_value,
  ) {
    return _StructElement_Attr_GetNumberValue(
      value,
      out_value,
    );
  }

  late final _StructElement_Attr_GetNumberValuePtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(
                  FPDF_STRUCTELEMENT_ATTR_VALUE, ffi.Pointer<ffi.Float>)>>(
      'PDFIUM_FPDF_StructElement_Attr_GetNumberValue');
  late final _StructElement_Attr_GetNumberValue =
      _StructElement_Attr_GetNumberValuePtr.asFunction<
          int Function(
              FPDF_STRUCTELEMENT_ATTR_VALUE, ffi.Pointer<ffi.Float>)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_Attr_GetStringValue
  /// Get the value of a string attribute in an attribute map as string.
  /// FPDF_StructElement_Attr_GetType() should have returned
  /// FPDF_OBJECT_STRING or FPDF_OBJECT_NAME for this property.
  /// Parameters:
  /// value      - Handle to the value.
  /// buffer     - A buffer for holding the returned key in UTF-16LE.
  /// This is only modified if |buflen| is longer than the
  /// length of the key. Optional, pass null to just
  /// retrieve the size of the buffer needed.
  /// buflen     - The length of the buffer.
  /// out_buflen - A pointer to variable that will receive the minimum
  /// buffer size to contain the key. Not filled if FALSE is
  /// returned.
  /// Return value:
  /// Returns TRUE if the attribute maps to a string value, FALSE
  /// otherwise.
  int StructElement_Attr_GetStringValue(
    FPDF_STRUCTELEMENT_ATTR_VALUE value,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
    ffi.Pointer<ffi.UnsignedLong> out_buflen,
  ) {
    return _StructElement_Attr_GetStringValue(
      value,
      buffer,
      buflen,
      out_buflen,
    );
  }

  late final _StructElement_Attr_GetStringValuePtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(
                  FPDF_STRUCTELEMENT_ATTR_VALUE,
                  ffi.Pointer<ffi.Void>,
                  ffi.UnsignedLong,
                  ffi.Pointer<ffi.UnsignedLong>)>>(
      'PDFIUM_FPDF_StructElement_Attr_GetStringValue');
  late final _StructElement_Attr_GetStringValue =
      _StructElement_Attr_GetStringValuePtr.asFunction<
          int Function(FPDF_STRUCTELEMENT_ATTR_VALUE, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.UnsignedLong>)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_Attr_GetBlobValue
  /// Get the value of a blob attribute in an attribute map as string.
  /// Parameters:
  /// value      - Handle to the value.
  /// buffer     - A buffer for holding the returned value. This is only
  /// modified if |buflen| is at least as long as the length
  /// of the value. Optional, pass null to just retrieve the
  /// size of the buffer needed.
  /// buflen     - The length of the buffer.
  /// out_buflen - A pointer to variable that will receive the minimum
  /// buffer size to contain the key. Not filled if FALSE is
  /// returned.
  /// Return value:
  /// Returns TRUE if the attribute maps to a string value, FALSE
  /// otherwise.
  int StructElement_Attr_GetBlobValue(
    FPDF_STRUCTELEMENT_ATTR_VALUE value,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
    ffi.Pointer<ffi.UnsignedLong> out_buflen,
  ) {
    return _StructElement_Attr_GetBlobValue(
      value,
      buffer,
      buflen,
      out_buflen,
    );
  }

  late final _StructElement_Attr_GetBlobValuePtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(
                  FPDF_STRUCTELEMENT_ATTR_VALUE,
                  ffi.Pointer<ffi.Void>,
                  ffi.UnsignedLong,
                  ffi.Pointer<ffi.UnsignedLong>)>>(
      'PDFIUM_FPDF_StructElement_Attr_GetBlobValue');
  late final _StructElement_Attr_GetBlobValue =
      _StructElement_Attr_GetBlobValuePtr.asFunction<
          int Function(FPDF_STRUCTELEMENT_ATTR_VALUE, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.UnsignedLong>)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_Attr_CountChildren
  /// Count the number of children values in an attribute.
  /// Parameters:
  /// value - Handle to the value.
  /// Return value:
  /// The number of children, or -1 on error.
  int StructElement_Attr_CountChildren(
    FPDF_STRUCTELEMENT_ATTR_VALUE value,
  ) {
    return _StructElement_Attr_CountChildren(
      value,
    );
  }

  late final _StructElement_Attr_CountChildrenPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(FPDF_STRUCTELEMENT_ATTR_VALUE)>>(
      'PDFIUM_FPDF_StructElement_Attr_CountChildren');
  late final _StructElement_Attr_CountChildren =
      _StructElement_Attr_CountChildrenPtr.asFunction<
          int Function(FPDF_STRUCTELEMENT_ATTR_VALUE)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_Attr_GetChildAtIndex
  /// Get a child from an attribute.
  /// Parameters:
  /// value - Handle to the value.
  /// index - The index for the child, 0-based.
  /// Return value:
  /// The child at the n-th index or NULL on error.
  /// Comments:
  /// The |index| must be less than the
  /// FPDF_StructElement_Attr_CountChildren() return value.
  FPDF_STRUCTELEMENT_ATTR_VALUE StructElement_Attr_GetChildAtIndex(
    FPDF_STRUCTELEMENT_ATTR_VALUE value,
    int index,
  ) {
    return _StructElement_Attr_GetChildAtIndex(
      value,
      index,
    );
  }

  late final _StructElement_Attr_GetChildAtIndexPtr = _lookup<
      ffi.NativeFunction<
          FPDF_STRUCTELEMENT_ATTR_VALUE Function(FPDF_STRUCTELEMENT_ATTR_VALUE,
              ffi.Int)>>('PDFIUM_FPDF_StructElement_Attr_GetChildAtIndex');
  late final _StructElement_Attr_GetChildAtIndex =
      _StructElement_Attr_GetChildAtIndexPtr.asFunction<
          FPDF_STRUCTELEMENT_ATTR_VALUE Function(
              FPDF_STRUCTELEMENT_ATTR_VALUE, int)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_GetMarkedContentIdCount
  /// Get the count of marked content ids for a given element.
  /// Parameters:
  /// struct_element -   Handle to the struct element.
  /// Return value:
  /// The count of marked content ids or -1 if none exists.
  int StructElement_GetMarkedContentIdCount(
    FPDF_STRUCTELEMENT struct_element,
  ) {
    return _StructElement_GetMarkedContentIdCount(
      struct_element,
    );
  }

  late final _StructElement_GetMarkedContentIdCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_STRUCTELEMENT)>>(
          'PDFIUM_FPDF_StructElement_GetMarkedContentIdCount');
  late final _StructElement_GetMarkedContentIdCount =
      _StructElement_GetMarkedContentIdCountPtr.asFunction<
          int Function(FPDF_STRUCTELEMENT)>();

  /// Experimental API.
  /// Function: FPDF_StructElement_GetMarkedContentIdAtIndex
  /// Get the marked content id at a given index for a given element.
  /// Parameters:
  /// struct_element -   Handle to the struct element.
  /// index          -   The index of the marked content id, 0-based.
  /// Return value:
  /// The marked content ID of the element. If no ID exists, returns
  /// -1.
  /// Comments:
  /// The |index| must be less than the
  /// FPDF_StructElement_GetMarkedContentIdCount() return value.
  /// This will likely supersede FPDF_StructElement_GetMarkedContentID().
  int StructElement_GetMarkedContentIdAtIndex(
    FPDF_STRUCTELEMENT struct_element,
    int index,
  ) {
    return _StructElement_GetMarkedContentIdAtIndex(
      struct_element,
      index,
    );
  }

  late final _StructElement_GetMarkedContentIdAtIndexPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(FPDF_STRUCTELEMENT, ffi.Int)>>(
      'PDFIUM_FPDF_StructElement_GetMarkedContentIdAtIndex');
  late final _StructElement_GetMarkedContentIdAtIndex =
      _StructElement_GetMarkedContentIdAtIndexPtr.asFunction<
          int Function(FPDF_STRUCTELEMENT, int)>();

  /// Experimental API.
  /// Import pages to a FPDF_DOCUMENT.
  /// dest_doc     - The destination document for the pages.
  /// src_doc      - The document to be imported.
  /// page_indices - An array of page indices to be imported. The first page is
  /// zero. If |page_indices| is NULL, all pages from |src_doc|
  /// are imported.
  /// length       - The length of the |page_indices| array.
  /// index        - The page index at which to insert the first imported page
  /// into |dest_doc|. The first page is zero.
  /// Returns TRUE on success. Returns FALSE if any pages in |page_indices| is
  /// invalid.
  int ImportPagesByIndex(
    FPDF_DOCUMENT dest_doc,
    FPDF_DOCUMENT src_doc,
    ffi.Pointer<ffi.Int> page_indices,
    int length,
    int index,
  ) {
    return _ImportPagesByIndex(
      dest_doc,
      src_doc,
      page_indices,
      length,
      index,
    );
  }

  late final _ImportPagesByIndexPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_DOCUMENT, FPDF_DOCUMENT, ffi.Pointer<ffi.Int>,
              ffi.UnsignedLong, ffi.Int)>>('PDFIUM_FPDF_ImportPagesByIndex');
  late final _ImportPagesByIndex = _ImportPagesByIndexPtr.asFunction<
      int Function(
          FPDF_DOCUMENT, FPDF_DOCUMENT, ffi.Pointer<ffi.Int>, int, int)>();

  /// Import pages to a FPDF_DOCUMENT.
  /// dest_doc  - The destination document for the pages.
  /// src_doc   - The document to be imported.
  /// pagerange - A page range string, Such as "1,3,5-7". The first page is one.
  /// If |pagerange| is NULL, all pages from |src_doc| are imported.
  /// index     - The page index at which to insert the first imported page into
  /// |dest_doc|. The first page is zero.
  /// Returns TRUE on success. Returns FALSE if any pages in |pagerange| is
  /// invalid or if |pagerange| cannot be read.
  int ImportPages(
    FPDF_DOCUMENT dest_doc,
    FPDF_DOCUMENT src_doc,
    FPDF_BYTESTRING pagerange,
    int index,
  ) {
    return _ImportPages(
      dest_doc,
      src_doc,
      pagerange,
      index,
    );
  }

  late final _ImportPagesPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_DOCUMENT, FPDF_DOCUMENT, FPDF_BYTESTRING,
              ffi.Int)>>('PDFIUM_FPDF_ImportPages');
  late final _ImportPages = _ImportPagesPtr.asFunction<
      int Function(FPDF_DOCUMENT, FPDF_DOCUMENT, FPDF_BYTESTRING, int)>();

  /// Experimental API.
  /// Create a new document from |src_doc|.  The pages of |src_doc| will be
  /// combined to provide |num_pages_on_x_axis x num_pages_on_y_axis| pages per
  /// |output_doc| page.
  /// src_doc             - The document to be imported.
  /// output_width        - The output page width in PDF "user space" units.
  /// output_height       - The output page height in PDF "user space" units.
  /// num_pages_on_x_axis - The number of pages on X Axis.
  /// num_pages_on_y_axis - The number of pages on Y Axis.
  /// Return value:
  /// A handle to the created document, or NULL on failure.
  /// Comments:
  /// number of pages per page = num_pages_on_x_axis * num_pages_on_y_axis
  FPDF_DOCUMENT ImportNPagesToOne(
    FPDF_DOCUMENT src_doc,
    double output_width,
    double output_height,
    int num_pages_on_x_axis,
    int num_pages_on_y_axis,
  ) {
    return _ImportNPagesToOne(
      src_doc,
      output_width,
      output_height,
      num_pages_on_x_axis,
      num_pages_on_y_axis,
    );
  }

  late final _ImportNPagesToOnePtr = _lookup<
      ffi.NativeFunction<
          FPDF_DOCUMENT Function(FPDF_DOCUMENT, ffi.Float, ffi.Float, ffi.Size,
              ffi.Size)>>('PDFIUM_FPDF_ImportNPagesToOne');
  late final _ImportNPagesToOne = _ImportNPagesToOnePtr.asFunction<
      FPDF_DOCUMENT Function(FPDF_DOCUMENT, double, double, int, int)>();

  /// Experimental API.
  /// Create a template to generate form xobjects from |src_doc|'s page at
  /// |src_page_index|, for use in |dest_doc|.
  /// Returns a handle on success, or NULL on failure. Caller owns the newly
  /// created object.
  FPDF_XOBJECT NewXObjectFromPage(
    FPDF_DOCUMENT dest_doc,
    FPDF_DOCUMENT src_doc,
    int src_page_index,
  ) {
    return _NewXObjectFromPage(
      dest_doc,
      src_doc,
      src_page_index,
    );
  }

  late final _NewXObjectFromPagePtr = _lookup<
      ffi.NativeFunction<
          FPDF_XOBJECT Function(FPDF_DOCUMENT, FPDF_DOCUMENT,
              ffi.Int)>>('PDFIUM_FPDF_NewXObjectFromPage');
  late final _NewXObjectFromPage = _NewXObjectFromPagePtr.asFunction<
      FPDF_XOBJECT Function(FPDF_DOCUMENT, FPDF_DOCUMENT, int)>();

  /// Experimental API.
  /// Close an FPDF_XOBJECT handle created by FPDF_NewXObjectFromPage().
  /// FPDF_PAGEOBJECTs created from the FPDF_XOBJECT handle are not affected.
  void CloseXObject(
    FPDF_XOBJECT xobject,
  ) {
    return _CloseXObject(
      xobject,
    );
  }

  late final _CloseXObjectPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_XOBJECT)>>(
          'PDFIUM_FPDF_CloseXObject');
  late final _CloseXObject =
      _CloseXObjectPtr.asFunction<void Function(FPDF_XOBJECT)>();

  /// Experimental API.
  /// Create a new form object from an FPDF_XOBJECT object.
  /// Returns a new form object on success, or NULL on failure. Caller owns the
  /// newly created object.
  FPDF_PAGEOBJECT NewFormObjectFromXObject(
    FPDF_XOBJECT xobject,
  ) {
    return _NewFormObjectFromXObject(
      xobject,
    );
  }

  late final _NewFormObjectFromXObjectPtr =
      _lookup<ffi.NativeFunction<FPDF_PAGEOBJECT Function(FPDF_XOBJECT)>>(
          'PDFIUM_FPDF_NewFormObjectFromXObject');
  late final _NewFormObjectFromXObject = _NewFormObjectFromXObjectPtr
      .asFunction<FPDF_PAGEOBJECT Function(FPDF_XOBJECT)>();

  /// Copy the viewer preferences from |src_doc| into |dest_doc|.
  /// dest_doc - Document to write the viewer preferences into.
  /// src_doc  - Document to read the viewer preferences from.
  /// Returns TRUE on success.
  int CopyViewerPreferences(
    FPDF_DOCUMENT dest_doc,
    FPDF_DOCUMENT src_doc,
  ) {
    return _CopyViewerPreferences(
      dest_doc,
      src_doc,
    );
  }

  late final _CopyViewerPreferencesPtr = _lookup<
          ffi.NativeFunction<FPDF_BOOL Function(FPDF_DOCUMENT, FPDF_DOCUMENT)>>(
      'PDFIUM_FPDF_CopyViewerPreferences');
  late final _CopyViewerPreferences = _CopyViewerPreferencesPtr.asFunction<
      int Function(FPDF_DOCUMENT, FPDF_DOCUMENT)>();

  /// Function: FPDF_InitLibraryWithConfig
  /// Initialize the PDFium library and allocate global resources for it.
  /// Parameters:
  /// config - configuration information as above.
  /// Return value:
  /// None.
  /// Comments:
  /// You have to call this function before you can call any PDF
  /// processing functions.
  void InitLibraryWithConfig(
    ffi.Pointer<FPDF_LIBRARY_CONFIG> config,
  ) {
    return _InitLibraryWithConfig(
      config,
    );
  }

  late final _InitLibraryWithConfigPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<FPDF_LIBRARY_CONFIG>)>>(
      'PDFIUM_FPDF_InitLibraryWithConfig');
  late final _InitLibraryWithConfig = _InitLibraryWithConfigPtr.asFunction<
      void Function(ffi.Pointer<FPDF_LIBRARY_CONFIG>)>();

  /// Function: FPDF_InitLibrary
  /// Initialize the PDFium library (alternative form).
  /// Parameters:
  /// None
  /// Return value:
  /// None.
  /// Comments:
  /// Convenience function to call FPDF_InitLibraryWithConfig() with a
  /// default configuration for backwards compatibility purposes. New
  /// code should call FPDF_InitLibraryWithConfig() instead. This will
  /// be deprecated in the future.
  void InitLibrary() {
    return _InitLibrary();
  }

  late final _InitLibraryPtr = _lookup<ffi.NativeFunction<ffi.Void Function()>>(
      'PDFIUM_FPDF_InitLibrary');
  late final _InitLibrary = _InitLibraryPtr.asFunction<void Function()>();

  /// Function: FPDF_DestroyLibrary
  /// Release global resources allocated to the PDFium library by
  /// FPDF_InitLibrary() or FPDF_InitLibraryWithConfig().
  /// Parameters:
  /// None.
  /// Return value:
  /// None.
  /// Comments:
  /// After this function is called, you must not call any PDF
  /// processing functions.
  /// Calling this function does not automatically close other
  /// objects. It is recommended to close other objects before
  /// closing the library with this function.
  void DestroyLibrary() {
    return _DestroyLibrary();
  }

  late final _DestroyLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'PDFIUM_FPDF_DestroyLibrary');
  late final _DestroyLibrary = _DestroyLibraryPtr.asFunction<void Function()>();

  /// Function: FPDF_SetSandBoxPolicy
  /// Set the policy for the sandbox environment.
  /// Parameters:
  /// policy -   The specified policy for setting, for example:
  /// FPDF_POLICY_MACHINETIME_ACCESS.
  /// enable -   True to enable, false to disable the policy.
  /// Return value:
  /// None.
  void SetSandBoxPolicy(
    int policy,
    int enable,
  ) {
    return _SetSandBoxPolicy(
      policy,
      enable,
    );
  }

  late final _SetSandBoxPolicyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_DWORD, FPDF_BOOL)>>(
          'PDFIUM_FPDF_SetSandBoxPolicy');
  late final _SetSandBoxPolicy =
      _SetSandBoxPolicyPtr.asFunction<void Function(int, int)>();

  /// Function: FPDF_LoadDocument
  /// Open and load a PDF document.
  /// Parameters:
  /// file_path -  Path to the PDF file (including extension).
  /// password  -  A string used as the password for the PDF file.
  /// If no password is needed, empty or NULL can be used.
  /// See comments below regarding the encoding.
  /// Return value:
  /// A handle to the loaded document, or NULL on failure.
  /// Comments:
  /// Loaded document can be closed by FPDF_CloseDocument().
  /// If this function fails, you can use FPDF_GetLastError() to retrieve
  /// the reason why it failed.
  /// The encoding for |file_path| is UTF-8.
  /// The encoding for |password| can be either UTF-8 or Latin-1. PDFs,
  /// depending on the security handler revision, will only accept one or
  /// the other encoding. If |password|'s encoding and the PDF's expected
  /// encoding do not match, FPDF_LoadDocument() will automatically
  /// convert |password| to the other encoding.
  FPDF_DOCUMENT LoadDocument(
    FPDF_STRING file_path,
    FPDF_BYTESTRING password,
  ) {
    return _LoadDocument(
      file_path,
      password,
    );
  }

  late final _LoadDocumentPtr = _lookup<
      ffi.NativeFunction<
          FPDF_DOCUMENT Function(
              FPDF_STRING, FPDF_BYTESTRING)>>('PDFIUM_FPDF_LoadDocument');
  late final _LoadDocument = _LoadDocumentPtr.asFunction<
      FPDF_DOCUMENT Function(FPDF_STRING, FPDF_BYTESTRING)>();

  /// Function: FPDF_LoadMemDocument
  /// Open and load a PDF document from memory.
  /// Parameters:
  /// data_buf    -   Pointer to a buffer containing the PDF document.
  /// size        -   Number of bytes in the PDF document.
  /// password    -   A string used as the password for the PDF file.
  /// If no password is needed, empty or NULL can be used.
  /// Return value:
  /// A handle to the loaded document, or NULL on failure.
  /// Comments:
  /// The memory buffer must remain valid when the document is open.
  /// The loaded document can be closed by FPDF_CloseDocument.
  /// If this function fails, you can use FPDF_GetLastError() to retrieve
  /// the reason why it failed.
  /// See the comments for FPDF_LoadDocument() regarding the encoding for
  /// |password|.
  /// Notes:
  /// If PDFium is built with the XFA module, the application should call
  /// FPDF_LoadXFA() function after the PDF document loaded to support XFA
  /// fields defined in the fpdfformfill.h file.
  FPDF_DOCUMENT LoadMemDocument(
    ffi.Pointer<ffi.Void> data_buf,
    int size,
    FPDF_BYTESTRING password,
  ) {
    return _LoadMemDocument(
      data_buf,
      size,
      password,
    );
  }

  late final _LoadMemDocumentPtr = _lookup<
      ffi.NativeFunction<
          FPDF_DOCUMENT Function(ffi.Pointer<ffi.Void>, ffi.Int,
              FPDF_BYTESTRING)>>('PDFIUM_FPDF_LoadMemDocument');
  late final _LoadMemDocument = _LoadMemDocumentPtr.asFunction<
      FPDF_DOCUMENT Function(ffi.Pointer<ffi.Void>, int, FPDF_BYTESTRING)>();

  /// Experimental API.
  /// Function: FPDF_LoadMemDocument64
  /// Open and load a PDF document from memory.
  /// Parameters:
  /// data_buf    -   Pointer to a buffer containing the PDF document.
  /// size        -   Number of bytes in the PDF document.
  /// password    -   A string used as the password for the PDF file.
  /// If no password is needed, empty or NULL can be used.
  /// Return value:
  /// A handle to the loaded document, or NULL on failure.
  /// Comments:
  /// The memory buffer must remain valid when the document is open.
  /// The loaded document can be closed by FPDF_CloseDocument.
  /// If this function fails, you can use FPDF_GetLastError() to retrieve
  /// the reason why it failed.
  /// See the comments for FPDF_LoadDocument() regarding the encoding for
  /// |password|.
  /// Notes:
  /// If PDFium is built with the XFA module, the application should call
  /// FPDF_LoadXFA() function after the PDF document loaded to support XFA
  /// fields defined in the fpdfformfill.h file.
  FPDF_DOCUMENT LoadMemDocument64(
    ffi.Pointer<ffi.Void> data_buf,
    int size,
    FPDF_BYTESTRING password,
  ) {
    return _LoadMemDocument64(
      data_buf,
      size,
      password,
    );
  }

  late final _LoadMemDocument64Ptr = _lookup<
      ffi.NativeFunction<
          FPDF_DOCUMENT Function(ffi.Pointer<ffi.Void>, ffi.Size,
              FPDF_BYTESTRING)>>('PDFIUM_FPDF_LoadMemDocument64');
  late final _LoadMemDocument64 = _LoadMemDocument64Ptr.asFunction<
      FPDF_DOCUMENT Function(ffi.Pointer<ffi.Void>, int, FPDF_BYTESTRING)>();

  /// Function: FPDF_LoadCustomDocument
  /// Load PDF document from a custom access descriptor.
  /// Parameters:
  /// pFileAccess -   A structure for accessing the file.
  /// password    -   Optional password for decrypting the PDF file.
  /// Return value:
  /// A handle to the loaded document, or NULL on failure.
  /// Comments:
  /// The application must keep the file resources |pFileAccess| points to
  /// valid until the returned FPDF_DOCUMENT is closed. |pFileAccess|
  /// itself does not need to outlive the FPDF_DOCUMENT.
  /// The loaded document can be closed with FPDF_CloseDocument().
  /// See the comments for FPDF_LoadDocument() regarding the encoding for
  /// |password|.
  /// Notes:
  /// If PDFium is built with the XFA module, the application should call
  /// FPDF_LoadXFA() function after the PDF document loaded to support XFA
  /// fields defined in the fpdfformfill.h file.
  FPDF_DOCUMENT LoadCustomDocument(
    ffi.Pointer<FPDF_FILEACCESS> pFileAccess,
    FPDF_BYTESTRING password,
  ) {
    return _LoadCustomDocument(
      pFileAccess,
      password,
    );
  }

  late final _LoadCustomDocumentPtr = _lookup<
      ffi.NativeFunction<
          FPDF_DOCUMENT Function(ffi.Pointer<FPDF_FILEACCESS>,
              FPDF_BYTESTRING)>>('PDFIUM_FPDF_LoadCustomDocument');
  late final _LoadCustomDocument = _LoadCustomDocumentPtr.asFunction<
      FPDF_DOCUMENT Function(ffi.Pointer<FPDF_FILEACCESS>, FPDF_BYTESTRING)>();

  /// Function: FPDF_GetFileVersion
  /// Get the file version of the given PDF document.
  /// Parameters:
  /// doc         -   Handle to a document.
  /// fileVersion -   The PDF file version. File version: 14 for 1.4, 15
  /// for 1.5, ...
  /// Return value:
  /// True if succeeds, false otherwise.
  /// Comments:
  /// If the document was created by FPDF_CreateNewDocument,
  /// then this function will always fail.
  int GetFileVersion(
    FPDF_DOCUMENT doc,
    ffi.Pointer<ffi.Int> fileVersion,
  ) {
    return _GetFileVersion(
      doc,
      fileVersion,
    );
  }

  late final _GetFileVersionPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_DOCUMENT,
              ffi.Pointer<ffi.Int>)>>('PDFIUM_FPDF_GetFileVersion');
  late final _GetFileVersion = _GetFileVersionPtr.asFunction<
      int Function(FPDF_DOCUMENT, ffi.Pointer<ffi.Int>)>();

  /// Function: FPDF_GetLastError
  /// Get last error code when a function fails.
  /// Parameters:
  /// None.
  /// Return value:
  /// A 32-bit integer indicating error code as defined above.
  /// Comments:
  /// If the previous SDK call succeeded, the return value of this
  /// function is not defined. This function only works in conjunction
  /// with APIs that mention FPDF_GetLastError() in their documentation.
  int GetLastError() {
    return _GetLastError();
  }

  late final _GetLastErrorPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLong Function()>>(
          'PDFIUM_FPDF_GetLastError');
  late final _GetLastError = _GetLastErrorPtr.asFunction<int Function()>();

  /// Experimental API.
  /// Function: FPDF_DocumentHasValidCrossReferenceTable
  /// Whether the document's cross reference table is valid or not.
  /// Parameters:
  /// document    -   Handle to a document. Returned by FPDF_LoadDocument.
  /// Return value:
  /// True if the PDF parser did not encounter problems parsing the cross
  /// reference table. False if the parser could not parse the cross
  /// reference table and the table had to be rebuild from other data
  /// within the document.
  /// Comments:
  /// The return value can change over time as the PDF parser evolves.
  int DocumentHasValidCrossReferenceTable(
    FPDF_DOCUMENT document,
  ) {
    return _DocumentHasValidCrossReferenceTable(
      document,
    );
  }

  late final _DocumentHasValidCrossReferenceTablePtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDF_DocumentHasValidCrossReferenceTable');
  late final _DocumentHasValidCrossReferenceTable =
      _DocumentHasValidCrossReferenceTablePtr.asFunction<
          int Function(FPDF_DOCUMENT)>();

  /// Experimental API.
  /// Function: FPDF_GetTrailerEnds
  /// Get the byte offsets of trailer ends.
  /// Parameters:
  /// document    -   Handle to document. Returned by FPDF_LoadDocument().
  /// buffer      -   The address of a buffer that receives the
  /// byte offsets.
  /// length      -   The size, in ints, of |buffer|.
  /// Return value:
  /// Returns the number of ints in the buffer on success, 0 on error.
  /// |buffer| is an array of integers that describes the exact byte offsets of the
  /// trailer ends in the document. If |length| is less than the returned length,
  /// or |document| or |buffer| is NULL, |buffer| will not be modified.
  int GetTrailerEnds(
    FPDF_DOCUMENT document,
    ffi.Pointer<ffi.UnsignedInt> buffer,
    int length,
  ) {
    return _GetTrailerEnds(
      document,
      buffer,
      length,
    );
  }

  late final _GetTrailerEndsPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_DOCUMENT, ffi.Pointer<ffi.UnsignedInt>,
              ffi.UnsignedLong)>>('PDFIUM_FPDF_GetTrailerEnds');
  late final _GetTrailerEnds = _GetTrailerEndsPtr.asFunction<
      int Function(FPDF_DOCUMENT, ffi.Pointer<ffi.UnsignedInt>, int)>();

  /// Function: FPDF_GetDocPermissions
  /// Get file permission flags of the document.
  /// Parameters:
  /// document    -   Handle to a document. Returned by FPDF_LoadDocument.
  /// Return value:
  /// A 32-bit integer indicating permission flags. Please refer to the
  /// PDF Reference for detailed descriptions. If the document is not
  /// protected or was unlocked by the owner, 0xffffffff will be returned.
  int GetDocPermissions(
    FPDF_DOCUMENT document,
  ) {
    return _GetDocPermissions(
      document,
    );
  }

  late final _GetDocPermissionsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLong Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDF_GetDocPermissions');
  late final _GetDocPermissions =
      _GetDocPermissionsPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_GetDocUserPermissions
  /// Get user file permission flags of the document.
  /// Parameters:
  /// document    -   Handle to a document. Returned by FPDF_LoadDocument.
  /// Return value:
  /// A 32-bit integer indicating permission flags. Please refer to the
  /// PDF Reference for detailed descriptions. If the document is not
  /// protected, 0xffffffff will be returned. Always returns user
  /// permissions, even if the document was unlocked by the owner.
  int GetDocUserPermissions(
    FPDF_DOCUMENT document,
  ) {
    return _GetDocUserPermissions(
      document,
    );
  }

  late final _GetDocUserPermissionsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLong Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDF_GetDocUserPermissions');
  late final _GetDocUserPermissions =
      _GetDocUserPermissionsPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_GetSecurityHandlerRevision
  /// Get the revision for the security handler.
  /// Parameters:
  /// document    -   Handle to a document. Returned by FPDF_LoadDocument.
  /// Return value:
  /// The security handler revision number. Please refer to the PDF
  /// Reference for a detailed description. If the document is not
  /// protected, -1 will be returned.
  int GetSecurityHandlerRevision(
    FPDF_DOCUMENT document,
  ) {
    return _GetSecurityHandlerRevision(
      document,
    );
  }

  late final _GetSecurityHandlerRevisionPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDF_GetSecurityHandlerRevision');
  late final _GetSecurityHandlerRevision =
      _GetSecurityHandlerRevisionPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_GetPageCount
  /// Get total number of pages in the document.
  /// Parameters:
  /// document    -   Handle to document. Returned by FPDF_LoadDocument.
  /// Return value:
  /// Total number of pages in the document.
  int GetPageCount(
    FPDF_DOCUMENT document,
  ) {
    return _GetPageCount(
      document,
    );
  }

  late final _GetPageCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDF_GetPageCount');
  late final _GetPageCount =
      _GetPageCountPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_LoadPage
  /// Load a page inside the document.
  /// Parameters:
  /// document    -   Handle to document. Returned by FPDF_LoadDocument
  /// page_index  -   Index number of the page. 0 for the first page.
  /// Return value:
  /// A handle to the loaded page, or NULL if page load fails.
  /// Comments:
  /// The loaded page can be rendered to devices using FPDF_RenderPage.
  /// The loaded page can be closed using FPDF_ClosePage.
  FPDF_PAGE LoadPage(
    FPDF_DOCUMENT document,
    int page_index,
  ) {
    return _LoadPage(
      document,
      page_index,
    );
  }

  late final _LoadPagePtr =
      _lookup<ffi.NativeFunction<FPDF_PAGE Function(FPDF_DOCUMENT, ffi.Int)>>(
          'PDFIUM_FPDF_LoadPage');
  late final _LoadPage =
      _LoadPagePtr.asFunction<FPDF_PAGE Function(FPDF_DOCUMENT, int)>();

  /// Experimental API
  /// Function: FPDF_GetPageWidthF
  /// Get page width.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage().
  /// Return value:
  /// Page width (excluding non-displayable area) measured in points.
  /// One point is 1/72 inch (around 0.3528 mm).
  /// Comments:
  /// Changing the rotation of |page| affects the return value.
  double GetPageWidthF(
    FPDF_PAGE page,
  ) {
    return _GetPageWidthF(
      page,
    );
  }

  late final _GetPageWidthFPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(FPDF_PAGE)>>(
          'PDFIUM_FPDF_GetPageWidthF');
  late final _GetPageWidthF =
      _GetPageWidthFPtr.asFunction<double Function(FPDF_PAGE)>();

  /// Function: FPDF_GetPageWidth
  /// Get page width.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// Return value:
  /// Page width (excluding non-displayable area) measured in points.
  /// One point is 1/72 inch (around 0.3528 mm).
  /// Note:
  /// Prefer FPDF_GetPageWidthF() above. This will be deprecated in the
  /// future.
  /// Comments:
  /// Changing the rotation of |page| affects the return value.
  double GetPageWidth(
    FPDF_PAGE page,
  ) {
    return _GetPageWidth(
      page,
    );
  }

  late final _GetPageWidthPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(FPDF_PAGE)>>(
          'PDFIUM_FPDF_GetPageWidth');
  late final _GetPageWidth =
      _GetPageWidthPtr.asFunction<double Function(FPDF_PAGE)>();

  /// Experimental API
  /// Function: FPDF_GetPageHeightF
  /// Get page height.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage().
  /// Return value:
  /// Page height (excluding non-displayable area) measured in points.
  /// One point is 1/72 inch (around 0.3528 mm)
  /// Comments:
  /// Changing the rotation of |page| affects the return value.
  double GetPageHeightF(
    FPDF_PAGE page,
  ) {
    return _GetPageHeightF(
      page,
    );
  }

  late final _GetPageHeightFPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(FPDF_PAGE)>>(
          'PDFIUM_FPDF_GetPageHeightF');
  late final _GetPageHeightF =
      _GetPageHeightFPtr.asFunction<double Function(FPDF_PAGE)>();

  /// Function: FPDF_GetPageHeight
  /// Get page height.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// Return value:
  /// Page height (excluding non-displayable area) measured in points.
  /// One point is 1/72 inch (around 0.3528 mm)
  /// Note:
  /// Prefer FPDF_GetPageHeightF() above. This will be deprecated in the
  /// future.
  /// Comments:
  /// Changing the rotation of |page| affects the return value.
  double GetPageHeight(
    FPDF_PAGE page,
  ) {
    return _GetPageHeight(
      page,
    );
  }

  late final _GetPageHeightPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(FPDF_PAGE)>>(
          'PDFIUM_FPDF_GetPageHeight');
  late final _GetPageHeight =
      _GetPageHeightPtr.asFunction<double Function(FPDF_PAGE)>();

  /// Experimental API.
  /// Function: FPDF_GetPageBoundingBox
  /// Get the bounding box of the page. This is the intersection between
  /// its media box and its crop box.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// rect        -   Pointer to a rect to receive the page bounding box.
  /// On an error, |rect| won't be filled.
  /// Return value:
  /// True for success.
  int GetPageBoundingBox(
    FPDF_PAGE page,
    ffi.Pointer<FS_RECTF> rect,
  ) {
    return _GetPageBoundingBox(
      page,
      rect,
    );
  }

  late final _GetPageBoundingBoxPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGE,
              ffi.Pointer<FS_RECTF>)>>('PDFIUM_FPDF_GetPageBoundingBox');
  late final _GetPageBoundingBox = _GetPageBoundingBoxPtr.asFunction<
      int Function(FPDF_PAGE, ffi.Pointer<FS_RECTF>)>();

  /// Experimental API.
  /// Function: FPDF_GetPageSizeByIndexF
  /// Get the size of the page at the given index.
  /// Parameters:
  /// document    -   Handle to document. Returned by FPDF_LoadDocument().
  /// page_index  -   Page index, zero for the first page.
  /// size        -   Pointer to a FS_SIZEF to receive the page size.
  /// (in points).
  /// Return value:
  /// Non-zero for success. 0 for error (document or page not found).
  int GetPageSizeByIndexF(
    FPDF_DOCUMENT document,
    int page_index,
    ffi.Pointer<FS_SIZEF> size,
  ) {
    return _GetPageSizeByIndexF(
      document,
      page_index,
      size,
    );
  }

  late final _GetPageSizeByIndexFPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_DOCUMENT, ffi.Int,
              ffi.Pointer<FS_SIZEF>)>>('PDFIUM_FPDF_GetPageSizeByIndexF');
  late final _GetPageSizeByIndexF = _GetPageSizeByIndexFPtr.asFunction<
      int Function(FPDF_DOCUMENT, int, ffi.Pointer<FS_SIZEF>)>();

  /// Function: FPDF_GetPageSizeByIndex
  /// Get the size of the page at the given index.
  /// Parameters:
  /// document    -   Handle to document. Returned by FPDF_LoadDocument.
  /// page_index  -   Page index, zero for the first page.
  /// width       -   Pointer to a double to receive the page width
  /// (in points).
  /// height      -   Pointer to a double to receive the page height
  /// (in points).
  /// Return value:
  /// Non-zero for success. 0 for error (document or page not found).
  /// Note:
  /// Prefer FPDF_GetPageSizeByIndexF() above. This will be deprecated in
  /// the future.
  int GetPageSizeByIndex(
    FPDF_DOCUMENT document,
    int page_index,
    ffi.Pointer<ffi.Double> width,
    ffi.Pointer<ffi.Double> height,
  ) {
    return _GetPageSizeByIndex(
      document,
      page_index,
      width,
      height,
    );
  }

  late final _GetPageSizeByIndexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(FPDF_DOCUMENT, ffi.Int, ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>)>>('PDFIUM_FPDF_GetPageSizeByIndex');
  late final _GetPageSizeByIndex = _GetPageSizeByIndexPtr.asFunction<
      int Function(FPDF_DOCUMENT, int, ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>)>();

  /// Function: FPDF_RenderPageBitmap
  /// Render contents of a page to a device independent bitmap.
  /// Parameters:
  /// bitmap      -   Handle to the device independent bitmap (as the
  /// output buffer). The bitmap handle can be created
  /// by FPDFBitmap_Create or retrieved from an image
  /// object by FPDFImageObj_GetBitmap.
  /// page        -   Handle to the page. Returned by FPDF_LoadPage
  /// start_x     -   Left pixel position of the display area in
  /// bitmap coordinates.
  /// start_y     -   Top pixel position of the display area in bitmap
  /// coordinates.
  /// size_x      -   Horizontal size (in pixels) for displaying the page.
  /// size_y      -   Vertical size (in pixels) for displaying the page.
  /// rotate      -   Page orientation:
  /// 0 (normal)
  /// 1 (rotated 90 degrees clockwise)
  /// 2 (rotated 180 degrees)
  /// 3 (rotated 90 degrees counter-clockwise)
  /// flags       -   0 for normal display, or combination of the Page
  /// Rendering flags defined above. With the FPDF_ANNOT
  /// flag, it renders all annotations that do not require
  /// user-interaction, which are all annotations except
  /// widget and popup annotations.
  /// Return value:
  /// None.
  void RenderPageBitmap(
    FPDF_BITMAP bitmap,
    FPDF_PAGE page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    int flags,
  ) {
    return _RenderPageBitmap(
      bitmap,
      page,
      start_x,
      start_y,
      size_x,
      size_y,
      rotate,
      flags,
    );
  }

  late final _RenderPageBitmapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FPDF_BITMAP, FPDF_PAGE, ffi.Int, ffi.Int, ffi.Int,
              ffi.Int, ffi.Int, ffi.Int)>>('PDFIUM_FPDF_RenderPageBitmap');
  late final _RenderPageBitmap = _RenderPageBitmapPtr.asFunction<
      void Function(FPDF_BITMAP, FPDF_PAGE, int, int, int, int, int, int)>();

  /// Function: FPDF_RenderPageBitmapWithMatrix
  /// Render contents of a page to a device independent bitmap.
  /// Parameters:
  /// bitmap      -   Handle to the device independent bitmap (as the
  /// output buffer). The bitmap handle can be created
  /// by FPDFBitmap_Create or retrieved by
  /// FPDFImageObj_GetBitmap.
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// matrix      -   The transform matrix, which must be invertible.
  /// See PDF Reference 1.7, 4.2.2 Common Transformations.
  /// clipping    -   The rect to clip to in device coords.
  /// flags       -   0 for normal display, or combination of the Page
  /// Rendering flags defined above. With the FPDF_ANNOT
  /// flag, it renders all annotations that do not require
  /// user-interaction, which are all annotations except
  /// widget and popup annotations.
  /// Return value:
  /// None. Note that behavior is undefined if det of |matrix| is 0.
  void RenderPageBitmapWithMatrix(
    FPDF_BITMAP bitmap,
    FPDF_PAGE page,
    ffi.Pointer<FS_MATRIX> matrix,
    ffi.Pointer<FS_RECTF> clipping,
    int flags,
  ) {
    return _RenderPageBitmapWithMatrix(
      bitmap,
      page,
      matrix,
      clipping,
      flags,
    );
  }

  late final _RenderPageBitmapWithMatrixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              FPDF_BITMAP,
              FPDF_PAGE,
              ffi.Pointer<FS_MATRIX>,
              ffi.Pointer<FS_RECTF>,
              ffi.Int)>>('PDFIUM_FPDF_RenderPageBitmapWithMatrix');
  late final _RenderPageBitmapWithMatrix =
      _RenderPageBitmapWithMatrixPtr.asFunction<
          void Function(FPDF_BITMAP, FPDF_PAGE, ffi.Pointer<FS_MATRIX>,
              ffi.Pointer<FS_RECTF>, int)>();

  /// Function: FPDF_ClosePage
  /// Close a loaded PDF page.
  /// Parameters:
  /// page        -   Handle to the loaded page.
  /// Return value:
  /// None.
  void ClosePage(
    FPDF_PAGE page,
  ) {
    return _ClosePage(
      page,
    );
  }

  late final _ClosePagePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_PAGE)>>(
          'PDFIUM_FPDF_ClosePage');
  late final _ClosePage = _ClosePagePtr.asFunction<void Function(FPDF_PAGE)>();

  /// Function: FPDF_CloseDocument
  /// Close a loaded PDF document.
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// Return value:
  /// None.
  void CloseDocument(
    FPDF_DOCUMENT document,
  ) {
    return _CloseDocument(
      document,
    );
  }

  late final _CloseDocumentPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDF_CloseDocument');
  late final _CloseDocument =
      _CloseDocumentPtr.asFunction<void Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_DeviceToPage
  /// Convert the screen coordinates of a point to page coordinates.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// start_x     -   Left pixel position of the display area in
  /// device coordinates.
  /// start_y     -   Top pixel position of the display area in device
  /// coordinates.
  /// size_x      -   Horizontal size (in pixels) for displaying the page.
  /// size_y      -   Vertical size (in pixels) for displaying the page.
  /// rotate      -   Page orientation:
  /// 0 (normal)
  /// 1 (rotated 90 degrees clockwise)
  /// 2 (rotated 180 degrees)
  /// 3 (rotated 90 degrees counter-clockwise)
  /// device_x    -   X value in device coordinates to be converted.
  /// device_y    -   Y value in device coordinates to be converted.
  /// page_x      -   A pointer to a double receiving the converted X
  /// value in page coordinates.
  /// page_y      -   A pointer to a double receiving the converted Y
  /// value in page coordinates.
  /// Return value:
  /// Returns true if the conversion succeeds, and |page_x| and |page_y|
  /// successfully receives the converted coordinates.
  /// Comments:
  /// The page coordinate system has its origin at the left-bottom corner
  /// of the page, with the X-axis on the bottom going to the right, and
  /// the Y-axis on the left side going up.
  /// NOTE: this coordinate system can be altered when you zoom, scroll,
  /// or rotate a page, however, a point on the page should always have
  /// the same coordinate values in the page coordinate system.
  /// The device coordinate system is device dependent. For screen device,
  /// its origin is at the left-top corner of the window. However this
  /// origin can be altered by the Windows coordinate transformation
  /// utilities.
  /// You must make sure the start_x, start_y, size_x, size_y
  /// and rotate parameters have exactly same values as you used in
  /// the FPDF_RenderPage() function call.
  int DeviceToPage(
    FPDF_PAGE page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    int device_x,
    int device_y,
    ffi.Pointer<ffi.Double> page_x,
    ffi.Pointer<ffi.Double> page_y,
  ) {
    return _DeviceToPage(
      page,
      start_x,
      start_y,
      size_x,
      size_y,
      rotate,
      device_x,
      device_y,
      page_x,
      page_y,
    );
  }

  late final _DeviceToPagePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGE,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>)>>('PDFIUM_FPDF_DeviceToPage');
  late final _DeviceToPage = _DeviceToPagePtr.asFunction<
      int Function(FPDF_PAGE, int, int, int, int, int, int, int,
          ffi.Pointer<ffi.Double>, ffi.Pointer<ffi.Double>)>();

  /// Function: FPDF_PageToDevice
  /// Convert the page coordinates of a point to screen coordinates.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// start_x     -   Left pixel position of the display area in
  /// device coordinates.
  /// start_y     -   Top pixel position of the display area in device
  /// coordinates.
  /// size_x      -   Horizontal size (in pixels) for displaying the page.
  /// size_y      -   Vertical size (in pixels) for displaying the page.
  /// rotate      -   Page orientation:
  /// 0 (normal)
  /// 1 (rotated 90 degrees clockwise)
  /// 2 (rotated 180 degrees)
  /// 3 (rotated 90 degrees counter-clockwise)
  /// page_x      -   X value in page coordinates.
  /// page_y      -   Y value in page coordinate.
  /// device_x    -   A pointer to an integer receiving the result X
  /// value in device coordinates.
  /// device_y    -   A pointer to an integer receiving the result Y
  /// value in device coordinates.
  /// Return value:
  /// Returns true if the conversion succeeds, and |device_x| and
  /// |device_y| successfully receives the converted coordinates.
  /// Comments:
  /// See comments for FPDF_DeviceToPage().
  int PageToDevice(
    FPDF_PAGE page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    double page_x,
    double page_y,
    ffi.Pointer<ffi.Int> device_x,
    ffi.Pointer<ffi.Int> device_y,
  ) {
    return _PageToDevice(
      page,
      start_x,
      start_y,
      size_x,
      size_y,
      rotate,
      page_x,
      page_y,
      device_x,
      device_y,
    );
  }

  late final _PageToDevicePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGE,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Double,
              ffi.Double,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('PDFIUM_FPDF_PageToDevice');
  late final _PageToDevice = _PageToDevicePtr.asFunction<
      int Function(FPDF_PAGE, int, int, int, int, int, double, double,
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Function: FPDFBitmap_Create
  /// Create a device independent bitmap (FXDIB).
  /// Parameters:
  /// width       -   The number of pixels in width for the bitmap.
  /// Must be greater than 0.
  /// height      -   The number of pixels in height for the bitmap.
  /// Must be greater than 0.
  /// alpha       -   A flag indicating whether the alpha channel is used.
  /// Non-zero for using alpha, zero for not using.
  /// Return value:
  /// The created bitmap handle, or NULL if a parameter error or out of
  /// memory.
  /// Comments:
  /// The bitmap always uses 4 bytes per pixel. The first byte is always
  /// double word aligned.
  /// The byte order is BGRx (the last byte unused if no alpha channel) or
  /// BGRA.
  /// The pixels in a horizontal line are stored side by side, with the
  /// left most pixel stored first (with lower memory address).
  /// Each line uses width * 4 bytes.
  /// Lines are stored one after another, with the top most line stored
  /// first. There is no gap between adjacent lines.
  /// This function allocates enough memory for holding all pixels in the
  /// bitmap, but it doesn't initialize the buffer. Applications can use
  /// FPDFBitmap_FillRect() to fill the bitmap using any color. If the OS
  /// allows it, this function can allocate up to 4 GB of memory.
  FPDF_BITMAP Bitmap_Create(
    int width,
    int height,
    int alpha,
  ) {
    return _Bitmap_Create(
      width,
      height,
      alpha,
    );
  }

  late final _Bitmap_CreatePtr = _lookup<
          ffi.NativeFunction<FPDF_BITMAP Function(ffi.Int, ffi.Int, ffi.Int)>>(
      'PDFIUM_FPDFBitmap_Create');
  late final _Bitmap_Create =
      _Bitmap_CreatePtr.asFunction<FPDF_BITMAP Function(int, int, int)>();

  /// Function: FPDFBitmap_CreateEx
  /// Create a device independent bitmap (FXDIB)
  /// Parameters:
  /// width       -   The number of pixels in width for the bitmap.
  /// Must be greater than 0.
  /// height      -   The number of pixels in height for the bitmap.
  /// Must be greater than 0.
  /// format      -   A number indicating for bitmap format, as defined
  /// above.
  /// first_scan  -   A pointer to the first byte of the first line if
  /// using an external buffer. If this parameter is NULL,
  /// then a new buffer will be created.
  /// stride      -   Number of bytes for each scan line. The value must
  /// be 0 or greater. When the value is 0,
  /// FPDFBitmap_CreateEx() will automatically calculate
  /// the appropriate value using |width| and |format|.
  /// When using an external buffer, it is recommended for
  /// the caller to pass in the value.
  /// When not using an external buffer, it is recommended
  /// for the caller to pass in 0.
  /// Return value:
  /// The bitmap handle, or NULL if parameter error or out of memory.
  /// Comments:
  /// Similar to FPDFBitmap_Create function, but allows for more formats
  /// and an external buffer is supported. The bitmap created by this
  /// function can be used in any place that a FPDF_BITMAP handle is
  /// required.
  /// If an external buffer is used, then the caller should destroy the
  /// buffer. FPDFBitmap_Destroy() will not destroy the buffer.
  /// It is recommended to use FPDFBitmap_GetStride() to get the stride
  /// value.
  FPDF_BITMAP Bitmap_CreateEx(
    int width,
    int height,
    int format,
    ffi.Pointer<ffi.Void> first_scan,
    int stride,
  ) {
    return _Bitmap_CreateEx(
      width,
      height,
      format,
      first_scan,
      stride,
    );
  }

  late final _Bitmap_CreateExPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BITMAP Function(ffi.Int, ffi.Int, ffi.Int, ffi.Pointer<ffi.Void>,
              ffi.Int)>>('PDFIUM_FPDFBitmap_CreateEx');
  late final _Bitmap_CreateEx = _Bitmap_CreateExPtr.asFunction<
      FPDF_BITMAP Function(int, int, int, ffi.Pointer<ffi.Void>, int)>();

  /// Function: FPDFBitmap_GetFormat
  /// Get the format of the bitmap.
  /// Parameters:
  /// bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create
  /// or FPDFImageObj_GetBitmap.
  /// Return value:
  /// The format of the bitmap.
  /// Comments:
  /// Only formats supported by FPDFBitmap_CreateEx are supported by this
  /// function; see the list of such formats above.
  int Bitmap_GetFormat(
    FPDF_BITMAP bitmap,
  ) {
    return _Bitmap_GetFormat(
      bitmap,
    );
  }

  late final _Bitmap_GetFormatPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_BITMAP)>>(
          'PDFIUM_FPDFBitmap_GetFormat');
  late final _Bitmap_GetFormat =
      _Bitmap_GetFormatPtr.asFunction<int Function(FPDF_BITMAP)>();

  /// Function: FPDFBitmap_FillRect
  /// Fill a rectangle in a bitmap.
  /// Parameters:
  /// bitmap      -   The handle to the bitmap. Returned by
  /// FPDFBitmap_Create.
  /// left        -   The left position. Starting from 0 at the
  /// left-most pixel.
  /// top         -   The top position. Starting from 0 at the
  /// top-most line.
  /// width       -   Width in pixels to be filled.
  /// height      -   Height in pixels to be filled.
  /// color       -   A 32-bit value specifing the color, in 8888 ARGB
  /// format.
  /// Return value:
  /// Returns whether the operation succeeded or not.
  /// Comments:
  /// This function sets the color and (optionally) alpha value in the
  /// specified region of the bitmap.
  /// NOTE: If the alpha channel is used, this function does NOT
  /// composite the background with the source color, instead the
  /// background will be replaced by the source color and the alpha.
  /// If the alpha channel is not used, the alpha parameter is ignored.
  int Bitmap_FillRect(
    FPDF_BITMAP bitmap,
    int left,
    int top,
    int width,
    int height,
    int color,
  ) {
    return _Bitmap_FillRect(
      bitmap,
      left,
      top,
      width,
      height,
      color,
    );
  }

  late final _Bitmap_FillRectPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_BITMAP, ffi.Int, ffi.Int, ffi.Int, ffi.Int,
              FPDF_DWORD)>>('PDFIUM_FPDFBitmap_FillRect');
  late final _Bitmap_FillRect = _Bitmap_FillRectPtr.asFunction<
      int Function(FPDF_BITMAP, int, int, int, int, int)>();

  /// Function: FPDFBitmap_GetBuffer
  /// Get data buffer of a bitmap.
  /// Parameters:
  /// bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create
  /// or FPDFImageObj_GetBitmap.
  /// Return value:
  /// The pointer to the first byte of the bitmap buffer.
  /// Comments:
  /// The stride may be more than width * number of bytes per pixel
  /// Applications can use this function to get the bitmap buffer pointer,
  /// then manipulate any color and/or alpha values for any pixels in the
  /// bitmap.
  /// Use FPDFBitmap_GetFormat() to find out the format of the data.
  ffi.Pointer<ffi.Void> Bitmap_GetBuffer(
    FPDF_BITMAP bitmap,
  ) {
    return _Bitmap_GetBuffer(
      bitmap,
    );
  }

  late final _Bitmap_GetBufferPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(FPDF_BITMAP)>>(
          'PDFIUM_FPDFBitmap_GetBuffer');
  late final _Bitmap_GetBuffer = _Bitmap_GetBufferPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(FPDF_BITMAP)>();

  /// Function: FPDFBitmap_GetWidth
  /// Get width of a bitmap.
  /// Parameters:
  /// bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create
  /// or FPDFImageObj_GetBitmap.
  /// Return value:
  /// The width of the bitmap in pixels.
  int Bitmap_GetWidth(
    FPDF_BITMAP bitmap,
  ) {
    return _Bitmap_GetWidth(
      bitmap,
    );
  }

  late final _Bitmap_GetWidthPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_BITMAP)>>(
          'PDFIUM_FPDFBitmap_GetWidth');
  late final _Bitmap_GetWidth =
      _Bitmap_GetWidthPtr.asFunction<int Function(FPDF_BITMAP)>();

  /// Function: FPDFBitmap_GetHeight
  /// Get height of a bitmap.
  /// Parameters:
  /// bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create
  /// or FPDFImageObj_GetBitmap.
  /// Return value:
  /// The height of the bitmap in pixels.
  int Bitmap_GetHeight(
    FPDF_BITMAP bitmap,
  ) {
    return _Bitmap_GetHeight(
      bitmap,
    );
  }

  late final _Bitmap_GetHeightPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_BITMAP)>>(
          'PDFIUM_FPDFBitmap_GetHeight');
  late final _Bitmap_GetHeight =
      _Bitmap_GetHeightPtr.asFunction<int Function(FPDF_BITMAP)>();

  /// Function: FPDFBitmap_GetStride
  /// Get number of bytes for each line in the bitmap buffer.
  /// Parameters:
  /// bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create
  /// or FPDFImageObj_GetBitmap.
  /// Return value:
  /// The number of bytes for each line in the bitmap buffer.
  /// Comments:
  /// The stride may be more than width * number of bytes per pixel.
  int Bitmap_GetStride(
    FPDF_BITMAP bitmap,
  ) {
    return _Bitmap_GetStride(
      bitmap,
    );
  }

  late final _Bitmap_GetStridePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_BITMAP)>>(
          'PDFIUM_FPDFBitmap_GetStride');
  late final _Bitmap_GetStride =
      _Bitmap_GetStridePtr.asFunction<int Function(FPDF_BITMAP)>();

  /// Function: FPDFBitmap_Destroy
  /// Destroy a bitmap and release all related buffers.
  /// Parameters:
  /// bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create
  /// or FPDFImageObj_GetBitmap.
  /// Return value:
  /// None.
  /// Comments:
  /// This function will not destroy any external buffers provided when
  /// the bitmap was created.
  void Bitmap_Destroy(
    FPDF_BITMAP bitmap,
  ) {
    return _Bitmap_Destroy(
      bitmap,
    );
  }

  late final _Bitmap_DestroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_BITMAP)>>(
          'PDFIUM_FPDFBitmap_Destroy');
  late final _Bitmap_Destroy =
      _Bitmap_DestroyPtr.asFunction<void Function(FPDF_BITMAP)>();

  /// Function: FPDF_VIEWERREF_GetPrintScaling
  /// Whether the PDF document prefers to be scaled or not.
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// Return value:
  /// None.
  int VIEWERREF_GetPrintScaling(
    FPDF_DOCUMENT document,
  ) {
    return _VIEWERREF_GetPrintScaling(
      document,
    );
  }

  late final _VIEWERREF_GetPrintScalingPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDF_VIEWERREF_GetPrintScaling');
  late final _VIEWERREF_GetPrintScaling =
      _VIEWERREF_GetPrintScalingPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_VIEWERREF_GetNumCopies
  /// Returns the number of copies to be printed.
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// Return value:
  /// The number of copies to be printed.
  int VIEWERREF_GetNumCopies(
    FPDF_DOCUMENT document,
  ) {
    return _VIEWERREF_GetNumCopies(
      document,
    );
  }

  late final _VIEWERREF_GetNumCopiesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDF_VIEWERREF_GetNumCopies');
  late final _VIEWERREF_GetNumCopies =
      _VIEWERREF_GetNumCopiesPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_VIEWERREF_GetPrintPageRange
  /// Page numbers to initialize print dialog box when file is printed.
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// Return value:
  /// The print page range to be used for printing.
  FPDF_PAGERANGE VIEWERREF_GetPrintPageRange(
    FPDF_DOCUMENT document,
  ) {
    return _VIEWERREF_GetPrintPageRange(
      document,
    );
  }

  late final _VIEWERREF_GetPrintPageRangePtr =
      _lookup<ffi.NativeFunction<FPDF_PAGERANGE Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDF_VIEWERREF_GetPrintPageRange');
  late final _VIEWERREF_GetPrintPageRange = _VIEWERREF_GetPrintPageRangePtr
      .asFunction<FPDF_PAGERANGE Function(FPDF_DOCUMENT)>();

  /// Experimental API.
  /// Function: FPDF_VIEWERREF_GetPrintPageRangeCount
  /// Returns the number of elements in a FPDF_PAGERANGE.
  /// Parameters:
  /// pagerange   -   Handle to the page range.
  /// Return value:
  /// The number of elements in the page range. Returns 0 on error.
  int VIEWERREF_GetPrintPageRangeCount(
    FPDF_PAGERANGE pagerange,
  ) {
    return _VIEWERREF_GetPrintPageRangeCount(
      pagerange,
    );
  }

  late final _VIEWERREF_GetPrintPageRangeCountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(FPDF_PAGERANGE)>>(
          'PDFIUM_FPDF_VIEWERREF_GetPrintPageRangeCount');
  late final _VIEWERREF_GetPrintPageRangeCount =
      _VIEWERREF_GetPrintPageRangeCountPtr.asFunction<
          int Function(FPDF_PAGERANGE)>();

  /// Experimental API.
  /// Function: FPDF_VIEWERREF_GetPrintPageRangeElement
  /// Returns an element from a FPDF_PAGERANGE.
  /// Parameters:
  /// pagerange   -   Handle to the page range.
  /// index       -   Index of the element.
  /// Return value:
  /// The value of the element in the page range at a given index.
  /// Returns -1 on error.
  int VIEWERREF_GetPrintPageRangeElement(
    FPDF_PAGERANGE pagerange,
    int index,
  ) {
    return _VIEWERREF_GetPrintPageRangeElement(
      pagerange,
      index,
    );
  }

  late final _VIEWERREF_GetPrintPageRangeElementPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGERANGE, ffi.Size)>>(
          'PDFIUM_FPDF_VIEWERREF_GetPrintPageRangeElement');
  late final _VIEWERREF_GetPrintPageRangeElement =
      _VIEWERREF_GetPrintPageRangeElementPtr.asFunction<
          int Function(FPDF_PAGERANGE, int)>();

  /// Function: FPDF_VIEWERREF_GetDuplex
  /// Returns the paper handling option to be used when printing from
  /// the print dialog.
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// Return value:
  /// The paper handling option to be used when printing.
  int VIEWERREF_GetDuplex(
    FPDF_DOCUMENT document,
  ) {
    return _VIEWERREF_GetDuplex(
      document,
    );
  }

  late final _VIEWERREF_GetDuplexPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDF_VIEWERREF_GetDuplex');
  late final _VIEWERREF_GetDuplex =
      _VIEWERREF_GetDuplexPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_VIEWERREF_GetName
  /// Gets the contents for a viewer ref, with a given key. The value must
  /// be of type "name".
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// key         -   Name of the key in the viewer pref dictionary,
  /// encoded in UTF-8.
  /// buffer      -   Caller-allocate buffer to receive the key, or NULL
  /// -   to query the required length.
  /// length      -   Length of the buffer.
  /// Return value:
  /// The number of bytes in the contents, including the NULL terminator.
  /// Thus if the return value is 0, then that indicates an error, such
  /// as when |document| is invalid. If |length| is less than the required
  /// length, or |buffer| is NULL, |buffer| will not be modified.
  int VIEWERREF_GetName(
    FPDF_DOCUMENT document,
    FPDF_BYTESTRING key,
    ffi.Pointer<ffi.Char> buffer,
    int length,
  ) {
    return _VIEWERREF_GetName(
      document,
      key,
      buffer,
      length,
    );
  }

  late final _VIEWERREF_GetNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_DOCUMENT,
              FPDF_BYTESTRING,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedLong)>>('PDFIUM_FPDF_VIEWERREF_GetName');
  late final _VIEWERREF_GetName = _VIEWERREF_GetNamePtr.asFunction<
      int Function(
          FPDF_DOCUMENT, FPDF_BYTESTRING, ffi.Pointer<ffi.Char>, int)>();

  /// Function: FPDF_CountNamedDests
  /// Get the count of named destinations in the PDF document.
  /// Parameters:
  /// document    -   Handle to a document
  /// Return value:
  /// The count of named destinations.
  int CountNamedDests(
    FPDF_DOCUMENT document,
  ) {
    return _CountNamedDests(
      document,
    );
  }

  late final _CountNamedDestsPtr =
      _lookup<ffi.NativeFunction<FPDF_DWORD Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDF_CountNamedDests');
  late final _CountNamedDests =
      _CountNamedDestsPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_GetNamedDestByName
  /// Get a the destination handle for the given name.
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// name        -   The name of a destination.
  /// Return value:
  /// The handle to the destination.
  FPDF_DEST GetNamedDestByName(
    FPDF_DOCUMENT document,
    FPDF_BYTESTRING name,
  ) {
    return _GetNamedDestByName(
      document,
      name,
    );
  }

  late final _GetNamedDestByNamePtr = _lookup<
          ffi
          .NativeFunction<FPDF_DEST Function(FPDF_DOCUMENT, FPDF_BYTESTRING)>>(
      'PDFIUM_FPDF_GetNamedDestByName');
  late final _GetNamedDestByName = _GetNamedDestByNamePtr.asFunction<
      FPDF_DEST Function(FPDF_DOCUMENT, FPDF_BYTESTRING)>();

  /// Function: FPDF_GetNamedDest
  /// Get the named destination by index.
  /// Parameters:
  /// document        -   Handle to a document
  /// index           -   The index of a named destination.
  /// buffer          -   The buffer to store the destination name,
  /// used as wchar_t*.
  /// buflen [in/out] -   Size of the buffer in bytes on input,
  /// length of the result in bytes on output
  /// or -1 if the buffer is too small.
  /// Return value:
  /// The destination handle for a given index, or NULL if there is no
  /// named destination corresponding to |index|.
  /// Comments:
  /// Call this function twice to get the name of the named destination:
  /// 1) First time pass in |buffer| as NULL and get buflen.
  /// 2) Second time pass in allocated |buffer| and buflen to retrieve
  /// |buffer|, which should be used as wchar_t*.
  /// If buflen is not sufficiently large, it will be set to -1 upon
  /// return.
  FPDF_DEST GetNamedDest(
    FPDF_DOCUMENT document,
    int index,
    ffi.Pointer<ffi.Void> buffer,
    ffi.Pointer<ffi.Long> buflen,
  ) {
    return _GetNamedDest(
      document,
      index,
      buffer,
      buflen,
    );
  }

  late final _GetNamedDestPtr = _lookup<
      ffi.NativeFunction<
          FPDF_DEST Function(FPDF_DOCUMENT, ffi.Int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Long>)>>('PDFIUM_FPDF_GetNamedDest');
  late final _GetNamedDest = _GetNamedDestPtr.asFunction<
      FPDF_DEST Function(
          FPDF_DOCUMENT, int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Long>)>();

  /// Experimental API.
  /// Function: FPDF_GetXFAPacketCount
  /// Get the number of valid packets in the XFA entry.
  /// Parameters:
  /// document - Handle to the document.
  /// Return value:
  /// The number of valid packets, or -1 on error.
  int GetXFAPacketCount(
    FPDF_DOCUMENT document,
  ) {
    return _GetXFAPacketCount(
      document,
    );
  }

  late final _GetXFAPacketCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDF_GetXFAPacketCount');
  late final _GetXFAPacketCount =
      _GetXFAPacketCountPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Experimental API.
  /// Function: FPDF_GetXFAPacketName
  /// Get the name of a packet in the XFA array.
  /// Parameters:
  /// document - Handle to the document.
  /// index    - Index number of the packet. 0 for the first packet.
  /// buffer   - Buffer for holding the name of the XFA packet.
  /// buflen   - Length of |buffer| in bytes.
  /// Return value:
  /// The length of the packet name in bytes, or 0 on error.
  /// |document| must be valid and |index| must be in the range [0, N), where N is
  /// the value returned by FPDF_GetXFAPacketCount().
  /// |buffer| is only modified if it is non-NULL and |buflen| is greater than or
  /// equal to the length of the packet name. The packet name includes a
  /// terminating NUL character. |buffer| is unmodified on error.
  int GetXFAPacketName(
    FPDF_DOCUMENT document,
    int index,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _GetXFAPacketName(
      document,
      index,
      buffer,
      buflen,
    );
  }

  late final _GetXFAPacketNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_DOCUMENT,
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDF_GetXFAPacketName');
  late final _GetXFAPacketName = _GetXFAPacketNamePtr.asFunction<
      int Function(FPDF_DOCUMENT, int, ffi.Pointer<ffi.Void>, int)>();

  /// Experimental API.
  /// Function: FPDF_GetXFAPacketContent
  /// Get the content of a packet in the XFA array.
  /// Parameters:
  /// document   - Handle to the document.
  /// index      - Index number of the packet. 0 for the first packet.
  /// buffer     - Buffer for holding the content of the XFA packet.
  /// buflen     - Length of |buffer| in bytes.
  /// out_buflen - Pointer to the variable that will receive the minimum
  /// buffer size needed to contain the content of the XFA
  /// packet.
  /// Return value:
  /// Whether the operation succeeded or not.
  /// |document| must be valid and |index| must be in the range [0, N), where N is
  /// the value returned by FPDF_GetXFAPacketCount(). |out_buflen| must not be
  /// NULL. When the aforementioned arguments are valid, the operation succeeds,
  /// and |out_buflen| receives the content size. |buffer| is only modified if
  /// |buffer| is non-null and long enough to contain the content. Callers must
  /// check both the return value and the input |buflen| is no less than the
  /// returned |out_buflen| before using the data in |buffer|.
  int GetXFAPacketContent(
    FPDF_DOCUMENT document,
    int index,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
    ffi.Pointer<ffi.UnsignedLong> out_buflen,
  ) {
    return _GetXFAPacketContent(
      document,
      index,
      buffer,
      buflen,
      out_buflen,
    );
  }

  late final _GetXFAPacketContentPtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(FPDF_DOCUMENT, ffi.Int, ffi.Pointer<ffi.Void>,
                  ffi.UnsignedLong, ffi.Pointer<ffi.UnsignedLong>)>>(
      'PDFIUM_FPDF_GetXFAPacketContent');
  late final _GetXFAPacketContent = _GetXFAPacketContentPtr.asFunction<
      int Function(FPDF_DOCUMENT, int, ffi.Pointer<ffi.Void>, int,
          ffi.Pointer<ffi.UnsignedLong>)>();

  /// Experimental API.
  /// Determine if |document| represents a tagged PDF.
  /// For the definition of tagged PDF, See (see 10.7 "Tagged PDF" in PDF
  /// Reference 1.7).
  /// document - handle to a document.
  /// Returns |true| iff |document| is a tagged PDF.
  int Catalog_IsTagged(
    FPDF_DOCUMENT document,
  ) {
    return _Catalog_IsTagged(
      document,
    );
  }

  late final _Catalog_IsTaggedPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDFCatalog_IsTagged');
  late final _Catalog_IsTagged =
      _Catalog_IsTaggedPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Experimental API.
  /// Sets the language of |document| to |language|.
  /// document - handle to a document.
  /// language - the language to set to.
  /// Returns TRUE on success.
  int Catalog_SetLanguage(
    FPDF_DOCUMENT document,
    FPDF_BYTESTRING language,
  ) {
    return _Catalog_SetLanguage(
      document,
      language,
    );
  }

  late final _Catalog_SetLanguagePtr = _lookup<
          ffi
          .NativeFunction<FPDF_BOOL Function(FPDF_DOCUMENT, FPDF_BYTESTRING)>>(
      'PDFIUM_FPDFCatalog_SetLanguage');
  late final _Catalog_SetLanguage = _Catalog_SetLanguagePtr.asFunction<
      int Function(FPDF_DOCUMENT, FPDF_BYTESTRING)>();

  /// Create a new PDF document.
  /// Returns a handle to a new document, or NULL on failure.
  FPDF_DOCUMENT CreateNewDocument() {
    return _CreateNewDocument();
  }

  late final _CreateNewDocumentPtr =
      _lookup<ffi.NativeFunction<FPDF_DOCUMENT Function()>>(
          'PDFIUM_FPDF_CreateNewDocument');
  late final _CreateNewDocument =
      _CreateNewDocumentPtr.asFunction<FPDF_DOCUMENT Function()>();

  /// Create a new PDF page.
  /// document   - handle to document.
  /// page_index - suggested 0-based index of the page to create. If it is larger
  /// than document's current last index(L), the created page index
  /// is the next available index -- L+1.
  /// width      - the page width in points.
  /// height     - the page height in points.
  /// Returns the handle to the new page or NULL on failure.
  /// The page should be closed with FPDF_ClosePage() when finished as
  /// with any other page in the document.
  FPDF_PAGE Page_New(
    FPDF_DOCUMENT document,
    int page_index,
    double width,
    double height,
  ) {
    return _Page_New(
      document,
      page_index,
      width,
      height,
    );
  }

  late final _Page_NewPtr = _lookup<
      ffi.NativeFunction<
          FPDF_PAGE Function(FPDF_DOCUMENT, ffi.Int, ffi.Double,
              ffi.Double)>>('PDFIUM_FPDFPage_New');
  late final _Page_New = _Page_NewPtr.asFunction<
      FPDF_PAGE Function(FPDF_DOCUMENT, int, double, double)>();

  /// Delete the page at |page_index|.
  /// document   - handle to document.
  /// page_index - the index of the page to delete.
  void Page_Delete(
    FPDF_DOCUMENT document,
    int page_index,
  ) {
    return _Page_Delete(
      document,
      page_index,
    );
  }

  late final _Page_DeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_DOCUMENT, ffi.Int)>>(
          'PDFIUM_FPDFPage_Delete');
  late final _Page_Delete =
      _Page_DeletePtr.asFunction<void Function(FPDF_DOCUMENT, int)>();

  /// Experimental API.
  /// Move the given pages to a new index position.
  /// page_indices     - the ordered list of pages to move. No duplicates allowed.
  /// page_indices_len - the number of elements in |page_indices|
  /// dest_page_index  - the new index position to which the pages in
  /// |page_indices| are moved.
  /// Returns TRUE on success. If it returns FALSE, the document may be left in an
  /// indeterminate state.
  /// Example: The PDF document starts out with pages [A, B, C, D], with indices
  /// [0, 1, 2, 3].
  /// >  Move(doc, [3, 2], 2, 1); // returns true
  /// >  // The document has pages [A, D, C, B].
  /// >
  /// >  Move(doc, [0, 4, 3], 3, 1); // returns false
  /// >  // Returned false because index 4 is out of range.
  /// >
  /// >  Move(doc, [0, 3, 1], 3, 2); // returns false
  /// >  // Returned false because index 2 is out of range for 3 page indices.
  /// >
  /// >  Move(doc, [2, 2], 2, 0); // returns false
  /// >  // Returned false because [2, 2] contains duplicates.
  int MovePages(
    FPDF_DOCUMENT document,
    ffi.Pointer<ffi.Int> page_indices,
    int page_indices_len,
    int dest_page_index,
  ) {
    return _MovePages(
      document,
      page_indices,
      page_indices_len,
      dest_page_index,
    );
  }

  late final _MovePagesPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_DOCUMENT, ffi.Pointer<ffi.Int>,
              ffi.UnsignedLong, ffi.Int)>>('PDFIUM_FPDF_MovePages');
  late final _MovePages = _MovePagesPtr.asFunction<
      int Function(FPDF_DOCUMENT, ffi.Pointer<ffi.Int>, int, int)>();

  /// Get the rotation of |page|.
  /// page - handle to a page
  /// Returns one of the following indicating the page rotation:
  /// 0 - No rotation.
  /// 1 - Rotated 90 degrees clockwise.
  /// 2 - Rotated 180 degrees clockwise.
  /// 3 - Rotated 270 degrees clockwise.
  int Page_GetRotation(
    FPDF_PAGE page,
  ) {
    return _Page_GetRotation(
      page,
    );
  }

  late final _Page_GetRotationPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGE)>>(
          'PDFIUM_FPDFPage_GetRotation');
  late final _Page_GetRotation =
      _Page_GetRotationPtr.asFunction<int Function(FPDF_PAGE)>();

  /// Set rotation for |page|.
  /// page   - handle to a page.
  /// rotate - the rotation value, one of:
  /// 0 - No rotation.
  /// 1 - Rotated 90 degrees clockwise.
  /// 2 - Rotated 180 degrees clockwise.
  /// 3 - Rotated 270 degrees clockwise.
  void Page_SetRotation(
    FPDF_PAGE page,
    int rotate,
  ) {
    return _Page_SetRotation(
      page,
      rotate,
    );
  }

  late final _Page_SetRotationPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_PAGE, ffi.Int)>>(
          'PDFIUM_FPDFPage_SetRotation');
  late final _Page_SetRotation =
      _Page_SetRotationPtr.asFunction<void Function(FPDF_PAGE, int)>();

  /// Insert |page_object| into |page|.
  /// page        - handle to a page
  /// page_object - handle to a page object. The |page_object| will be
  /// automatically freed.
  void Page_InsertObject(
    FPDF_PAGE page,
    FPDF_PAGEOBJECT page_object,
  ) {
    return _Page_InsertObject(
      page,
      page_object,
    );
  }

  late final _Page_InsertObjectPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(FPDF_PAGE, FPDF_PAGEOBJECT)>>(
      'PDFIUM_FPDFPage_InsertObject');
  late final _Page_InsertObject = _Page_InsertObjectPtr.asFunction<
      void Function(FPDF_PAGE, FPDF_PAGEOBJECT)>();

  /// Insert |page_object| into |page| at the specified |index|.
  /// page        - handle to a page
  /// page_object - handle to a page object as previously obtained by
  /// FPDFPageObj_CreateNew{Path|Rect}() or
  /// FPDFPageObj_New{Text|Image}Obj(). Ownership of the object
  /// is transferred back to PDFium.
  /// index       - the index position to insert the object at. If index equals
  /// the current object count, the object will be appended to the
  /// end. If index is greater than the object count, the function
  /// will fail and return false.
  /// Returns true if successful.
  int Page_InsertObjectAtIndex(
    FPDF_PAGE page,
    FPDF_PAGEOBJECT page_object,
    int index,
  ) {
    return _Page_InsertObjectAtIndex(
      page,
      page_object,
      index,
    );
  }

  late final _Page_InsertObjectAtIndexPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGE, FPDF_PAGEOBJECT,
              ffi.Size)>>('PDFIUM_FPDFPage_InsertObjectAtIndex');
  late final _Page_InsertObjectAtIndex = _Page_InsertObjectAtIndexPtr
      .asFunction<int Function(FPDF_PAGE, FPDF_PAGEOBJECT, int)>();

  /// Experimental API.
  /// Remove |page_object| from |page|.
  /// page        - handle to a page
  /// page_object - handle to a page object to be removed.
  /// Returns TRUE on success.
  /// Ownership is transferred to the caller. Call FPDFPageObj_Destroy() to free
  /// it.
  /// Note that when removing a |page_object| of type FPDF_PAGEOBJ_TEXT, all
  /// FPDF_TEXTPAGE handles for |page| are no longer valid.
  int Page_RemoveObject(
    FPDF_PAGE page,
    FPDF_PAGEOBJECT page_object,
  ) {
    return _Page_RemoveObject(
      page,
      page_object,
    );
  }

  late final _Page_RemoveObjectPtr = _lookup<
          ffi.NativeFunction<FPDF_BOOL Function(FPDF_PAGE, FPDF_PAGEOBJECT)>>(
      'PDFIUM_FPDFPage_RemoveObject');
  late final _Page_RemoveObject = _Page_RemoveObjectPtr.asFunction<
      int Function(FPDF_PAGE, FPDF_PAGEOBJECT)>();

  /// Get number of page objects inside |page|.
  /// page - handle to a page.
  /// Returns the number of objects in |page|.
  int Page_CountObjects(
    FPDF_PAGE page,
  ) {
    return _Page_CountObjects(
      page,
    );
  }

  late final _Page_CountObjectsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGE)>>(
          'PDFIUM_FPDFPage_CountObjects');
  late final _Page_CountObjects =
      _Page_CountObjectsPtr.asFunction<int Function(FPDF_PAGE)>();

  /// Get object in |page| at |index|.
  /// page  - handle to a page.
  /// index - the index of a page object.
  /// Returns the handle to the page object, or NULL on failed.
  FPDF_PAGEOBJECT Page_GetObject(
    FPDF_PAGE page,
    int index,
  ) {
    return _Page_GetObject(
      page,
      index,
    );
  }

  late final _Page_GetObjectPtr =
      _lookup<ffi.NativeFunction<FPDF_PAGEOBJECT Function(FPDF_PAGE, ffi.Int)>>(
          'PDFIUM_FPDFPage_GetObject');
  late final _Page_GetObject =
      _Page_GetObjectPtr.asFunction<FPDF_PAGEOBJECT Function(FPDF_PAGE, int)>();

  /// Checks if |page| contains transparency.
  /// page - handle to a page.
  /// Returns TRUE if |page| contains transparency.
  int Page_HasTransparency(
    FPDF_PAGE page,
  ) {
    return _Page_HasTransparency(
      page,
    );
  }

  late final _Page_HasTransparencyPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_PAGE)>>(
          'PDFIUM_FPDFPage_HasTransparency');
  late final _Page_HasTransparency =
      _Page_HasTransparencyPtr.asFunction<int Function(FPDF_PAGE)>();

  /// Generate the content of |page|.
  /// page - handle to a page.
  /// Returns TRUE on success.
  /// Before you save the page to a file, or reload the page, you must call
  /// |FPDFPage_GenerateContent| or any changes to |page| will be lost.
  int Page_GenerateContent(
    FPDF_PAGE page,
  ) {
    return _Page_GenerateContent(
      page,
    );
  }

  late final _Page_GenerateContentPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_PAGE)>>(
          'PDFIUM_FPDFPage_GenerateContent');
  late final _Page_GenerateContent =
      _Page_GenerateContentPtr.asFunction<int Function(FPDF_PAGE)>();

  /// Destroy |page_object| by releasing its resources. |page_object| must have
  /// been created by FPDFPageObj_CreateNew{Path|Rect}() or
  /// FPDFPageObj_New{Text|Image}Obj(). This function must be called on
  /// newly-created objects if they are not added to a page through
  /// FPDFPage_InsertObject() or to an annotation through FPDFAnnot_AppendObject().
  /// page_object - handle to a page object.
  void PageObj_Destroy(
    FPDF_PAGEOBJECT page_object,
  ) {
    return _PageObj_Destroy(
      page_object,
    );
  }

  late final _PageObj_DestroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_PAGEOBJECT)>>(
          'PDFIUM_FPDFPageObj_Destroy');
  late final _PageObj_Destroy =
      _PageObj_DestroyPtr.asFunction<void Function(FPDF_PAGEOBJECT)>();

  /// Checks if |page_object| contains transparency.
  /// page_object - handle to a page object.
  /// Returns TRUE if |page_object| contains transparency.
  int PageObj_HasTransparency(
    FPDF_PAGEOBJECT page_object,
  ) {
    return _PageObj_HasTransparency(
      page_object,
    );
  }

  late final _PageObj_HasTransparencyPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_PAGEOBJECT)>>(
          'PDFIUM_FPDFPageObj_HasTransparency');
  late final _PageObj_HasTransparency =
      _PageObj_HasTransparencyPtr.asFunction<int Function(FPDF_PAGEOBJECT)>();

  /// Get type of |page_object|.
  /// page_object - handle to a page object.
  /// Returns one of the FPDF_PAGEOBJ_* values on success, FPDF_PAGEOBJ_UNKNOWN on
  /// error.
  int PageObj_GetType(
    FPDF_PAGEOBJECT page_object,
  ) {
    return _PageObj_GetType(
      page_object,
    );
  }

  late final _PageObj_GetTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGEOBJECT)>>(
          'PDFIUM_FPDFPageObj_GetType');
  late final _PageObj_GetType =
      _PageObj_GetTypePtr.asFunction<int Function(FPDF_PAGEOBJECT)>();

  /// Experimental API.
  /// Gets active state for |page_object| within page.
  /// page_object - handle to a page object.
  /// active      - pointer to variable that will receive if the page object is
  /// active. This is a required parameter. Not filled if FALSE
  /// is returned.
  /// For page objects where |active| is filled with FALSE, the |page_object| is
  /// treated as if it wasn't in the document even though it is still held
  /// internally.
  /// Returns TRUE if the operation succeeded, FALSE if it failed.
  int PageObj_GetIsActive(
    FPDF_PAGEOBJECT page_object,
    ffi.Pointer<FPDF_BOOL> active,
  ) {
    return _PageObj_GetIsActive(
      page_object,
      active,
    );
  }

  late final _PageObj_GetIsActivePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGEOBJECT,
              ffi.Pointer<FPDF_BOOL>)>>('PDFIUM_FPDFPageObj_GetIsActive');
  late final _PageObj_GetIsActive = _PageObj_GetIsActivePtr.asFunction<
      int Function(FPDF_PAGEOBJECT, ffi.Pointer<FPDF_BOOL>)>();

  /// Experimental API.
  /// Sets if |page_object| is active within page.
  /// page_object - handle to a page object.
  /// active      - a boolean specifying if the object is active.
  /// Returns TRUE on success.
  /// Page objects all start in the active state by default, and remain in that
  /// state unless this function is called.
  /// When |active| is false, this makes the |page_object| be treated as if it
  /// wasn't in the document even though it is still held internally.
  int PageObj_SetIsActive(
    FPDF_PAGEOBJECT page_object,
    int active,
  ) {
    return _PageObj_SetIsActive(
      page_object,
      active,
    );
  }

  late final _PageObj_SetIsActivePtr = _lookup<
          ffi.NativeFunction<FPDF_BOOL Function(FPDF_PAGEOBJECT, FPDF_BOOL)>>(
      'PDFIUM_FPDFPageObj_SetIsActive');
  late final _PageObj_SetIsActive =
      _PageObj_SetIsActivePtr.asFunction<int Function(FPDF_PAGEOBJECT, int)>();

  /// Transform |page_object| by the given matrix.
  /// page_object - handle to a page object.
  /// a           - matrix value.
  /// b           - matrix value.
  /// c           - matrix value.
  /// d           - matrix value.
  /// e           - matrix value.
  /// f           - matrix value.
  /// The matrix is composed as:
  /// |a c e|
  /// |b d f|
  /// and can be used to scale, rotate, shear and translate the |page_object|.
  void PageObj_Transform(
    FPDF_PAGEOBJECT page_object,
    double a,
    double b,
    double c,
    double d,
    double e,
    double f,
  ) {
    return _PageObj_Transform(
      page_object,
      a,
      b,
      c,
      d,
      e,
      f,
    );
  }

  late final _PageObj_TransformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              FPDF_PAGEOBJECT,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Double)>>('PDFIUM_FPDFPageObj_Transform');
  late final _PageObj_Transform = _PageObj_TransformPtr.asFunction<
      void Function(
          FPDF_PAGEOBJECT, double, double, double, double, double, double)>();

  /// Experimental API.
  /// Transform |page_object| by the given matrix.
  /// page_object - handle to a page object.
  /// matrix      - the transform matrix.
  /// Returns TRUE on success.
  /// This can be used to scale, rotate, shear and translate the |page_object|.
  /// It is an improved version of FPDFPageObj_Transform() that does not do
  /// unnecessary double to float conversions, and only uses 1 parameter for the
  /// matrix. It also returns whether the operation succeeded or not.
  int PageObj_TransformF(
    FPDF_PAGEOBJECT page_object,
    ffi.Pointer<FS_MATRIX> matrix,
  ) {
    return _PageObj_TransformF(
      page_object,
      matrix,
    );
  }

  late final _PageObj_TransformFPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGEOBJECT,
              ffi.Pointer<FS_MATRIX>)>>('PDFIUM_FPDFPageObj_TransformF');
  late final _PageObj_TransformF = _PageObj_TransformFPtr.asFunction<
      int Function(FPDF_PAGEOBJECT, ffi.Pointer<FS_MATRIX>)>();

  /// Experimental API.
  /// Get the transform matrix of a page object.
  /// page_object - handle to a page object.
  /// matrix      - pointer to struct to receive the matrix value.
  /// The matrix is composed as:
  /// |a c e|
  /// |b d f|
  /// and used to scale, rotate, shear and translate the page object.
  /// For page objects outside form objects, the matrix values are relative to the
  /// page that contains it.
  /// For page objects inside form objects, the matrix values are relative to the
  /// form that contains it.
  /// Returns TRUE on success.
  int PageObj_GetMatrix(
    FPDF_PAGEOBJECT page_object,
    ffi.Pointer<FS_MATRIX> matrix,
  ) {
    return _PageObj_GetMatrix(
      page_object,
      matrix,
    );
  }

  late final _PageObj_GetMatrixPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGEOBJECT,
              ffi.Pointer<FS_MATRIX>)>>('PDFIUM_FPDFPageObj_GetMatrix');
  late final _PageObj_GetMatrix = _PageObj_GetMatrixPtr.asFunction<
      int Function(FPDF_PAGEOBJECT, ffi.Pointer<FS_MATRIX>)>();

  /// Experimental API.
  /// Set the transform matrix of a page object.
  /// page_object - handle to a page object.
  /// matrix      - pointer to struct with the matrix value.
  /// The matrix is composed as:
  /// |a c e|
  /// |b d f|
  /// and can be used to scale, rotate, shear and translate the page object.
  /// Returns TRUE on success.
  int PageObj_SetMatrix(
    FPDF_PAGEOBJECT page_object,
    ffi.Pointer<FS_MATRIX> matrix,
  ) {
    return _PageObj_SetMatrix(
      page_object,
      matrix,
    );
  }

  late final _PageObj_SetMatrixPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGEOBJECT,
              ffi.Pointer<FS_MATRIX>)>>('PDFIUM_FPDFPageObj_SetMatrix');
  late final _PageObj_SetMatrix = _PageObj_SetMatrixPtr.asFunction<
      int Function(FPDF_PAGEOBJECT, ffi.Pointer<FS_MATRIX>)>();

  /// Transform all annotations in |page|.
  /// page - handle to a page.
  /// a    - matrix value.
  /// b    - matrix value.
  /// c    - matrix value.
  /// d    - matrix value.
  /// e    - matrix value.
  /// f    - matrix value.
  /// The matrix is composed as:
  /// |a c e|
  /// |b d f|
  /// and can be used to scale, rotate, shear and translate the |page| annotations.
  void Page_TransformAnnots(
    FPDF_PAGE page,
    double a,
    double b,
    double c,
    double d,
    double e,
    double f,
  ) {
    return _Page_TransformAnnots(
      page,
      a,
      b,
      c,
      d,
      e,
      f,
    );
  }

  late final _Page_TransformAnnotsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              FPDF_PAGE,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Double)>>('PDFIUM_FPDFPage_TransformAnnots');
  late final _Page_TransformAnnots = _Page_TransformAnnotsPtr.asFunction<
      void Function(
          FPDF_PAGE, double, double, double, double, double, double)>();

  /// Create a new image object.
  /// document - handle to a document.
  /// Returns a handle to a new image object.
  FPDF_PAGEOBJECT PageObj_NewImageObj(
    FPDF_DOCUMENT document,
  ) {
    return _PageObj_NewImageObj(
      document,
    );
  }

  late final _PageObj_NewImageObjPtr =
      _lookup<ffi.NativeFunction<FPDF_PAGEOBJECT Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDFPageObj_NewImageObj');
  late final _PageObj_NewImageObj = _PageObj_NewImageObjPtr.asFunction<
      FPDF_PAGEOBJECT Function(FPDF_DOCUMENT)>();

  /// Experimental API.
  /// Get the marked content ID for the object.
  /// page_object - handle to a page object.
  /// Returns the page object's marked content ID, or -1 on error.
  int PageObj_GetMarkedContentID(
    FPDF_PAGEOBJECT page_object,
  ) {
    return _PageObj_GetMarkedContentID(
      page_object,
    );
  }

  late final _PageObj_GetMarkedContentIDPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGEOBJECT)>>(
          'PDFIUM_FPDFPageObj_GetMarkedContentID');
  late final _PageObj_GetMarkedContentID = _PageObj_GetMarkedContentIDPtr
      .asFunction<int Function(FPDF_PAGEOBJECT)>();

  /// Experimental API.
  /// Get number of content marks in |page_object|.
  /// page_object - handle to a page object.
  /// Returns the number of content marks in |page_object|, or -1 in case of
  /// failure.
  int PageObj_CountMarks(
    FPDF_PAGEOBJECT page_object,
  ) {
    return _PageObj_CountMarks(
      page_object,
    );
  }

  late final _PageObj_CountMarksPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGEOBJECT)>>(
          'PDFIUM_FPDFPageObj_CountMarks');
  late final _PageObj_CountMarks =
      _PageObj_CountMarksPtr.asFunction<int Function(FPDF_PAGEOBJECT)>();

  /// Experimental API.
  /// Get content mark in |page_object| at |index|.
  /// page_object - handle to a page object.
  /// index       - the index of a page object.
  /// Returns the handle to the content mark, or NULL on failure. The handle is
  /// still owned by the library, and it should not be freed directly. It becomes
  /// invalid if the page object is destroyed, either directly or indirectly by
  /// unloading the page.
  FPDF_PAGEOBJECTMARK PageObj_GetMark(
    FPDF_PAGEOBJECT page_object,
    int index,
  ) {
    return _PageObj_GetMark(
      page_object,
      index,
    );
  }

  late final _PageObj_GetMarkPtr = _lookup<
      ffi.NativeFunction<
          FPDF_PAGEOBJECTMARK Function(FPDF_PAGEOBJECT,
              ffi.UnsignedLong)>>('PDFIUM_FPDFPageObj_GetMark');
  late final _PageObj_GetMark = _PageObj_GetMarkPtr.asFunction<
      FPDF_PAGEOBJECTMARK Function(FPDF_PAGEOBJECT, int)>();

  /// Experimental API.
  /// Add a new content mark to a |page_object|.
  /// page_object - handle to a page object.
  /// name        - the name (tag) of the mark.
  /// Returns the handle to the content mark, or NULL on failure. The handle is
  /// still owned by the library, and it should not be freed directly. It becomes
  /// invalid if the page object is destroyed, either directly or indirectly by
  /// unloading the page.
  FPDF_PAGEOBJECTMARK PageObj_AddMark(
    FPDF_PAGEOBJECT page_object,
    FPDF_BYTESTRING name,
  ) {
    return _PageObj_AddMark(
      page_object,
      name,
    );
  }

  late final _PageObj_AddMarkPtr = _lookup<
      ffi.NativeFunction<
          FPDF_PAGEOBJECTMARK Function(
              FPDF_PAGEOBJECT, FPDF_BYTESTRING)>>('PDFIUM_FPDFPageObj_AddMark');
  late final _PageObj_AddMark = _PageObj_AddMarkPtr.asFunction<
      FPDF_PAGEOBJECTMARK Function(FPDF_PAGEOBJECT, FPDF_BYTESTRING)>();

  /// Experimental API.
  /// Removes a content |mark| from a |page_object|.
  /// The mark handle will be invalid after the removal.
  /// page_object - handle to a page object.
  /// mark        - handle to a content mark in that object to remove.
  /// Returns TRUE if the operation succeeded, FALSE if it failed.
  int PageObj_RemoveMark(
    FPDF_PAGEOBJECT page_object,
    FPDF_PAGEOBJECTMARK mark,
  ) {
    return _PageObj_RemoveMark(
      page_object,
      mark,
    );
  }

  late final _PageObj_RemoveMarkPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGEOBJECT,
              FPDF_PAGEOBJECTMARK)>>('PDFIUM_FPDFPageObj_RemoveMark');
  late final _PageObj_RemoveMark = _PageObj_RemoveMarkPtr.asFunction<
      int Function(FPDF_PAGEOBJECT, FPDF_PAGEOBJECTMARK)>();

  /// Experimental API.
  /// Get the name of a content mark.
  /// mark       - handle to a content mark.
  /// buffer     - buffer for holding the returned name in UTF-16LE. This is only
  /// modified if |buflen| is large enough to store the name.
  /// Optional, pass null to just retrieve the size of the buffer
  /// needed.
  /// buflen     - length of the buffer in bytes.
  /// out_buflen - pointer to variable that will receive the minimum buffer size
  /// in bytes to contain the name. This is a required parameter.
  /// Not filled if FALSE is returned.
  /// Returns TRUE if the operation succeeded, FALSE if it failed.
  int PageObjMark_GetName(
    FPDF_PAGEOBJECTMARK mark,
    ffi.Pointer<FPDF_WCHAR> buffer,
    int buflen,
    ffi.Pointer<ffi.UnsignedLong> out_buflen,
  ) {
    return _PageObjMark_GetName(
      mark,
      buffer,
      buflen,
      out_buflen,
    );
  }

  late final _PageObjMark_GetNamePtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(FPDF_PAGEOBJECTMARK, ffi.Pointer<FPDF_WCHAR>,
                  ffi.UnsignedLong, ffi.Pointer<ffi.UnsignedLong>)>>(
      'PDFIUM_FPDFPageObjMark_GetName');
  late final _PageObjMark_GetName = _PageObjMark_GetNamePtr.asFunction<
      int Function(FPDF_PAGEOBJECTMARK, ffi.Pointer<FPDF_WCHAR>, int,
          ffi.Pointer<ffi.UnsignedLong>)>();

  /// Experimental API.
  /// Get the number of key/value pair parameters in |mark|.
  /// mark   - handle to a content mark.
  /// Returns the number of key/value pair parameters |mark|, or -1 in case of
  /// failure.
  int PageObjMark_CountParams(
    FPDF_PAGEOBJECTMARK mark,
  ) {
    return _PageObjMark_CountParams(
      mark,
    );
  }

  late final _PageObjMark_CountParamsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGEOBJECTMARK)>>(
          'PDFIUM_FPDFPageObjMark_CountParams');
  late final _PageObjMark_CountParams = _PageObjMark_CountParamsPtr.asFunction<
      int Function(FPDF_PAGEOBJECTMARK)>();

  /// Experimental API.
  /// Get the key of a property in a content mark.
  /// mark       - handle to a content mark.
  /// index      - index of the property.
  /// buffer     - buffer for holding the returned key in UTF-16LE. This is only
  /// modified if |buflen| is large enough to store the key.
  /// Optional, pass null to just retrieve the size of the buffer
  /// needed.
  /// buflen     - length of the buffer in bytes.
  /// out_buflen - pointer to variable that will receive the minimum buffer size
  /// in bytes to contain the name. This is a required parameter.
  /// Not filled if FALSE is returned.
  /// Returns TRUE if the operation was successful, FALSE otherwise.
  int PageObjMark_GetParamKey(
    FPDF_PAGEOBJECTMARK mark,
    int index,
    ffi.Pointer<FPDF_WCHAR> buffer,
    int buflen,
    ffi.Pointer<ffi.UnsignedLong> out_buflen,
  ) {
    return _PageObjMark_GetParamKey(
      mark,
      index,
      buffer,
      buflen,
      out_buflen,
    );
  }

  late final _PageObjMark_GetParamKeyPtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(
                  FPDF_PAGEOBJECTMARK,
                  ffi.UnsignedLong,
                  ffi.Pointer<FPDF_WCHAR>,
                  ffi.UnsignedLong,
                  ffi.Pointer<ffi.UnsignedLong>)>>(
      'PDFIUM_FPDFPageObjMark_GetParamKey');
  late final _PageObjMark_GetParamKey = _PageObjMark_GetParamKeyPtr.asFunction<
      int Function(FPDF_PAGEOBJECTMARK, int, ffi.Pointer<FPDF_WCHAR>, int,
          ffi.Pointer<ffi.UnsignedLong>)>();

  /// Experimental API.
  /// Get the type of the value of a property in a content mark by key.
  /// mark   - handle to a content mark.
  /// key    - string key of the property.
  /// Returns the type of the value, or FPDF_OBJECT_UNKNOWN in case of failure.
  int PageObjMark_GetParamValueType(
    FPDF_PAGEOBJECTMARK mark,
    FPDF_BYTESTRING key,
  ) {
    return _PageObjMark_GetParamValueType(
      mark,
      key,
    );
  }

  late final _PageObjMark_GetParamValueTypePtr = _lookup<
      ffi.NativeFunction<
          FPDF_OBJECT_TYPE Function(FPDF_PAGEOBJECTMARK,
              FPDF_BYTESTRING)>>('PDFIUM_FPDFPageObjMark_GetParamValueType');
  late final _PageObjMark_GetParamValueType = _PageObjMark_GetParamValueTypePtr
      .asFunction<int Function(FPDF_PAGEOBJECTMARK, FPDF_BYTESTRING)>();

  /// Experimental API.
  /// Get the value of a number property in a content mark by key as int.
  /// FPDFPageObjMark_GetParamValueType() should have returned FPDF_OBJECT_NUMBER
  /// for this property.
  /// mark      - handle to a content mark.
  /// key       - string key of the property.
  /// out_value - pointer to variable that will receive the value. Not filled if
  /// false is returned.
  /// Returns TRUE if the key maps to a number value, FALSE otherwise.
  int PageObjMark_GetParamIntValue(
    FPDF_PAGEOBJECTMARK mark,
    FPDF_BYTESTRING key,
    ffi.Pointer<ffi.Int> out_value,
  ) {
    return _PageObjMark_GetParamIntValue(
      mark,
      key,
      out_value,
    );
  }

  late final _PageObjMark_GetParamIntValuePtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(
                  FPDF_PAGEOBJECTMARK, FPDF_BYTESTRING, ffi.Pointer<ffi.Int>)>>(
      'PDFIUM_FPDFPageObjMark_GetParamIntValue');
  late final _PageObjMark_GetParamIntValue =
      _PageObjMark_GetParamIntValuePtr.asFunction<
          int Function(
              FPDF_PAGEOBJECTMARK, FPDF_BYTESTRING, ffi.Pointer<ffi.Int>)>();

  /// Experimental API.
  /// Get the value of a string property in a content mark by key.
  /// mark       - handle to a content mark.
  /// key        - string key of the property.
  /// buffer     - buffer for holding the returned value in UTF-16LE. This is
  /// only modified if |buflen| is large enough to store the value.
  /// Optional, pass null to just retrieve the size of the buffer
  /// needed.
  /// buflen     - length of the buffer in bytes.
  /// out_buflen - pointer to variable that will receive the minimum buffer size
  /// in bytes to contain the name. This is a required parameter.
  /// Not filled if FALSE is returned.
  /// Returns TRUE if the key maps to a string/blob value, FALSE otherwise.
  int PageObjMark_GetParamStringValue(
    FPDF_PAGEOBJECTMARK mark,
    FPDF_BYTESTRING key,
    ffi.Pointer<FPDF_WCHAR> buffer,
    int buflen,
    ffi.Pointer<ffi.UnsignedLong> out_buflen,
  ) {
    return _PageObjMark_GetParamStringValue(
      mark,
      key,
      buffer,
      buflen,
      out_buflen,
    );
  }

  late final _PageObjMark_GetParamStringValuePtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(
                  FPDF_PAGEOBJECTMARK,
                  FPDF_BYTESTRING,
                  ffi.Pointer<FPDF_WCHAR>,
                  ffi.UnsignedLong,
                  ffi.Pointer<ffi.UnsignedLong>)>>(
      'PDFIUM_FPDFPageObjMark_GetParamStringValue');
  late final _PageObjMark_GetParamStringValue =
      _PageObjMark_GetParamStringValuePtr.asFunction<
          int Function(FPDF_PAGEOBJECTMARK, FPDF_BYTESTRING,
              ffi.Pointer<FPDF_WCHAR>, int, ffi.Pointer<ffi.UnsignedLong>)>();

  /// Experimental API.
  /// Get the value of a blob property in a content mark by key.
  /// mark       - handle to a content mark.
  /// key        - string key of the property.
  /// buffer     - buffer for holding the returned value. This is only modified
  /// if |buflen| is large enough to store the value.
  /// Optional, pass null to just retrieve the size of the buffer
  /// needed.
  /// buflen     - length of the buffer in bytes.
  /// out_buflen - pointer to variable that will receive the minimum buffer size
  /// in bytes to contain the name. This is a required parameter.
  /// Not filled if FALSE is returned.
  /// Returns TRUE if the key maps to a string/blob value, FALSE otherwise.
  int PageObjMark_GetParamBlobValue(
    FPDF_PAGEOBJECTMARK mark,
    FPDF_BYTESTRING key,
    ffi.Pointer<ffi.UnsignedChar> buffer,
    int buflen,
    ffi.Pointer<ffi.UnsignedLong> out_buflen,
  ) {
    return _PageObjMark_GetParamBlobValue(
      mark,
      key,
      buffer,
      buflen,
      out_buflen,
    );
  }

  late final _PageObjMark_GetParamBlobValuePtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(
                  FPDF_PAGEOBJECTMARK,
                  FPDF_BYTESTRING,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.UnsignedLong,
                  ffi.Pointer<ffi.UnsignedLong>)>>(
      'PDFIUM_FPDFPageObjMark_GetParamBlobValue');
  late final _PageObjMark_GetParamBlobValue =
      _PageObjMark_GetParamBlobValuePtr.asFunction<
          int Function(
              FPDF_PAGEOBJECTMARK,
              FPDF_BYTESTRING,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              ffi.Pointer<ffi.UnsignedLong>)>();

  /// Experimental API.
  /// Set the value of an int property in a content mark by key. If a parameter
  /// with key |key| exists, its value is set to |value|. Otherwise, it is added as
  /// a new parameter.
  /// document    - handle to the document.
  /// page_object - handle to the page object with the mark.
  /// mark        - handle to a content mark.
  /// key         - string key of the property.
  /// value       - int value to set.
  /// Returns TRUE if the operation succeeded, FALSE otherwise.
  int PageObjMark_SetIntParam(
    FPDF_DOCUMENT document,
    FPDF_PAGEOBJECT page_object,
    FPDF_PAGEOBJECTMARK mark,
    FPDF_BYTESTRING key,
    int value,
  ) {
    return _PageObjMark_SetIntParam(
      document,
      page_object,
      mark,
      key,
      value,
    );
  }

  late final _PageObjMark_SetIntParamPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_DOCUMENT,
              FPDF_PAGEOBJECT,
              FPDF_PAGEOBJECTMARK,
              FPDF_BYTESTRING,
              ffi.Int)>>('PDFIUM_FPDFPageObjMark_SetIntParam');
  late final _PageObjMark_SetIntParam = _PageObjMark_SetIntParamPtr.asFunction<
      int Function(FPDF_DOCUMENT, FPDF_PAGEOBJECT, FPDF_PAGEOBJECTMARK,
          FPDF_BYTESTRING, int)>();

  /// Experimental API.
  /// Set the value of a string property in a content mark by key. If a parameter
  /// with key |key| exists, its value is set to |value|. Otherwise, it is added as
  /// a new parameter.
  /// document    - handle to the document.
  /// page_object - handle to the page object with the mark.
  /// mark        - handle to a content mark.
  /// key         - string key of the property.
  /// value       - string value to set.
  /// Returns TRUE if the operation succeeded, FALSE otherwise.
  int PageObjMark_SetStringParam(
    FPDF_DOCUMENT document,
    FPDF_PAGEOBJECT page_object,
    FPDF_PAGEOBJECTMARK mark,
    FPDF_BYTESTRING key,
    FPDF_BYTESTRING value,
  ) {
    return _PageObjMark_SetStringParam(
      document,
      page_object,
      mark,
      key,
      value,
    );
  }

  late final _PageObjMark_SetStringParamPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_DOCUMENT,
              FPDF_PAGEOBJECT,
              FPDF_PAGEOBJECTMARK,
              FPDF_BYTESTRING,
              FPDF_BYTESTRING)>>('PDFIUM_FPDFPageObjMark_SetStringParam');
  late final _PageObjMark_SetStringParam =
      _PageObjMark_SetStringParamPtr.asFunction<
          int Function(FPDF_DOCUMENT, FPDF_PAGEOBJECT, FPDF_PAGEOBJECTMARK,
              FPDF_BYTESTRING, FPDF_BYTESTRING)>();

  /// Experimental API.
  /// Set the value of a blob property in a content mark by key. If a parameter
  /// with key |key| exists, its value is set to |value|. Otherwise, it is added as
  /// a new parameter.
  /// document    - handle to the document.
  /// page_object - handle to the page object with the mark.
  /// mark        - handle to a content mark.
  /// key         - string key of the property.
  /// value       - pointer to blob value to set.
  /// value_len   - size in bytes of |value|.
  /// Returns TRUE if the operation succeeded, FALSE otherwise.
  int PageObjMark_SetBlobParam(
    FPDF_DOCUMENT document,
    FPDF_PAGEOBJECT page_object,
    FPDF_PAGEOBJECTMARK mark,
    FPDF_BYTESTRING key,
    ffi.Pointer<ffi.UnsignedChar> value,
    int value_len,
  ) {
    return _PageObjMark_SetBlobParam(
      document,
      page_object,
      mark,
      key,
      value,
      value_len,
    );
  }

  late final _PageObjMark_SetBlobParamPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_DOCUMENT,
              FPDF_PAGEOBJECT,
              FPDF_PAGEOBJECTMARK,
              FPDF_BYTESTRING,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFPageObjMark_SetBlobParam');
  late final _PageObjMark_SetBlobParam =
      _PageObjMark_SetBlobParamPtr.asFunction<
          int Function(FPDF_DOCUMENT, FPDF_PAGEOBJECT, FPDF_PAGEOBJECTMARK,
              FPDF_BYTESTRING, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Experimental API.
  /// Removes a property from a content mark by key.
  /// page_object - handle to the page object with the mark.
  /// mark        - handle to a content mark.
  /// key         - string key of the property.
  /// Returns TRUE if the operation succeeded, FALSE otherwise.
  int PageObjMark_RemoveParam(
    FPDF_PAGEOBJECT page_object,
    FPDF_PAGEOBJECTMARK mark,
    FPDF_BYTESTRING key,
  ) {
    return _PageObjMark_RemoveParam(
      page_object,
      mark,
      key,
    );
  }

  late final _PageObjMark_RemoveParamPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGEOBJECT, FPDF_PAGEOBJECTMARK,
              FPDF_BYTESTRING)>>('PDFIUM_FPDFPageObjMark_RemoveParam');
  late final _PageObjMark_RemoveParam = _PageObjMark_RemoveParamPtr.asFunction<
      int Function(FPDF_PAGEOBJECT, FPDF_PAGEOBJECTMARK, FPDF_BYTESTRING)>();

  /// Load an image from a JPEG image file and then set it into |image_object|.
  /// pages        - pointer to the start of all loaded pages, may be NULL.
  /// count        - number of |pages|, may be 0.
  /// image_object - handle to an image object.
  /// file_access  - file access handler which specifies the JPEG image file.
  /// Returns TRUE on success.
  /// The image object might already have an associated image, which is shared and
  /// cached by the loaded pages. In that case, we need to clear the cached image
  /// for all the loaded pages. Pass |pages| and page count (|count|) to this API
  /// to clear the image cache. If the image is not previously shared, or NULL is a
  /// valid |pages| value.
  int ImageObj_LoadJpegFile(
    ffi.Pointer<FPDF_PAGE> pages,
    int count,
    FPDF_PAGEOBJECT image_object,
    ffi.Pointer<FPDF_FILEACCESS> file_access,
  ) {
    return _ImageObj_LoadJpegFile(
      pages,
      count,
      image_object,
      file_access,
    );
  }

  late final _ImageObj_LoadJpegFilePtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(ffi.Pointer<FPDF_PAGE>, ffi.Int,
                  FPDF_PAGEOBJECT, ffi.Pointer<FPDF_FILEACCESS>)>>(
      'PDFIUM_FPDFImageObj_LoadJpegFile');
  late final _ImageObj_LoadJpegFile = _ImageObj_LoadJpegFilePtr.asFunction<
      int Function(ffi.Pointer<FPDF_PAGE>, int, FPDF_PAGEOBJECT,
          ffi.Pointer<FPDF_FILEACCESS>)>();

  /// Load an image from a JPEG image file and then set it into |image_object|.
  /// pages        - pointer to the start of all loaded pages, may be NULL.
  /// count        - number of |pages|, may be 0.
  /// image_object - handle to an image object.
  /// file_access  - file access handler which specifies the JPEG image file.
  /// Returns TRUE on success.
  /// The image object might already have an associated image, which is shared and
  /// cached by the loaded pages. In that case, we need to clear the cached image
  /// for all the loaded pages. Pass |pages| and page count (|count|) to this API
  /// to clear the image cache. If the image is not previously shared, or NULL is a
  /// valid |pages| value. This function loads the JPEG image inline, so the image
  /// content is copied to the file. This allows |file_access| and its associated
  /// data to be deleted after this function returns.
  int ImageObj_LoadJpegFileInline(
    ffi.Pointer<FPDF_PAGE> pages,
    int count,
    FPDF_PAGEOBJECT image_object,
    ffi.Pointer<FPDF_FILEACCESS> file_access,
  ) {
    return _ImageObj_LoadJpegFileInline(
      pages,
      count,
      image_object,
      file_access,
    );
  }

  late final _ImageObj_LoadJpegFileInlinePtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(ffi.Pointer<FPDF_PAGE>, ffi.Int,
                  FPDF_PAGEOBJECT, ffi.Pointer<FPDF_FILEACCESS>)>>(
      'PDFIUM_FPDFImageObj_LoadJpegFileInline');
  late final _ImageObj_LoadJpegFileInline =
      _ImageObj_LoadJpegFileInlinePtr.asFunction<
          int Function(ffi.Pointer<FPDF_PAGE>, int, FPDF_PAGEOBJECT,
              ffi.Pointer<FPDF_FILEACCESS>)>();

  /// TODO(thestig): Start deprecating this once FPDFPageObj_SetMatrix() is stable.
  /// Set the transform matrix of |image_object|.
  /// image_object - handle to an image object.
  /// a            - matrix value.
  /// b            - matrix value.
  /// c            - matrix value.
  /// d            - matrix value.
  /// e            - matrix value.
  /// f            - matrix value.
  /// The matrix is composed as:
  /// |a c e|
  /// |b d f|
  /// and can be used to scale, rotate, shear and translate the |image_object|.
  /// Returns TRUE on success.
  int ImageObj_SetMatrix(
    FPDF_PAGEOBJECT image_object,
    double a,
    double b,
    double c,
    double d,
    double e,
    double f,
  ) {
    return _ImageObj_SetMatrix(
      image_object,
      a,
      b,
      c,
      d,
      e,
      f,
    );
  }

  late final _ImageObj_SetMatrixPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGEOBJECT,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Double)>>('PDFIUM_FPDFImageObj_SetMatrix');
  late final _ImageObj_SetMatrix = _ImageObj_SetMatrixPtr.asFunction<
      int Function(
          FPDF_PAGEOBJECT, double, double, double, double, double, double)>();

  /// Set |bitmap| to |image_object|.
  /// pages        - pointer to the start of all loaded pages, may be NULL.
  /// count        - number of |pages|, may be 0.
  /// image_object - handle to an image object.
  /// bitmap       - handle of the bitmap.
  /// Returns TRUE on success.
  int ImageObj_SetBitmap(
    ffi.Pointer<FPDF_PAGE> pages,
    int count,
    FPDF_PAGEOBJECT image_object,
    FPDF_BITMAP bitmap,
  ) {
    return _ImageObj_SetBitmap(
      pages,
      count,
      image_object,
      bitmap,
    );
  }

  late final _ImageObj_SetBitmapPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(ffi.Pointer<FPDF_PAGE>, ffi.Int, FPDF_PAGEOBJECT,
              FPDF_BITMAP)>>('PDFIUM_FPDFImageObj_SetBitmap');
  late final _ImageObj_SetBitmap = _ImageObj_SetBitmapPtr.asFunction<
      int Function(
          ffi.Pointer<FPDF_PAGE>, int, FPDF_PAGEOBJECT, FPDF_BITMAP)>();

  /// Get a bitmap rasterization of |image_object|. FPDFImageObj_GetBitmap() only
  /// operates on |image_object| and does not take the associated image mask into
  /// account. It also ignores the matrix for |image_object|.
  /// The returned bitmap will be owned by the caller, and FPDFBitmap_Destroy()
  /// must be called on the returned bitmap when it is no longer needed.
  /// image_object - handle to an image object.
  /// Returns the bitmap.
  FPDF_BITMAP ImageObj_GetBitmap(
    FPDF_PAGEOBJECT image_object,
  ) {
    return _ImageObj_GetBitmap(
      image_object,
    );
  }

  late final _ImageObj_GetBitmapPtr =
      _lookup<ffi.NativeFunction<FPDF_BITMAP Function(FPDF_PAGEOBJECT)>>(
          'PDFIUM_FPDFImageObj_GetBitmap');
  late final _ImageObj_GetBitmap = _ImageObj_GetBitmapPtr.asFunction<
      FPDF_BITMAP Function(FPDF_PAGEOBJECT)>();

  /// Experimental API.
  /// Get a bitmap rasterization of |image_object| that takes the image mask and
  /// image matrix into account. To render correctly, the caller must provide the
  /// |document| associated with |image_object|. If there is a |page| associated
  /// with |image_object|, the caller should provide that as well.
  /// The returned bitmap will be owned by the caller, and FPDFBitmap_Destroy()
  /// must be called on the returned bitmap when it is no longer needed.
  /// document     - handle to a document associated with |image_object|.
  /// page         - handle to an optional page associated with |image_object|.
  /// image_object - handle to an image object.
  /// Returns the bitmap or NULL on failure.
  FPDF_BITMAP ImageObj_GetRenderedBitmap(
    FPDF_DOCUMENT document,
    FPDF_PAGE page,
    FPDF_PAGEOBJECT image_object,
  ) {
    return _ImageObj_GetRenderedBitmap(
      document,
      page,
      image_object,
    );
  }

  late final _ImageObj_GetRenderedBitmapPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BITMAP Function(FPDF_DOCUMENT, FPDF_PAGE,
              FPDF_PAGEOBJECT)>>('PDFIUM_FPDFImageObj_GetRenderedBitmap');
  late final _ImageObj_GetRenderedBitmap =
      _ImageObj_GetRenderedBitmapPtr.asFunction<
          FPDF_BITMAP Function(FPDF_DOCUMENT, FPDF_PAGE, FPDF_PAGEOBJECT)>();

  /// Get the decoded image data of |image_object|. The decoded data is the
  /// uncompressed image data, i.e. the raw image data after having all filters
  /// applied. |buffer| is only modified if |buflen| is longer than the length of
  /// the decoded image data.
  /// image_object - handle to an image object.
  /// buffer       - buffer for holding the decoded image data.
  /// buflen       - length of the buffer in bytes.
  /// Returns the length of the decoded image data.
  int ImageObj_GetImageDataDecoded(
    FPDF_PAGEOBJECT image_object,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _ImageObj_GetImageDataDecoded(
      image_object,
      buffer,
      buflen,
    );
  }

  late final _ImageObj_GetImageDataDecodedPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_PAGEOBJECT, ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFImageObj_GetImageDataDecoded');
  late final _ImageObj_GetImageDataDecoded = _ImageObj_GetImageDataDecodedPtr
      .asFunction<int Function(FPDF_PAGEOBJECT, ffi.Pointer<ffi.Void>, int)>();

  /// Get the raw image data of |image_object|. The raw data is the image data as
  /// stored in the PDF without applying any filters. |buffer| is only modified if
  /// |buflen| is longer than the length of the raw image data.
  /// image_object - handle to an image object.
  /// buffer       - buffer for holding the raw image data.
  /// buflen       - length of the buffer in bytes.
  /// Returns the length of the raw image data.
  int ImageObj_GetImageDataRaw(
    FPDF_PAGEOBJECT image_object,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _ImageObj_GetImageDataRaw(
      image_object,
      buffer,
      buflen,
    );
  }

  late final _ImageObj_GetImageDataRawPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_PAGEOBJECT, ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFImageObj_GetImageDataRaw');
  late final _ImageObj_GetImageDataRaw = _ImageObj_GetImageDataRawPtr
      .asFunction<int Function(FPDF_PAGEOBJECT, ffi.Pointer<ffi.Void>, int)>();

  /// Get the number of filters (i.e. decoders) of the image in |image_object|.
  /// image_object - handle to an image object.
  /// Returns the number of |image_object|'s filters.
  int ImageObj_GetImageFilterCount(
    FPDF_PAGEOBJECT image_object,
  ) {
    return _ImageObj_GetImageFilterCount(
      image_object,
    );
  }

  late final _ImageObj_GetImageFilterCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGEOBJECT)>>(
          'PDFIUM_FPDFImageObj_GetImageFilterCount');
  late final _ImageObj_GetImageFilterCount = _ImageObj_GetImageFilterCountPtr
      .asFunction<int Function(FPDF_PAGEOBJECT)>();

  /// Get the filter at |index| of |image_object|'s list of filters. Note that the
  /// filters need to be applied in order, i.e. the first filter should be applied
  /// first, then the second, etc. |buffer| is only modified if |buflen| is longer
  /// than the length of the filter string.
  /// image_object - handle to an image object.
  /// index        - the index of the filter requested.
  /// buffer       - buffer for holding filter string, encoded in UTF-8.
  /// buflen       - length of the buffer.
  /// Returns the length of the filter string.
  int ImageObj_GetImageFilter(
    FPDF_PAGEOBJECT image_object,
    int index,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _ImageObj_GetImageFilter(
      image_object,
      index,
      buffer,
      buflen,
    );
  }

  late final _ImageObj_GetImageFilterPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_PAGEOBJECT,
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFImageObj_GetImageFilter');
  late final _ImageObj_GetImageFilter = _ImageObj_GetImageFilterPtr.asFunction<
      int Function(FPDF_PAGEOBJECT, int, ffi.Pointer<ffi.Void>, int)>();

  /// Get the image metadata of |image_object|, including dimension, DPI, bits per
  /// pixel, and colorspace. If the |image_object| is not an image object or if it
  /// does not have an image, then the return value will be false. Otherwise,
  /// failure to retrieve any specific parameter would result in its value being 0.
  /// image_object - handle to an image object.
  /// page         - handle to the page that |image_object| is on. Required for
  /// retrieving the image's bits per pixel and colorspace.
  /// metadata     - receives the image metadata; must not be NULL.
  /// Returns true if successful.
  int ImageObj_GetImageMetadata(
    FPDF_PAGEOBJECT image_object,
    FPDF_PAGE page,
    ffi.Pointer<FPDF_IMAGEOBJ_METADATA> metadata,
  ) {
    return _ImageObj_GetImageMetadata(
      image_object,
      page,
      metadata,
    );
  }

  late final _ImageObj_GetImageMetadataPtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(FPDF_PAGEOBJECT, FPDF_PAGE,
                  ffi.Pointer<FPDF_IMAGEOBJ_METADATA>)>>(
      'PDFIUM_FPDFImageObj_GetImageMetadata');
  late final _ImageObj_GetImageMetadata =
      _ImageObj_GetImageMetadataPtr.asFunction<
          int Function(FPDF_PAGEOBJECT, FPDF_PAGE,
              ffi.Pointer<FPDF_IMAGEOBJ_METADATA>)>();

  /// Experimental API.
  /// Get the image size in pixels. Faster method to get only image size.
  /// image_object - handle to an image object.
  /// width        - receives the image width in pixels; must not be NULL.
  /// height       - receives the image height in pixels; must not be NULL.
  /// Returns true if successful.
  int ImageObj_GetImagePixelSize(
    FPDF_PAGEOBJECT image_object,
    ffi.Pointer<ffi.UnsignedInt> width,
    ffi.Pointer<ffi.UnsignedInt> height,
  ) {
    return _ImageObj_GetImagePixelSize(
      image_object,
      width,
      height,
    );
  }

  late final _ImageObj_GetImagePixelSizePtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(FPDF_PAGEOBJECT, ffi.Pointer<ffi.UnsignedInt>,
                  ffi.Pointer<ffi.UnsignedInt>)>>(
      'PDFIUM_FPDFImageObj_GetImagePixelSize');
  late final _ImageObj_GetImagePixelSize =
      _ImageObj_GetImagePixelSizePtr.asFunction<
          int Function(FPDF_PAGEOBJECT, ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>)>();

  /// Experimental API.
  /// Get ICC profile decoded data of |image_object|. If the |image_object| is not
  /// an image object or if it does not have an image, then the return value will
  /// be false. It also returns false if the |image_object| has no ICC profile.
  /// |buffer| is only modified if ICC profile exists and |buflen| is longer than
  /// the length of the ICC profile decoded data.
  /// image_object - handle to an image object; must not be NULL.
  /// page         - handle to the page containing |image_object|; must not be
  /// NULL. Required for retrieving the image's colorspace.
  /// buffer       - Buffer to receive ICC profile data; may be NULL if querying
  /// required size via |out_buflen|.
  /// buflen       - Length of the buffer in bytes. Ignored if |buffer| is NULL.
  /// out_buflen   - Pointer to receive the ICC profile data size in bytes; must
  /// not be NULL. Will be set if this API returns true.
  /// Returns true if |out_buflen| is not null and an ICC profile exists for the
  /// given |image_object|.
  int ImageObj_GetIccProfileDataDecoded(
    FPDF_PAGEOBJECT image_object,
    FPDF_PAGE page,
    ffi.Pointer<ffi.Uint8> buffer,
    int buflen,
    ffi.Pointer<ffi.Size> out_buflen,
  ) {
    return _ImageObj_GetIccProfileDataDecoded(
      image_object,
      page,
      buffer,
      buflen,
      out_buflen,
    );
  }

  late final _ImageObj_GetIccProfileDataDecodedPtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(FPDF_PAGEOBJECT, FPDF_PAGE,
                  ffi.Pointer<ffi.Uint8>, ffi.Size, ffi.Pointer<ffi.Size>)>>(
      'PDFIUM_FPDFImageObj_GetIccProfileDataDecoded');
  late final _ImageObj_GetIccProfileDataDecoded =
      _ImageObj_GetIccProfileDataDecodedPtr.asFunction<
          int Function(FPDF_PAGEOBJECT, FPDF_PAGE, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Size>)>();

  /// Create a new path object at an initial position.
  /// x - initial horizontal position.
  /// y - initial vertical position.
  /// Returns a handle to a new path object.
  FPDF_PAGEOBJECT PageObj_CreateNewPath(
    double x,
    double y,
  ) {
    return _PageObj_CreateNewPath(
      x,
      y,
    );
  }

  late final _PageObj_CreateNewPathPtr = _lookup<
          ffi.NativeFunction<FPDF_PAGEOBJECT Function(ffi.Float, ffi.Float)>>(
      'PDFIUM_FPDFPageObj_CreateNewPath');
  late final _PageObj_CreateNewPath = _PageObj_CreateNewPathPtr.asFunction<
      FPDF_PAGEOBJECT Function(double, double)>();

  /// Create a closed path consisting of a rectangle.
  /// x - horizontal position for the left boundary of the rectangle.
  /// y - vertical position for the bottom boundary of the rectangle.
  /// w - width of the rectangle.
  /// h - height of the rectangle.
  /// Returns a handle to the new path object.
  FPDF_PAGEOBJECT PageObj_CreateNewRect(
    double x,
    double y,
    double w,
    double h,
  ) {
    return _PageObj_CreateNewRect(
      x,
      y,
      w,
      h,
    );
  }

  late final _PageObj_CreateNewRectPtr = _lookup<
      ffi.NativeFunction<
          FPDF_PAGEOBJECT Function(ffi.Float, ffi.Float, ffi.Float,
              ffi.Float)>>('PDFIUM_FPDFPageObj_CreateNewRect');
  late final _PageObj_CreateNewRect = _PageObj_CreateNewRectPtr.asFunction<
      FPDF_PAGEOBJECT Function(double, double, double, double)>();

  /// Get the bounding box of |page_object|.
  /// page_object  - handle to a page object.
  /// left         - pointer where the left coordinate will be stored
  /// bottom       - pointer where the bottom coordinate will be stored
  /// right        - pointer where the right coordinate will be stored
  /// top          - pointer where the top coordinate will be stored
  /// On success, returns TRUE and fills in the 4 coordinates.
  int PageObj_GetBounds(
    FPDF_PAGEOBJECT page_object,
    ffi.Pointer<ffi.Float> left,
    ffi.Pointer<ffi.Float> bottom,
    ffi.Pointer<ffi.Float> right,
    ffi.Pointer<ffi.Float> top,
  ) {
    return _PageObj_GetBounds(
      page_object,
      left,
      bottom,
      right,
      top,
    );
  }

  late final _PageObj_GetBoundsPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGEOBJECT,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('PDFIUM_FPDFPageObj_GetBounds');
  late final _PageObj_GetBounds = _PageObj_GetBoundsPtr.asFunction<
      int Function(
          FPDF_PAGEOBJECT,
          ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>)>();

  /// Experimental API.
  /// Get the quad points that bounds |page_object|.
  /// page_object  - handle to a page object.
  /// quad_points  - pointer where the quadrilateral points will be stored.
  /// On success, returns TRUE and fills in |quad_points|.
  /// Similar to FPDFPageObj_GetBounds(), this returns the bounds of a page
  /// object. When the object is rotated by a non-multiple of 90 degrees, this API
  /// returns a tighter bound that cannot be represented with just the 4 sides of
  /// a rectangle.
  /// Currently only works the following |page_object| types: FPDF_PAGEOBJ_TEXT and
  /// FPDF_PAGEOBJ_IMAGE.
  int PageObj_GetRotatedBounds(
    FPDF_PAGEOBJECT page_object,
    ffi.Pointer<FS_QUADPOINTSF> quad_points,
  ) {
    return _PageObj_GetRotatedBounds(
      page_object,
      quad_points,
    );
  }

  late final _PageObj_GetRotatedBoundsPtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(
                  FPDF_PAGEOBJECT, ffi.Pointer<FS_QUADPOINTSF>)>>(
      'PDFIUM_FPDFPageObj_GetRotatedBounds');
  late final _PageObj_GetRotatedBounds = _PageObj_GetRotatedBoundsPtr
      .asFunction<int Function(FPDF_PAGEOBJECT, ffi.Pointer<FS_QUADPOINTSF>)>();

  /// Set the blend mode of |page_object|.
  /// page_object  - handle to a page object.
  /// blend_mode   - string containing the blend mode.
  /// Blend mode can be one of following: Color, ColorBurn, ColorDodge, Darken,
  /// Difference, Exclusion, HardLight, Hue, Lighten, Luminosity, Multiply, Normal,
  /// Overlay, Saturation, Screen, SoftLight
  void PageObj_SetBlendMode(
    FPDF_PAGEOBJECT page_object,
    FPDF_BYTESTRING blend_mode,
  ) {
    return _PageObj_SetBlendMode(
      page_object,
      blend_mode,
    );
  }

  late final _PageObj_SetBlendModePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(FPDF_PAGEOBJECT, FPDF_BYTESTRING)>>(
      'PDFIUM_FPDFPageObj_SetBlendMode');
  late final _PageObj_SetBlendMode = _PageObj_SetBlendModePtr.asFunction<
      void Function(FPDF_PAGEOBJECT, FPDF_BYTESTRING)>();

  /// Set the stroke RGBA of a page object. Range of values: 0 - 255.
  /// page_object  - the handle to the page object.
  /// R            - the red component for the object's stroke color.
  /// G            - the green component for the object's stroke color.
  /// B            - the blue component for the object's stroke color.
  /// A            - the stroke alpha for the object.
  /// Returns TRUE on success.
  int PageObj_SetStrokeColor(
    FPDF_PAGEOBJECT page_object,
    int R,
    int G,
    int B,
    int A,
  ) {
    return _PageObj_SetStrokeColor(
      page_object,
      R,
      G,
      B,
      A,
    );
  }

  late final _PageObj_SetStrokeColorPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGEOBJECT,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('PDFIUM_FPDFPageObj_SetStrokeColor');
  late final _PageObj_SetStrokeColor = _PageObj_SetStrokeColorPtr.asFunction<
      int Function(FPDF_PAGEOBJECT, int, int, int, int)>();

  /// Get the stroke RGBA of a page object. Range of values: 0 - 255.
  /// page_object  - the handle to the page object.
  /// R            - the red component of the path stroke color.
  /// G            - the green component of the object's stroke color.
  /// B            - the blue component of the object's stroke color.
  /// A            - the stroke alpha of the object.
  /// Returns TRUE on success.
  int PageObj_GetStrokeColor(
    FPDF_PAGEOBJECT page_object,
    ffi.Pointer<ffi.UnsignedInt> R,
    ffi.Pointer<ffi.UnsignedInt> G,
    ffi.Pointer<ffi.UnsignedInt> B,
    ffi.Pointer<ffi.UnsignedInt> A,
  ) {
    return _PageObj_GetStrokeColor(
      page_object,
      R,
      G,
      B,
      A,
    );
  }

  late final _PageObj_GetStrokeColorPtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(
                  FPDF_PAGEOBJECT,
                  ffi.Pointer<ffi.UnsignedInt>,
                  ffi.Pointer<ffi.UnsignedInt>,
                  ffi.Pointer<ffi.UnsignedInt>,
                  ffi.Pointer<ffi.UnsignedInt>)>>(
      'PDFIUM_FPDFPageObj_GetStrokeColor');
  late final _PageObj_GetStrokeColor = _PageObj_GetStrokeColorPtr.asFunction<
      int Function(
          FPDF_PAGEOBJECT,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// Set the stroke width of a page object.
  /// path   - the handle to the page object.
  /// width  - the width of the stroke.
  /// Returns TRUE on success
  int PageObj_SetStrokeWidth(
    FPDF_PAGEOBJECT page_object,
    double width,
  ) {
    return _PageObj_SetStrokeWidth(
      page_object,
      width,
    );
  }

  late final _PageObj_SetStrokeWidthPtr = _lookup<
          ffi.NativeFunction<FPDF_BOOL Function(FPDF_PAGEOBJECT, ffi.Float)>>(
      'PDFIUM_FPDFPageObj_SetStrokeWidth');
  late final _PageObj_SetStrokeWidth = _PageObj_SetStrokeWidthPtr.asFunction<
      int Function(FPDF_PAGEOBJECT, double)>();

  /// Get the stroke width of a page object.
  /// path   - the handle to the page object.
  /// width  - the width of the stroke.
  /// Returns TRUE on success
  int PageObj_GetStrokeWidth(
    FPDF_PAGEOBJECT page_object,
    ffi.Pointer<ffi.Float> width,
  ) {
    return _PageObj_GetStrokeWidth(
      page_object,
      width,
    );
  }

  late final _PageObj_GetStrokeWidthPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGEOBJECT,
              ffi.Pointer<ffi.Float>)>>('PDFIUM_FPDFPageObj_GetStrokeWidth');
  late final _PageObj_GetStrokeWidth = _PageObj_GetStrokeWidthPtr.asFunction<
      int Function(FPDF_PAGEOBJECT, ffi.Pointer<ffi.Float>)>();

  /// Get the line join of |page_object|.
  /// page_object  - handle to a page object.
  /// Returns the line join, or -1 on failure.
  /// Line join can be one of following: FPDF_LINEJOIN_MITER, FPDF_LINEJOIN_ROUND,
  /// FPDF_LINEJOIN_BEVEL
  int PageObj_GetLineJoin(
    FPDF_PAGEOBJECT page_object,
  ) {
    return _PageObj_GetLineJoin(
      page_object,
    );
  }

  late final _PageObj_GetLineJoinPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGEOBJECT)>>(
          'PDFIUM_FPDFPageObj_GetLineJoin');
  late final _PageObj_GetLineJoin =
      _PageObj_GetLineJoinPtr.asFunction<int Function(FPDF_PAGEOBJECT)>();

  /// Set the line join of |page_object|.
  /// page_object  - handle to a page object.
  /// line_join    - line join
  /// Line join can be one of following: FPDF_LINEJOIN_MITER, FPDF_LINEJOIN_ROUND,
  /// FPDF_LINEJOIN_BEVEL
  int PageObj_SetLineJoin(
    FPDF_PAGEOBJECT page_object,
    int line_join,
  ) {
    return _PageObj_SetLineJoin(
      page_object,
      line_join,
    );
  }

  late final _PageObj_SetLineJoinPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_PAGEOBJECT, ffi.Int)>>(
          'PDFIUM_FPDFPageObj_SetLineJoin');
  late final _PageObj_SetLineJoin =
      _PageObj_SetLineJoinPtr.asFunction<int Function(FPDF_PAGEOBJECT, int)>();

  /// Get the line cap of |page_object|.
  /// page_object - handle to a page object.
  /// Returns the line cap, or -1 on failure.
  /// Line cap can be one of following: FPDF_LINECAP_BUTT, FPDF_LINECAP_ROUND,
  /// FPDF_LINECAP_PROJECTING_SQUARE
  int PageObj_GetLineCap(
    FPDF_PAGEOBJECT page_object,
  ) {
    return _PageObj_GetLineCap(
      page_object,
    );
  }

  late final _PageObj_GetLineCapPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGEOBJECT)>>(
          'PDFIUM_FPDFPageObj_GetLineCap');
  late final _PageObj_GetLineCap =
      _PageObj_GetLineCapPtr.asFunction<int Function(FPDF_PAGEOBJECT)>();

  /// Set the line cap of |page_object|.
  /// page_object - handle to a page object.
  /// line_cap    - line cap
  /// Line cap can be one of following: FPDF_LINECAP_BUTT, FPDF_LINECAP_ROUND,
  /// FPDF_LINECAP_PROJECTING_SQUARE
  int PageObj_SetLineCap(
    FPDF_PAGEOBJECT page_object,
    int line_cap,
  ) {
    return _PageObj_SetLineCap(
      page_object,
      line_cap,
    );
  }

  late final _PageObj_SetLineCapPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_PAGEOBJECT, ffi.Int)>>(
          'PDFIUM_FPDFPageObj_SetLineCap');
  late final _PageObj_SetLineCap =
      _PageObj_SetLineCapPtr.asFunction<int Function(FPDF_PAGEOBJECT, int)>();

  /// Set the fill RGBA of a page object. Range of values: 0 - 255.
  /// page_object  - the handle to the page object.
  /// R            - the red component for the object's fill color.
  /// G            - the green component for the object's fill color.
  /// B            - the blue component for the object's fill color.
  /// A            - the fill alpha for the object.
  /// Returns TRUE on success.
  int PageObj_SetFillColor(
    FPDF_PAGEOBJECT page_object,
    int R,
    int G,
    int B,
    int A,
  ) {
    return _PageObj_SetFillColor(
      page_object,
      R,
      G,
      B,
      A,
    );
  }

  late final _PageObj_SetFillColorPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGEOBJECT,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('PDFIUM_FPDFPageObj_SetFillColor');
  late final _PageObj_SetFillColor = _PageObj_SetFillColorPtr.asFunction<
      int Function(FPDF_PAGEOBJECT, int, int, int, int)>();

  /// Get the fill RGBA of a page object. Range of values: 0 - 255.
  /// page_object  - the handle to the page object.
  /// R            - the red component of the object's fill color.
  /// G            - the green component of the object's fill color.
  /// B            - the blue component of the object's fill color.
  /// A            - the fill alpha of the object.
  /// Returns TRUE on success.
  int PageObj_GetFillColor(
    FPDF_PAGEOBJECT page_object,
    ffi.Pointer<ffi.UnsignedInt> R,
    ffi.Pointer<ffi.UnsignedInt> G,
    ffi.Pointer<ffi.UnsignedInt> B,
    ffi.Pointer<ffi.UnsignedInt> A,
  ) {
    return _PageObj_GetFillColor(
      page_object,
      R,
      G,
      B,
      A,
    );
  }

  late final _PageObj_GetFillColorPtr = _lookup<
          ffi.NativeFunction<
              FPDF_BOOL Function(
                  FPDF_PAGEOBJECT,
                  ffi.Pointer<ffi.UnsignedInt>,
                  ffi.Pointer<ffi.UnsignedInt>,
                  ffi.Pointer<ffi.UnsignedInt>,
                  ffi.Pointer<ffi.UnsignedInt>)>>(
      'PDFIUM_FPDFPageObj_GetFillColor');
  late final _PageObj_GetFillColor = _PageObj_GetFillColorPtr.asFunction<
      int Function(
          FPDF_PAGEOBJECT,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// Experimental API.
  /// Get the line dash |phase| of |page_object|.
  /// page_object - handle to a page object.
  /// phase - pointer where the dashing phase will be stored.
  /// Returns TRUE on success.
  int PageObj_GetDashPhase(
    FPDF_PAGEOBJECT page_object,
    ffi.Pointer<ffi.Float> phase,
  ) {
    return _PageObj_GetDashPhase(
      page_object,
      phase,
    );
  }

  late final _PageObj_GetDashPhasePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGEOBJECT,
              ffi.Pointer<ffi.Float>)>>('PDFIUM_FPDFPageObj_GetDashPhase');
  late final _PageObj_GetDashPhase = _PageObj_GetDashPhasePtr.asFunction<
      int Function(FPDF_PAGEOBJECT, ffi.Pointer<ffi.Float>)>();

  /// Experimental API.
  /// Set the line dash phase of |page_object|.
  /// page_object - handle to a page object.
  /// phase - line dash phase.
  /// Returns TRUE on success.
  int PageObj_SetDashPhase(
    FPDF_PAGEOBJECT page_object,
    double phase,
  ) {
    return _PageObj_SetDashPhase(
      page_object,
      phase,
    );
  }

  late final _PageObj_SetDashPhasePtr = _lookup<
          ffi.NativeFunction<FPDF_BOOL Function(FPDF_PAGEOBJECT, ffi.Float)>>(
      'PDFIUM_FPDFPageObj_SetDashPhase');
  late final _PageObj_SetDashPhase = _PageObj_SetDashPhasePtr.asFunction<
      int Function(FPDF_PAGEOBJECT, double)>();

  /// Experimental API.
  /// Get the line dash array of |page_object|.
  /// page_object - handle to a page object.
  /// Returns the line dash array size or -1 on failure.
  int PageObj_GetDashCount(
    FPDF_PAGEOBJECT page_object,
  ) {
    return _PageObj_GetDashCount(
      page_object,
    );
  }

  late final _PageObj_GetDashCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGEOBJECT)>>(
          'PDFIUM_FPDFPageObj_GetDashCount');
  late final _PageObj_GetDashCount =
      _PageObj_GetDashCountPtr.asFunction<int Function(FPDF_PAGEOBJECT)>();

  /// Experimental API.
  /// Get the line dash array of |page_object|.
  /// page_object - handle to a page object.
  /// dash_array - pointer where the dashing array will be stored.
  /// dash_count - number of elements in |dash_array|.
  /// Returns TRUE on success.
  int PageObj_GetDashArray(
    FPDF_PAGEOBJECT page_object,
    ffi.Pointer<ffi.Float> dash_array,
    int dash_count,
  ) {
    return _PageObj_GetDashArray(
      page_object,
      dash_array,
      dash_count,
    );
  }

  late final _PageObj_GetDashArrayPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGEOBJECT, ffi.Pointer<ffi.Float>,
              ffi.Size)>>('PDFIUM_FPDFPageObj_GetDashArray');
  late final _PageObj_GetDashArray = _PageObj_GetDashArrayPtr.asFunction<
      int Function(FPDF_PAGEOBJECT, ffi.Pointer<ffi.Float>, int)>();

  /// Experimental API.
  /// Set the line dash array of |page_object|.
  /// page_object - handle to a page object.
  /// dash_array - the dash array.
  /// dash_count - number of elements in |dash_array|.
  /// phase - the line dash phase.
  /// Returns TRUE on success.
  int PageObj_SetDashArray(
    FPDF_PAGEOBJECT page_object,
    ffi.Pointer<ffi.Float> dash_array,
    int dash_count,
    double phase,
  ) {
    return _PageObj_SetDashArray(
      page_object,
      dash_array,
      dash_count,
      phase,
    );
  }

  late final _PageObj_SetDashArrayPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGEOBJECT, ffi.Pointer<ffi.Float>, ffi.Size,
              ffi.Float)>>('PDFIUM_FPDFPageObj_SetDashArray');
  late final _PageObj_SetDashArray = _PageObj_SetDashArrayPtr.asFunction<
      int Function(FPDF_PAGEOBJECT, ffi.Pointer<ffi.Float>, int, double)>();

  /// Get number of segments inside |path|.
  /// path - handle to a path.
  /// A segment is a command, created by e.g. FPDFPath_MoveTo(),
  /// FPDFPath_LineTo() or FPDFPath_BezierTo().
  /// Returns the number of objects in |path| or -1 on failure.
  int Path_CountSegments(
    FPDF_PAGEOBJECT path,
  ) {
    return _Path_CountSegments(
      path,
    );
  }

  late final _Path_CountSegmentsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGEOBJECT)>>(
          'PDFIUM_FPDFPath_CountSegments');
  late final _Path_CountSegments =
      _Path_CountSegmentsPtr.asFunction<int Function(FPDF_PAGEOBJECT)>();

  /// Get segment in |path| at |index|.
  /// path  - handle to a path.
  /// index - the index of a segment.
  /// Returns the handle to the segment, or NULL on faiure.
  FPDF_PATHSEGMENT Path_GetPathSegment(
    FPDF_PAGEOBJECT path,
    int index,
  ) {
    return _Path_GetPathSegment(
      path,
      index,
    );
  }

  late final _Path_GetPathSegmentPtr = _lookup<
          ffi
          .NativeFunction<FPDF_PATHSEGMENT Function(FPDF_PAGEOBJECT, ffi.Int)>>(
      'PDFIUM_FPDFPath_GetPathSegment');
  late final _Path_GetPathSegment = _Path_GetPathSegmentPtr.asFunction<
      FPDF_PATHSEGMENT Function(FPDF_PAGEOBJECT, int)>();

  /// Get coordinates of |segment|.
  /// segment  - handle to a segment.
  /// x      - the horizontal position of the segment.
  /// y      - the vertical position of the segment.
  /// Returns TRUE on success, otherwise |x| and |y| is not set.
  int PathSegment_GetPoint(
    FPDF_PATHSEGMENT segment,
    ffi.Pointer<ffi.Float> x,
    ffi.Pointer<ffi.Float> y,
  ) {
    return _PathSegment_GetPoint(
      segment,
      x,
      y,
    );
  }

  late final _PathSegment_GetPointPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PATHSEGMENT, ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('PDFIUM_FPDFPathSegment_GetPoint');
  late final _PathSegment_GetPoint = _PathSegment_GetPointPtr.asFunction<
      int Function(
          FPDF_PATHSEGMENT, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>)>();

  /// Get type of |segment|.
  /// segment - handle to a segment.
  /// Returns one of the FPDF_SEGMENT_* values on success,
  /// FPDF_SEGMENT_UNKNOWN on error.
  int PathSegment_GetType(
    FPDF_PATHSEGMENT segment,
  ) {
    return _PathSegment_GetType(
      segment,
    );
  }

  late final _PathSegment_GetTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PATHSEGMENT)>>(
          'PDFIUM_FPDFPathSegment_GetType');
  late final _PathSegment_GetType =
      _PathSegment_GetTypePtr.asFunction<int Function(FPDF_PATHSEGMENT)>();

  /// Gets if the |segment| closes the current subpath of a given path.
  /// segment - handle to a segment.
  /// Returns close flag for non-NULL segment, FALSE otherwise.
  int PathSegment_GetClose(
    FPDF_PATHSEGMENT segment,
  ) {
    return _PathSegment_GetClose(
      segment,
    );
  }

  late final _PathSegment_GetClosePtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_PATHSEGMENT)>>(
          'PDFIUM_FPDFPathSegment_GetClose');
  late final _PathSegment_GetClose =
      _PathSegment_GetClosePtr.asFunction<int Function(FPDF_PATHSEGMENT)>();

  /// Move a path's current point.
  /// path   - the handle to the path object.
  /// x      - the horizontal position of the new current point.
  /// y      - the vertical position of the new current point.
  /// Note that no line will be created between the previous current point and the
  /// new one.
  /// Returns TRUE on success
  int Path_MoveTo(
    FPDF_PAGEOBJECT path,
    double x,
    double y,
  ) {
    return _Path_MoveTo(
      path,
      x,
      y,
    );
  }

  late final _Path_MoveToPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGEOBJECT, ffi.Float,
              ffi.Float)>>('PDFIUM_FPDFPath_MoveTo');
  late final _Path_MoveTo = _Path_MoveToPtr.asFunction<
      int Function(FPDF_PAGEOBJECT, double, double)>();

  /// Add a line between the current point and a new point in the path.
  /// path   - the handle to the path object.
  /// x      - the horizontal position of the new point.
  /// y      - the vertical position of the new point.
  /// The path's current point is changed to (x, y).
  /// Returns TRUE on success
  int Path_LineTo(
    FPDF_PAGEOBJECT path,
    double x,
    double y,
  ) {
    return _Path_LineTo(
      path,
      x,
      y,
    );
  }

  late final _Path_LineToPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGEOBJECT, ffi.Float,
              ffi.Float)>>('PDFIUM_FPDFPath_LineTo');
  late final _Path_LineTo = _Path_LineToPtr.asFunction<
      int Function(FPDF_PAGEOBJECT, double, double)>();

  /// Add a cubic Bezier curve to the given path, starting at the current point.
  /// path   - the handle to the path object.
  /// x1     - the horizontal position of the first Bezier control point.
  /// y1     - the vertical position of the first Bezier control point.
  /// x2     - the horizontal position of the second Bezier control point.
  /// y2     - the vertical position of the second Bezier control point.
  /// x3     - the horizontal position of the ending point of the Bezier curve.
  /// y3     - the vertical position of the ending point of the Bezier curve.
  /// Returns TRUE on success
  int Path_BezierTo(
    FPDF_PAGEOBJECT path,
    double x1,
    double y1,
    double x2,
    double y2,
    double x3,
    double y3,
  ) {
    return _Path_BezierTo(
      path,
      x1,
      y1,
      x2,
      y2,
      x3,
      y3,
    );
  }

  late final _Path_BezierToPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGEOBJECT, ffi.Float, ffi.Float, ffi.Float,
              ffi.Float, ffi.Float, ffi.Float)>>('PDFIUM_FPDFPath_BezierTo');
  late final _Path_BezierTo = _Path_BezierToPtr.asFunction<
      int Function(
          FPDF_PAGEOBJECT, double, double, double, double, double, double)>();

  /// Close the current subpath of a given path.
  /// path   - the handle to the path object.
  /// This will add a line between the current point and the initial point of the
  /// subpath, thus terminating the current subpath.
  /// Returns TRUE on success
  int Path_Close(
    FPDF_PAGEOBJECT path,
  ) {
    return _Path_Close(
      path,
    );
  }

  late final _Path_ClosePtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_PAGEOBJECT)>>(
          'PDFIUM_FPDFPath_Close');
  late final _Path_Close =
      _Path_ClosePtr.asFunction<int Function(FPDF_PAGEOBJECT)>();

  /// Set the drawing mode of a path.
  /// path     - the handle to the path object.
  /// fillmode - the filling mode to be set: one of the FPDF_FILLMODE_* flags.
  /// stroke   - a boolean specifying if the path should be stroked or not.
  /// Returns TRUE on success
  int Path_SetDrawMode(
    FPDF_PAGEOBJECT path,
    int fillmode,
    int stroke,
  ) {
    return _Path_SetDrawMode(
      path,
      fillmode,
      stroke,
    );
  }

  late final _Path_SetDrawModePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGEOBJECT, ffi.Int,
              FPDF_BOOL)>>('PDFIUM_FPDFPath_SetDrawMode');
  late final _Path_SetDrawMode = _Path_SetDrawModePtr.asFunction<
      int Function(FPDF_PAGEOBJECT, int, int)>();

  /// Get the drawing mode of a path.
  /// path     - the handle to the path object.
  /// fillmode - the filling mode of the path: one of the FPDF_FILLMODE_* flags.
  /// stroke   - a boolean specifying if the path is stroked or not.
  /// Returns TRUE on success
  int Path_GetDrawMode(
    FPDF_PAGEOBJECT path,
    ffi.Pointer<ffi.Int> fillmode,
    ffi.Pointer<FPDF_BOOL> stroke,
  ) {
    return _Path_GetDrawMode(
      path,
      fillmode,
      stroke,
    );
  }

  late final _Path_GetDrawModePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGEOBJECT, ffi.Pointer<ffi.Int>,
              ffi.Pointer<FPDF_BOOL>)>>('PDFIUM_FPDFPath_GetDrawMode');
  late final _Path_GetDrawMode = _Path_GetDrawModePtr.asFunction<
      int Function(
          FPDF_PAGEOBJECT, ffi.Pointer<ffi.Int>, ffi.Pointer<FPDF_BOOL>)>();

  /// Create a new text object using one of the standard PDF fonts.
  /// document   - handle to the document.
  /// font       - string containing the font name, without spaces.
  /// font_size  - the font size for the new text object.
  /// Returns a handle to a new text object, or NULL on failure
  FPDF_PAGEOBJECT PageObj_NewTextObj(
    FPDF_DOCUMENT document,
    FPDF_BYTESTRING font,
    double font_size,
  ) {
    return _PageObj_NewTextObj(
      document,
      font,
      font_size,
    );
  }

  late final _PageObj_NewTextObjPtr = _lookup<
      ffi.NativeFunction<
          FPDF_PAGEOBJECT Function(FPDF_DOCUMENT, FPDF_BYTESTRING,
              ffi.Float)>>('PDFIUM_FPDFPageObj_NewTextObj');
  late final _PageObj_NewTextObj = _PageObj_NewTextObjPtr.asFunction<
      FPDF_PAGEOBJECT Function(FPDF_DOCUMENT, FPDF_BYTESTRING, double)>();

  /// Set the text for a text object. If it had text, it will be replaced.
  /// text_object  - handle to the text object.
  /// text         - the UTF-16LE encoded string containing the text to be added.
  /// Returns TRUE on success
  int Text_SetText(
    FPDF_PAGEOBJECT text_object,
    FPDF_WIDESTRING text,
  ) {
    return _Text_SetText(
      text_object,
      text,
    );
  }

  late final _Text_SetTextPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGEOBJECT, FPDF_WIDESTRING)>>('PDFIUM_FPDFText_SetText');
  late final _Text_SetText = _Text_SetTextPtr.asFunction<
      int Function(FPDF_PAGEOBJECT, FPDF_WIDESTRING)>();

  /// Experimental API.
  /// Set the text using charcodes for a text object. If it had text, it will be
  /// replaced.
  /// text_object  - handle to the text object.
  /// charcodes    - pointer to an array of charcodes to be added.
  /// count        - number of elements in |charcodes|.
  /// Returns TRUE on success
  int Text_SetCharcodes(
    FPDF_PAGEOBJECT text_object,
    ffi.Pointer<ffi.Uint32> charcodes,
    int count,
  ) {
    return _Text_SetCharcodes(
      text_object,
      charcodes,
      count,
    );
  }

  late final _Text_SetCharcodesPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGEOBJECT, ffi.Pointer<ffi.Uint32>,
              ffi.Size)>>('PDFIUM_FPDFText_SetCharcodes');
  late final _Text_SetCharcodes = _Text_SetCharcodesPtr.asFunction<
      int Function(FPDF_PAGEOBJECT, ffi.Pointer<ffi.Uint32>, int)>();

  /// Returns a font object loaded from a stream of data. The font is loaded
  /// into the document. Various font data structures, such as the ToUnicode data,
  /// are auto-generated based on the inputs.
  /// document  - handle to the document.
  /// data      - the stream of font data, which will be copied by the font object.
  /// size      - the size of the font data, in bytes.
  /// font_type - FPDF_FONT_TYPE1 or FPDF_FONT_TRUETYPE depending on the font type.
  /// cid       - a boolean specifying if the font is a CID font or not.
  /// The loaded font can be closed using FPDFFont_Close().
  /// Returns NULL on failure
  FPDF_FONT Text_LoadFont(
    FPDF_DOCUMENT document,
    ffi.Pointer<ffi.Uint8> data,
    int size,
    int font_type,
    int cid,
  ) {
    return _Text_LoadFont(
      document,
      data,
      size,
      font_type,
      cid,
    );
  }

  late final _Text_LoadFontPtr = _lookup<
      ffi.NativeFunction<
          FPDF_FONT Function(FPDF_DOCUMENT, ffi.Pointer<ffi.Uint8>, ffi.Uint32,
              ffi.Int, FPDF_BOOL)>>('PDFIUM_FPDFText_LoadFont');
  late final _Text_LoadFont = _Text_LoadFontPtr.asFunction<
      FPDF_FONT Function(
          FPDF_DOCUMENT, ffi.Pointer<ffi.Uint8>, int, int, int)>();

  /// Experimental API.
  /// Loads one of the standard 14 fonts per PDF spec 1.7 page 416. The preferred
  /// way of using font style is using a dash to separate the name from the style,
  /// for example 'Helvetica-BoldItalic'.
  /// document   - handle to the document.
  /// font       - string containing the font name, without spaces.
  /// The loaded font can be closed using FPDFFont_Close().
  /// Returns NULL on failure.
  FPDF_FONT Text_LoadStandardFont(
    FPDF_DOCUMENT document,
    FPDF_BYTESTRING font,
  ) {
    return _Text_LoadStandardFont(
      document,
      font,
    );
  }

  late final _Text_LoadStandardFontPtr = _lookup<
          ffi
          .NativeFunction<FPDF_FONT Function(FPDF_DOCUMENT, FPDF_BYTESTRING)>>(
      'PDFIUM_FPDFText_LoadStandardFont');
  late final _Text_LoadStandardFont = _Text_LoadStandardFontPtr.asFunction<
      FPDF_FONT Function(FPDF_DOCUMENT, FPDF_BYTESTRING)>();

  /// Experimental API.
  /// Returns a font object loaded from a stream of data for a type 2 CID font. The
  /// font is loaded into the document. Unlike FPDFText_LoadFont(), the ToUnicode
  /// data and the CIDToGIDMap data are caller provided, instead of auto-generated.
  /// document                 - handle to the document.
  /// font_data                - the stream of font data, which will be copied by
  /// the font object.
  /// font_data_size           - the size of the font data, in bytes.
  /// to_unicode_cmap          - the ToUnicode data.
  /// cid_to_gid_map_data      - the stream of CIDToGIDMap data.
  /// cid_to_gid_map_data_size - the size of the CIDToGIDMap data, in bytes.
  /// The loaded font can be closed using FPDFFont_Close().
  /// Returns NULL on failure.
  FPDF_FONT Text_LoadCidType2Font(
    FPDF_DOCUMENT document,
    ffi.Pointer<ffi.Uint8> font_data,
    int font_data_size,
    FPDF_BYTESTRING to_unicode_cmap,
    ffi.Pointer<ffi.Uint8> cid_to_gid_map_data,
    int cid_to_gid_map_data_size,
  ) {
    return _Text_LoadCidType2Font(
      document,
      font_data,
      font_data_size,
      to_unicode_cmap,
      cid_to_gid_map_data,
      cid_to_gid_map_data_size,
    );
  }

  late final _Text_LoadCidType2FontPtr = _lookup<
      ffi.NativeFunction<
          FPDF_FONT Function(
              FPDF_DOCUMENT,
              ffi.Pointer<ffi.Uint8>,
              ffi.Uint32,
              FPDF_BYTESTRING,
              ffi.Pointer<ffi.Uint8>,
              ffi.Uint32)>>('PDFIUM_FPDFText_LoadCidType2Font');
  late final _Text_LoadCidType2Font = _Text_LoadCidType2FontPtr.asFunction<
      FPDF_FONT Function(FPDF_DOCUMENT, ffi.Pointer<ffi.Uint8>, int,
          FPDF_BYTESTRING, ffi.Pointer<ffi.Uint8>, int)>();

  /// Get the font size of a text object.
  /// text - handle to a text.
  /// size - pointer to the font size of the text object, measured in points
  /// (about 1/72 inch)
  /// Returns TRUE on success.
  int TextObj_GetFontSize(
    FPDF_PAGEOBJECT text,
    ffi.Pointer<ffi.Float> size,
  ) {
    return _TextObj_GetFontSize(
      text,
      size,
    );
  }

  late final _TextObj_GetFontSizePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGEOBJECT,
              ffi.Pointer<ffi.Float>)>>('PDFIUM_FPDFTextObj_GetFontSize');
  late final _TextObj_GetFontSize = _TextObj_GetFontSizePtr.asFunction<
      int Function(FPDF_PAGEOBJECT, ffi.Pointer<ffi.Float>)>();

  /// Close a loaded PDF font.
  /// font   - Handle to the loaded font.
  void Font_Close(
    FPDF_FONT font,
  ) {
    return _Font_Close(
      font,
    );
  }

  late final _Font_ClosePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_FONT)>>(
          'PDFIUM_FPDFFont_Close');
  late final _Font_Close =
      _Font_ClosePtr.asFunction<void Function(FPDF_FONT)>();

  /// Create a new text object using a loaded font.
  /// document   - handle to the document.
  /// font       - handle to the font object.
  /// font_size  - the font size for the new text object.
  /// Returns a handle to a new text object, or NULL on failure
  FPDF_PAGEOBJECT PageObj_CreateTextObj(
    FPDF_DOCUMENT document,
    FPDF_FONT font,
    double font_size,
  ) {
    return _PageObj_CreateTextObj(
      document,
      font,
      font_size,
    );
  }

  late final _PageObj_CreateTextObjPtr = _lookup<
      ffi.NativeFunction<
          FPDF_PAGEOBJECT Function(FPDF_DOCUMENT, FPDF_FONT,
              ffi.Float)>>('PDFIUM_FPDFPageObj_CreateTextObj');
  late final _PageObj_CreateTextObj = _PageObj_CreateTextObjPtr.asFunction<
      FPDF_PAGEOBJECT Function(FPDF_DOCUMENT, FPDF_FONT, double)>();

  /// Get the text rendering mode of a text object.
  /// text     - the handle to the text object.
  /// Returns one of the known FPDF_TEXT_RENDERMODE enum values on success,
  /// FPDF_TEXTRENDERMODE_UNKNOWN on error.
  int TextObj_GetTextRenderMode(
    FPDF_PAGEOBJECT text,
  ) {
    return _TextObj_GetTextRenderMode(
      text,
    );
  }

  late final _TextObj_GetTextRenderModePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(FPDF_PAGEOBJECT)>>(
          'PDFIUM_FPDFTextObj_GetTextRenderMode');
  late final _TextObj_GetTextRenderMode =
      _TextObj_GetTextRenderModePtr.asFunction<int Function(FPDF_PAGEOBJECT)>();

  /// Experimental API.
  /// Set the text rendering mode of a text object.
  /// text         - the handle to the text object.
  /// render_mode  - the FPDF_TEXT_RENDERMODE enum value to be set (cannot set to
  /// FPDF_TEXTRENDERMODE_UNKNOWN).
  /// Returns TRUE on success.
  int TextObj_SetTextRenderMode(
    FPDF_PAGEOBJECT text,
    int render_mode,
  ) {
    return _TextObj_SetTextRenderMode(
      text,
      render_mode,
    );
  }

  late final _TextObj_SetTextRenderModePtr = _lookup<
          ffi.NativeFunction<FPDF_BOOL Function(FPDF_PAGEOBJECT, ffi.Int32)>>(
      'PDFIUM_FPDFTextObj_SetTextRenderMode');
  late final _TextObj_SetTextRenderMode = _TextObj_SetTextRenderModePtr
      .asFunction<int Function(FPDF_PAGEOBJECT, int)>();

  /// Get the text of a text object.
  /// text_object      - the handle to the text object.
  /// text_page        - the handle to the text page.
  /// buffer           - the address of a buffer that receives the text.
  /// length           - the size, in bytes, of |buffer|.
  /// Returns the number of bytes in the text (including the trailing NUL
  /// character) on success, 0 on error.
  /// Regardless of the platform, the |buffer| is always in UTF-16LE encoding.
  /// If |length| is less than the returned length, or |buffer| is NULL, |buffer|
  /// will not be modified.
  int TextObj_GetText(
    FPDF_PAGEOBJECT text_object,
    FPDF_TEXTPAGE text_page,
    ffi.Pointer<FPDF_WCHAR> buffer,
    int length,
  ) {
    return _TextObj_GetText(
      text_object,
      text_page,
      buffer,
      length,
    );
  }

  late final _TextObj_GetTextPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_PAGEOBJECT,
              FPDF_TEXTPAGE,
              ffi.Pointer<FPDF_WCHAR>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFTextObj_GetText');
  late final _TextObj_GetText = _TextObj_GetTextPtr.asFunction<
      int Function(
          FPDF_PAGEOBJECT, FPDF_TEXTPAGE, ffi.Pointer<FPDF_WCHAR>, int)>();

  /// Experimental API.
  /// Get a bitmap rasterization of |text_object|. To render correctly, the caller
  /// must provide the |document| associated with |text_object|. If there is a
  /// |page| associated with |text_object|, the caller should provide that as well.
  /// The returned bitmap will be owned by the caller, and FPDFBitmap_Destroy()
  /// must be called on the returned bitmap when it is no longer needed.
  /// document    - handle to a document associated with |text_object|.
  /// page        - handle to an optional page associated with |text_object|.
  /// text_object - handle to a text object.
  /// scale       - the scaling factor, which must be greater than 0.
  /// Returns the bitmap or NULL on failure.
  FPDF_BITMAP TextObj_GetRenderedBitmap(
    FPDF_DOCUMENT document,
    FPDF_PAGE page,
    FPDF_PAGEOBJECT text_object,
    double scale,
  ) {
    return _TextObj_GetRenderedBitmap(
      document,
      page,
      text_object,
      scale,
    );
  }

  late final _TextObj_GetRenderedBitmapPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BITMAP Function(FPDF_DOCUMENT, FPDF_PAGE, FPDF_PAGEOBJECT,
              ffi.Float)>>('PDFIUM_FPDFTextObj_GetRenderedBitmap');
  late final _TextObj_GetRenderedBitmap =
      _TextObj_GetRenderedBitmapPtr.asFunction<
          FPDF_BITMAP Function(
              FPDF_DOCUMENT, FPDF_PAGE, FPDF_PAGEOBJECT, double)>();

  /// Experimental API.
  /// Get the font of a text object.
  /// text - the handle to the text object.
  /// Returns a handle to the font object held by |text| which retains ownership.
  FPDF_FONT TextObj_GetFont(
    FPDF_PAGEOBJECT text,
  ) {
    return _TextObj_GetFont(
      text,
    );
  }

  late final _TextObj_GetFontPtr =
      _lookup<ffi.NativeFunction<FPDF_FONT Function(FPDF_PAGEOBJECT)>>(
          'PDFIUM_FPDFTextObj_GetFont');
  late final _TextObj_GetFont =
      _TextObj_GetFontPtr.asFunction<FPDF_FONT Function(FPDF_PAGEOBJECT)>();

  /// Experimental API.
  /// Get the base name of a font.
  /// font   - the handle to the font object.
  /// buffer - the address of a buffer that receives the base font name.
  /// length - the size, in bytes, of |buffer|.
  /// Returns the number of bytes in the base name (including the trailing NUL
  /// character) on success, 0 on error. The base name is typically the font's
  /// PostScript name. See descriptions of "BaseFont" in ISO 32000-1:2008 spec.
  /// Regardless of the platform, the |buffer| is always in UTF-8 encoding.
  /// If |length| is less than the returned length, or |buffer| is NULL, |buffer|
  /// will not be modified.
  int Font_GetBaseFontName(
    FPDF_FONT font,
    ffi.Pointer<ffi.Char> buffer,
    int length,
  ) {
    return _Font_GetBaseFontName(
      font,
      buffer,
      length,
    );
  }

  late final _Font_GetBaseFontNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(FPDF_FONT, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('PDFIUM_FPDFFont_GetBaseFontName');
  late final _Font_GetBaseFontName = _Font_GetBaseFontNamePtr.asFunction<
      int Function(FPDF_FONT, ffi.Pointer<ffi.Char>, int)>();

  /// Experimental API.
  /// Get the family name of a font.
  /// font   - the handle to the font object.
  /// buffer - the address of a buffer that receives the font name.
  /// length - the size, in bytes, of |buffer|.
  /// Returns the number of bytes in the family name (including the trailing NUL
  /// character) on success, 0 on error.
  /// Regardless of the platform, the |buffer| is always in UTF-8 encoding.
  /// If |length| is less than the returned length, or |buffer| is NULL, |buffer|
  /// will not be modified.
  int Font_GetFamilyName(
    FPDF_FONT font,
    ffi.Pointer<ffi.Char> buffer,
    int length,
  ) {
    return _Font_GetFamilyName(
      font,
      buffer,
      length,
    );
  }

  late final _Font_GetFamilyNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(FPDF_FONT, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('PDFIUM_FPDFFont_GetFamilyName');
  late final _Font_GetFamilyName = _Font_GetFamilyNamePtr.asFunction<
      int Function(FPDF_FONT, ffi.Pointer<ffi.Char>, int)>();

  /// Experimental API.
  /// Get the decoded data from the |font| object.
  /// font       - The handle to the font object. (Required)
  /// buffer     - The address of a buffer that receives the font data.
  /// buflen     - Length of the buffer.
  /// out_buflen - Pointer to variable that will receive the minimum buffer size
  /// to contain the font data. Not filled if the return value is
  /// FALSE. (Required)
  /// Returns TRUE on success. In which case, |out_buflen| will be filled, and
  /// |buffer| will be filled if it is large enough. Returns FALSE if any of the
  /// required parameters are null.
  /// The decoded data is the uncompressed font data. i.e. the raw font data after
  /// having all stream filters applied, when the data is embedded.
  /// If the font is not embedded, then this API will instead return the data for
  /// the substitution font it is using.
  int Font_GetFontData(
    FPDF_FONT font,
    ffi.Pointer<ffi.Uint8> buffer,
    int buflen,
    ffi.Pointer<ffi.Size> out_buflen,
  ) {
    return _Font_GetFontData(
      font,
      buffer,
      buflen,
      out_buflen,
    );
  }

  late final _Font_GetFontDataPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_FONT, ffi.Pointer<ffi.Uint8>, ffi.Size,
              ffi.Pointer<ffi.Size>)>>('PDFIUM_FPDFFont_GetFontData');
  late final _Font_GetFontData = _Font_GetFontDataPtr.asFunction<
      int Function(
          FPDF_FONT, ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Size>)>();

  /// Experimental API.
  /// Get whether |font| is embedded or not.
  /// font - the handle to the font object.
  /// Returns 1 if the font is embedded, 0 if it not, and -1 on failure.
  int Font_GetIsEmbedded(
    FPDF_FONT font,
  ) {
    return _Font_GetIsEmbedded(
      font,
    );
  }

  late final _Font_GetIsEmbeddedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_FONT)>>(
          'PDFIUM_FPDFFont_GetIsEmbedded');
  late final _Font_GetIsEmbedded =
      _Font_GetIsEmbeddedPtr.asFunction<int Function(FPDF_FONT)>();

  /// Experimental API.
  /// Get the descriptor flags of a font.
  /// font - the handle to the font object.
  /// Returns the bit flags specifying various characteristics of the font as
  /// defined in ISO 32000-1:2008, table 123, -1 on failure.
  int Font_GetFlags(
    FPDF_FONT font,
  ) {
    return _Font_GetFlags(
      font,
    );
  }

  late final _Font_GetFlagsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_FONT)>>(
          'PDFIUM_FPDFFont_GetFlags');
  late final _Font_GetFlags =
      _Font_GetFlagsPtr.asFunction<int Function(FPDF_FONT)>();

  /// Experimental API.
  /// Get the font weight of a font.
  /// font - the handle to the font object.
  /// Returns the font weight, -1 on failure.
  /// Typical values are 400 (normal) and 700 (bold).
  int Font_GetWeight(
    FPDF_FONT font,
  ) {
    return _Font_GetWeight(
      font,
    );
  }

  late final _Font_GetWeightPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_FONT)>>(
          'PDFIUM_FPDFFont_GetWeight');
  late final _Font_GetWeight =
      _Font_GetWeightPtr.asFunction<int Function(FPDF_FONT)>();

  /// Experimental API.
  /// Get the italic angle of a font.
  /// font  - the handle to the font object.
  /// angle - pointer where the italic angle will be stored
  /// The italic angle of a |font| is defined as degrees counterclockwise
  /// from vertical. For a font that slopes to the right, this will be negative.
  /// Returns TRUE on success; |angle| unmodified on failure.
  int Font_GetItalicAngle(
    FPDF_FONT font,
    ffi.Pointer<ffi.Int> angle,
  ) {
    return _Font_GetItalicAngle(
      font,
      angle,
    );
  }

  late final _Font_GetItalicAnglePtr = _lookup<
          ffi
          .NativeFunction<FPDF_BOOL Function(FPDF_FONT, ffi.Pointer<ffi.Int>)>>(
      'PDFIUM_FPDFFont_GetItalicAngle');
  late final _Font_GetItalicAngle = _Font_GetItalicAnglePtr.asFunction<
      int Function(FPDF_FONT, ffi.Pointer<ffi.Int>)>();

  /// Experimental API.
  /// Get ascent distance of a font.
  /// font       - the handle to the font object.
  /// font_size  - the size of the |font|.
  /// ascent     - pointer where the font ascent will be stored
  /// Ascent is the maximum distance in points above the baseline reached by the
  /// glyphs of the |font|. One point is 1/72 inch (around 0.3528 mm).
  /// Returns TRUE on success; |ascent| unmodified on failure.
  int Font_GetAscent(
    FPDF_FONT font,
    double font_size,
    ffi.Pointer<ffi.Float> ascent,
  ) {
    return _Font_GetAscent(
      font,
      font_size,
      ascent,
    );
  }

  late final _Font_GetAscentPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_FONT, ffi.Float,
              ffi.Pointer<ffi.Float>)>>('PDFIUM_FPDFFont_GetAscent');
  late final _Font_GetAscent = _Font_GetAscentPtr.asFunction<
      int Function(FPDF_FONT, double, ffi.Pointer<ffi.Float>)>();

  /// Experimental API.
  /// Get descent distance of a font.
  /// font       - the handle to the font object.
  /// font_size  - the size of the |font|.
  /// descent    - pointer where the font descent will be stored
  /// Descent is the maximum distance in points below the baseline reached by the
  /// glyphs of the |font|. One point is 1/72 inch (around 0.3528 mm).
  /// Returns TRUE on success; |descent| unmodified on failure.
  int Font_GetDescent(
    FPDF_FONT font,
    double font_size,
    ffi.Pointer<ffi.Float> descent,
  ) {
    return _Font_GetDescent(
      font,
      font_size,
      descent,
    );
  }

  late final _Font_GetDescentPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_FONT, ffi.Float,
              ffi.Pointer<ffi.Float>)>>('PDFIUM_FPDFFont_GetDescent');
  late final _Font_GetDescent = _Font_GetDescentPtr.asFunction<
      int Function(FPDF_FONT, double, ffi.Pointer<ffi.Float>)>();

  /// Experimental API.
  /// Get the width of a glyph in a font.
  /// font       - the handle to the font object.
  /// glyph      - the glyph.
  /// font_size  - the size of the font.
  /// width      - pointer where the glyph width will be stored
  /// Glyph width is the distance from the end of the prior glyph to the next
  /// glyph. This will be the vertical distance for vertical writing.
  /// Returns TRUE on success; |width| unmodified on failure.
  int Font_GetGlyphWidth(
    FPDF_FONT font,
    int glyph,
    double font_size,
    ffi.Pointer<ffi.Float> width,
  ) {
    return _Font_GetGlyphWidth(
      font,
      glyph,
      font_size,
      width,
    );
  }

  late final _Font_GetGlyphWidthPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_FONT, ffi.Uint32, ffi.Float,
              ffi.Pointer<ffi.Float>)>>('PDFIUM_FPDFFont_GetGlyphWidth');
  late final _Font_GetGlyphWidth = _Font_GetGlyphWidthPtr.asFunction<
      int Function(FPDF_FONT, int, double, ffi.Pointer<ffi.Float>)>();

  /// Experimental API.
  /// Get the glyphpath describing how to draw a font glyph.
  /// font       - the handle to the font object.
  /// glyph      - the glyph being drawn.
  /// font_size  - the size of the font.
  /// Returns the handle to the segment, or NULL on faiure.
  FPDF_GLYPHPATH Font_GetGlyphPath(
    FPDF_FONT font,
    int glyph,
    double font_size,
  ) {
    return _Font_GetGlyphPath(
      font,
      glyph,
      font_size,
    );
  }

  late final _Font_GetGlyphPathPtr = _lookup<
      ffi.NativeFunction<
          FPDF_GLYPHPATH Function(FPDF_FONT, ffi.Uint32,
              ffi.Float)>>('PDFIUM_FPDFFont_GetGlyphPath');
  late final _Font_GetGlyphPath = _Font_GetGlyphPathPtr.asFunction<
      FPDF_GLYPHPATH Function(FPDF_FONT, int, double)>();

  /// Experimental API.
  /// Get number of segments inside glyphpath.
  /// glyphpath - handle to a glyph path.
  /// Returns the number of objects in |glyphpath| or -1 on failure.
  int GlyphPath_CountGlyphSegments(
    FPDF_GLYPHPATH glyphpath,
  ) {
    return _GlyphPath_CountGlyphSegments(
      glyphpath,
    );
  }

  late final _GlyphPath_CountGlyphSegmentsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_GLYPHPATH)>>(
          'PDFIUM_FPDFGlyphPath_CountGlyphSegments');
  late final _GlyphPath_CountGlyphSegments = _GlyphPath_CountGlyphSegmentsPtr
      .asFunction<int Function(FPDF_GLYPHPATH)>();

  /// Experimental API.
  /// Get segment in glyphpath at index.
  /// glyphpath  - handle to a glyph path.
  /// index      - the index of a segment.
  /// Returns the handle to the segment, or NULL on faiure.
  FPDF_PATHSEGMENT GlyphPath_GetGlyphPathSegment(
    FPDF_GLYPHPATH glyphpath,
    int index,
  ) {
    return _GlyphPath_GetGlyphPathSegment(
      glyphpath,
      index,
    );
  }

  late final _GlyphPath_GetGlyphPathSegmentPtr = _lookup<
          ffi
          .NativeFunction<FPDF_PATHSEGMENT Function(FPDF_GLYPHPATH, ffi.Int)>>(
      'PDFIUM_FPDFGlyphPath_GetGlyphPathSegment');
  late final _GlyphPath_GetGlyphPathSegment = _GlyphPath_GetGlyphPathSegmentPtr
      .asFunction<FPDF_PATHSEGMENT Function(FPDF_GLYPHPATH, int)>();

  /// Get number of page objects inside |form_object|.
  /// form_object - handle to a form object.
  /// Returns the number of objects in |form_object| on success, -1 on error.
  int FormObj_CountObjects(
    FPDF_PAGEOBJECT form_object,
  ) {
    return _FormObj_CountObjects(
      form_object,
    );
  }

  late final _FormObj_CountObjectsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGEOBJECT)>>(
          'PDFIUM_FPDFFormObj_CountObjects');
  late final _FormObj_CountObjects =
      _FormObj_CountObjectsPtr.asFunction<int Function(FPDF_PAGEOBJECT)>();

  /// Get page object in |form_object| at |index|.
  /// form_object - handle to a form object.
  /// index       - the 0-based index of a page object.
  /// Returns the handle to the page object, or NULL on error.
  FPDF_PAGEOBJECT FormObj_GetObject(
    FPDF_PAGEOBJECT form_object,
    int index,
  ) {
    return _FormObj_GetObject(
      form_object,
      index,
    );
  }

  late final _FormObj_GetObjectPtr = _lookup<
      ffi.NativeFunction<
          FPDF_PAGEOBJECT Function(FPDF_PAGEOBJECT,
              ffi.UnsignedLong)>>('PDFIUM_FPDFFormObj_GetObject');
  late final _FormObj_GetObject = _FormObj_GetObjectPtr.asFunction<
      FPDF_PAGEOBJECT Function(FPDF_PAGEOBJECT, int)>();

  /// Experimental API.
  /// Remove |page_object| from |form_object|.
  /// form_object - handle to a form object.
  /// page_object - handle to a page object to be removed from the form.
  /// Returns TRUE on success.
  /// Ownership of the removed |page_object| is transferred to the caller.
  /// Call FPDFPageObj_Destroy() on the removed page_object to free it.
  int FormObj_RemoveObject(
    FPDF_PAGEOBJECT form_object,
    FPDF_PAGEOBJECT page_object,
  ) {
    return _FormObj_RemoveObject(
      form_object,
      page_object,
    );
  }

  late final _FormObj_RemoveObjectPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGEOBJECT,
              FPDF_PAGEOBJECT)>>('PDFIUM_FPDFFormObj_RemoveObject');
  late final _FormObj_RemoveObject = _FormObj_RemoveObjectPtr.asFunction<
      int Function(FPDF_PAGEOBJECT, FPDF_PAGEOBJECT)>();

  /// Experimental API.
  /// Gets the decoded data from the thumbnail of |page| if it exists.
  /// This only modifies |buffer| if |buflen| less than or equal to the
  /// size of the decoded data. Returns the size of the decoded
  /// data or 0 if thumbnail DNE. Optional, pass null to just retrieve
  /// the size of the buffer needed.
  /// page    - handle to a page.
  /// buffer  - buffer for holding the decoded image data.
  /// buflen  - length of the buffer in bytes.
  int Page_GetDecodedThumbnailData(
    FPDF_PAGE page,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _Page_GetDecodedThumbnailData(
      page,
      buffer,
      buflen,
    );
  }

  late final _Page_GetDecodedThumbnailDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_PAGE, ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFPage_GetDecodedThumbnailData');
  late final _Page_GetDecodedThumbnailData = _Page_GetDecodedThumbnailDataPtr
      .asFunction<int Function(FPDF_PAGE, ffi.Pointer<ffi.Void>, int)>();

  /// Experimental API.
  /// Gets the raw data from the thumbnail of |page| if it exists.
  /// This only modifies |buffer| if |buflen| is less than or equal to
  /// the size of the raw data. Returns the size of the raw data or 0
  /// if thumbnail DNE. Optional, pass null to just retrieve the size
  /// of the buffer needed.
  /// page    - handle to a page.
  /// buffer  - buffer for holding the raw image data.
  /// buflen  - length of the buffer in bytes.
  int Page_GetRawThumbnailData(
    FPDF_PAGE page,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _Page_GetRawThumbnailData(
      page,
      buffer,
      buflen,
    );
  }

  late final _Page_GetRawThumbnailDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_PAGE, ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFPage_GetRawThumbnailData');
  late final _Page_GetRawThumbnailData = _Page_GetRawThumbnailDataPtr
      .asFunction<int Function(FPDF_PAGE, ffi.Pointer<ffi.Void>, int)>();

  /// Experimental API.
  /// Returns the thumbnail of |page| as a FPDF_BITMAP. Returns a nullptr
  /// if unable to access the thumbnail's stream.
  /// page - handle to a page.
  FPDF_BITMAP Page_GetThumbnailAsBitmap(
    FPDF_PAGE page,
  ) {
    return _Page_GetThumbnailAsBitmap(
      page,
    );
  }

  late final _Page_GetThumbnailAsBitmapPtr =
      _lookup<ffi.NativeFunction<FPDF_BITMAP Function(FPDF_PAGE)>>(
          'PDFIUM_FPDFPage_GetThumbnailAsBitmap');
  late final _Page_GetThumbnailAsBitmap = _Page_GetThumbnailAsBitmapPtr
      .asFunction<FPDF_BITMAP Function(FPDF_PAGE)>();

  /// Experimental API.
  /// Get the number of JavaScript actions in |document|.
  /// document - handle to a document.
  /// Returns the number of JavaScript actions in |document| or -1 on error.
  int Doc_GetJavaScriptActionCount(
    FPDF_DOCUMENT document,
  ) {
    return _Doc_GetJavaScriptActionCount(
      document,
    );
  }

  late final _Doc_GetJavaScriptActionCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDFDoc_GetJavaScriptActionCount');
  late final _Doc_GetJavaScriptActionCount = _Doc_GetJavaScriptActionCountPtr
      .asFunction<int Function(FPDF_DOCUMENT)>();

  /// Experimental API.
  /// Get the JavaScript action at |index| in |document|.
  /// document - handle to a document.
  /// index    - the index of the requested JavaScript action.
  /// Returns the handle to the JavaScript action, or NULL on failure.
  /// Caller owns the returned handle and must close it with
  /// FPDFDoc_CloseJavaScriptAction().
  FPDF_JAVASCRIPT_ACTION Doc_GetJavaScriptAction(
    FPDF_DOCUMENT document,
    int index,
  ) {
    return _Doc_GetJavaScriptAction(
      document,
      index,
    );
  }

  late final _Doc_GetJavaScriptActionPtr = _lookup<
      ffi.NativeFunction<
          FPDF_JAVASCRIPT_ACTION Function(
              FPDF_DOCUMENT, ffi.Int)>>('PDFIUM_FPDFDoc_GetJavaScriptAction');
  late final _Doc_GetJavaScriptAction = _Doc_GetJavaScriptActionPtr.asFunction<
      FPDF_JAVASCRIPT_ACTION Function(FPDF_DOCUMENT, int)>();

  /// javascript - Handle to a JavaScript action.
  void Doc_CloseJavaScriptAction(
    FPDF_JAVASCRIPT_ACTION javascript,
  ) {
    return _Doc_CloseJavaScriptAction(
      javascript,
    );
  }

  late final _Doc_CloseJavaScriptActionPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_JAVASCRIPT_ACTION)>>(
          'PDFIUM_FPDFDoc_CloseJavaScriptAction');
  late final _Doc_CloseJavaScriptAction = _Doc_CloseJavaScriptActionPtr
      .asFunction<void Function(FPDF_JAVASCRIPT_ACTION)>();

  /// Experimental API.
  /// Get the name from the |javascript| handle. |buffer| is only modified if
  /// |buflen| is longer than the length of the name. On errors, |buffer| is
  /// unmodified and the returned length is 0.
  /// javascript - handle to an JavaScript action.
  /// buffer     - buffer for holding the name, encoded in UTF-16LE.
  /// buflen     - length of the buffer in bytes.
  /// Returns the length of the JavaScript action name in bytes.
  int JavaScriptAction_GetName(
    FPDF_JAVASCRIPT_ACTION javascript,
    ffi.Pointer<FPDF_WCHAR> buffer,
    int buflen,
  ) {
    return _JavaScriptAction_GetName(
      javascript,
      buffer,
      buflen,
    );
  }

  late final _JavaScriptAction_GetNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_JAVASCRIPT_ACTION,
              ffi.Pointer<FPDF_WCHAR>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFJavaScriptAction_GetName');
  late final _JavaScriptAction_GetName =
      _JavaScriptAction_GetNamePtr.asFunction<
          int Function(FPDF_JAVASCRIPT_ACTION, ffi.Pointer<FPDF_WCHAR>, int)>();

  /// Experimental API.
  /// Get the script from the |javascript| handle. |buffer| is only modified if
  /// |buflen| is longer than the length of the script. On errors, |buffer| is
  /// unmodified and the returned length is 0.
  /// javascript - handle to an JavaScript action.
  /// buffer     - buffer for holding the name, encoded in UTF-16LE.
  /// buflen     - length of the buffer in bytes.
  /// Returns the length of the JavaScript action name in bytes.
  int JavaScriptAction_GetScript(
    FPDF_JAVASCRIPT_ACTION javascript,
    ffi.Pointer<FPDF_WCHAR> buffer,
    int buflen,
  ) {
    return _JavaScriptAction_GetScript(
      javascript,
      buffer,
      buflen,
    );
  }

  late final _JavaScriptAction_GetScriptPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_JAVASCRIPT_ACTION,
              ffi.Pointer<FPDF_WCHAR>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFJavaScriptAction_GetScript');
  late final _JavaScriptAction_GetScript =
      _JavaScriptAction_GetScriptPtr.asFunction<
          int Function(FPDF_JAVASCRIPT_ACTION, ffi.Pointer<FPDF_WCHAR>, int)>();

  /// Function: FPDF_GetDefaultTTFMap
  /// Returns a pointer to the default character set to TT Font name map. The
  /// map is an array of FPDF_CharsetFontMap structs, with its end indicated
  /// by a { -1, NULL } entry.
  /// Parameters:
  /// None.
  /// Return Value:
  /// Pointer to the Charset Font Map.
  /// Note:
  /// Once FPDF_GetDefaultTTFMapCount() and FPDF_GetDefaultTTFMapEntry() are no
  /// longer experimental, this API will be marked as deprecated.
  /// See https://crbug.com/348468114
  ffi.Pointer<FPDF_CharsetFontMap> GetDefaultTTFMap() {
    return _GetDefaultTTFMap();
  }

  late final _GetDefaultTTFMapPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<FPDF_CharsetFontMap> Function()>>(
          'PDFIUM_FPDF_GetDefaultTTFMap');
  late final _GetDefaultTTFMap = _GetDefaultTTFMapPtr.asFunction<
      ffi.Pointer<FPDF_CharsetFontMap> Function()>();

  /// Experimental API.
  /// Function: FPDF_GetDefaultTTFMapCount
  /// Returns the number of entries in the default character set to TT Font name
  /// map.
  /// Parameters:
  /// None.
  /// Return Value:
  /// The number of entries in the map.
  int GetDefaultTTFMapCount() {
    return _GetDefaultTTFMapCount();
  }

  late final _GetDefaultTTFMapCountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          'PDFIUM_FPDF_GetDefaultTTFMapCount');
  late final _GetDefaultTTFMapCount =
      _GetDefaultTTFMapCountPtr.asFunction<int Function()>();

  /// Experimental API.
  /// Function: FPDF_GetDefaultTTFMapEntry
  /// Returns an entry in the default character set to TT Font name map.
  /// Parameters:
  /// index    -   The index to the entry in the map to retrieve.
  /// Return Value:
  /// A pointer to the entry, if it is in the map, or NULL if the index is out
  /// of bounds.
  ffi.Pointer<FPDF_CharsetFontMap> GetDefaultTTFMapEntry(
    int index,
  ) {
    return _GetDefaultTTFMapEntry(
      index,
    );
  }

  late final _GetDefaultTTFMapEntryPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<FPDF_CharsetFontMap> Function(ffi.Size)>>(
      'PDFIUM_FPDF_GetDefaultTTFMapEntry');
  late final _GetDefaultTTFMapEntry = _GetDefaultTTFMapEntryPtr.asFunction<
      ffi.Pointer<FPDF_CharsetFontMap> Function(int)>();

  /// Function: FPDF_AddInstalledFont
  /// Add a system font to the list in PDFium.
  /// Comments:
  /// This function is only called during the system font list building
  /// process.
  /// Parameters:
  /// mapper          -   Opaque pointer to Foxit font mapper
  /// face            -   The font face name
  /// charset         -   Font character set. See above defined constants.
  /// Return Value:
  /// None.
  void AddInstalledFont(
    ffi.Pointer<ffi.Void> mapper,
    ffi.Pointer<ffi.Char> face,
    int charset,
  ) {
    return _AddInstalledFont(
      mapper,
      face,
      charset,
    );
  }

  late final _AddInstalledFontPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('PDFIUM_FPDF_AddInstalledFont');
  late final _AddInstalledFont = _AddInstalledFontPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int)>();

  /// Function: FPDF_SetSystemFontInfo
  /// Set the system font info interface into PDFium
  /// Parameters:
  /// font_info       -   Pointer to a FPDF_SYSFONTINFO structure
  /// Return Value:
  /// None
  /// Comments:
  /// Platform support implementation should implement required methods of
  /// FFDF_SYSFONTINFO interface, then call this function during PDFium
  /// initialization process.
  /// Call this with NULL to tell PDFium to stop using a previously set
  /// |FPDF_SYSFONTINFO|.
  void SetSystemFontInfo(
    ffi.Pointer<FPDF_SYSFONTINFO> font_info,
  ) {
    return _SetSystemFontInfo(
      font_info,
    );
  }

  late final _SetSystemFontInfoPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FPDF_SYSFONTINFO>)>>(
      'PDFIUM_FPDF_SetSystemFontInfo');
  late final _SetSystemFontInfo = _SetSystemFontInfoPtr.asFunction<
      void Function(ffi.Pointer<FPDF_SYSFONTINFO>)>();

  /// Function: FPDF_GetDefaultSystemFontInfo
  /// Get default system font info interface for current platform
  /// Parameters:
  /// None
  /// Return Value:
  /// Pointer to a FPDF_SYSFONTINFO structure describing the default
  /// interface, or NULL if the platform doesn't have a default interface.
  /// Application should call FPDF_FreeDefaultSystemFontInfo to free the
  /// returned pointer.
  /// Comments:
  /// For some platforms, PDFium implements a default version of system
  /// font info interface. The default implementation can be passed to
  /// FPDF_SetSystemFontInfo().
  ffi.Pointer<FPDF_SYSFONTINFO> GetDefaultSystemFontInfo() {
    return _GetDefaultSystemFontInfo();
  }

  late final _GetDefaultSystemFontInfoPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<FPDF_SYSFONTINFO> Function()>>(
          'PDFIUM_FPDF_GetDefaultSystemFontInfo');
  late final _GetDefaultSystemFontInfo = _GetDefaultSystemFontInfoPtr
      .asFunction<ffi.Pointer<FPDF_SYSFONTINFO> Function()>();

  /// Function: FPDF_FreeDefaultSystemFontInfo
  /// Free a default system font info interface
  /// Parameters:
  /// font_info       -   Pointer to a FPDF_SYSFONTINFO structure
  /// Return Value:
  /// None
  /// Comments:
  /// This function should be called on the output from
  /// FPDF_GetDefaultSystemFontInfo() once it is no longer needed.
  void FreeDefaultSystemFontInfo(
    ffi.Pointer<FPDF_SYSFONTINFO> font_info,
  ) {
    return _FreeDefaultSystemFontInfo(
      font_info,
    );
  }

  late final _FreeDefaultSystemFontInfoPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FPDF_SYSFONTINFO>)>>(
      'PDFIUM_FPDF_FreeDefaultSystemFontInfo');
  late final _FreeDefaultSystemFontInfo = _FreeDefaultSystemFontInfoPtr
      .asFunction<void Function(ffi.Pointer<FPDF_SYSFONTINFO>)>();

  /// Create a document availability provider.
  /// file_avail - pointer to file availability interface.
  /// file       - pointer to a file access interface.
  /// Returns a handle to the document availability provider, or NULL on error.
  /// FPDFAvail_Destroy() must be called when done with the availability provider.
  FPDF_AVAIL Avail_Create(
    ffi.Pointer<FX_FILEAVAIL> file_avail,
    ffi.Pointer<FPDF_FILEACCESS> file,
  ) {
    return _Avail_Create(
      file_avail,
      file,
    );
  }

  late final _Avail_CreatePtr = _lookup<
      ffi.NativeFunction<
          FPDF_AVAIL Function(ffi.Pointer<FX_FILEAVAIL>,
              ffi.Pointer<FPDF_FILEACCESS>)>>('PDFIUM_FPDFAvail_Create');
  late final _Avail_Create = _Avail_CreatePtr.asFunction<
      FPDF_AVAIL Function(
          ffi.Pointer<FX_FILEAVAIL>, ffi.Pointer<FPDF_FILEACCESS>)>();

  /// Destroy the |avail| document availability provider.
  /// avail - handle to document availability provider to be destroyed.
  void Avail_Destroy(
    FPDF_AVAIL avail,
  ) {
    return _Avail_Destroy(
      avail,
    );
  }

  late final _Avail_DestroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_AVAIL)>>(
          'PDFIUM_FPDFAvail_Destroy');
  late final _Avail_Destroy =
      _Avail_DestroyPtr.asFunction<void Function(FPDF_AVAIL)>();

  /// Checks if the document is ready for loading, if not, gets download hints.
  /// avail - handle to document availability provider.
  /// hints - pointer to a download hints interface.
  /// Returns one of:
  /// PDF_DATA_ERROR: A common error is returned. Data availability unknown.
  /// PDF_DATA_NOTAVAIL: Data not yet available.
  /// PDF_DATA_AVAIL: Data available.
  /// Applications should call this function whenever new data arrives, and process
  /// all the generated download hints, if any, until the function returns
  /// |PDF_DATA_ERROR| or |PDF_DATA_AVAIL|.
  /// if hints is nullptr, the function just check current document availability.
  /// Once all data is available, call FPDFAvail_GetDocument() to get a document
  /// handle.
  int Avail_IsDocAvail(
    FPDF_AVAIL avail,
    ffi.Pointer<FX_DOWNLOADHINTS> hints,
  ) {
    return _Avail_IsDocAvail(
      avail,
      hints,
    );
  }

  late final _Avail_IsDocAvailPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(FPDF_AVAIL,
              ffi.Pointer<FX_DOWNLOADHINTS>)>>('PDFIUM_FPDFAvail_IsDocAvail');
  late final _Avail_IsDocAvail = _Avail_IsDocAvailPtr.asFunction<
      int Function(FPDF_AVAIL, ffi.Pointer<FX_DOWNLOADHINTS>)>();

  /// Get document from the availability provider.
  /// avail    - handle to document availability provider.
  /// password - password for decrypting the PDF file. Optional.
  /// Returns a handle to the document.
  /// When FPDFAvail_IsDocAvail() returns TRUE, call FPDFAvail_GetDocument() to
  /// retrieve the document handle.
  /// See the comments for FPDF_LoadDocument() regarding the encoding for
  /// |password|.
  FPDF_DOCUMENT Avail_GetDocument(
    FPDF_AVAIL avail,
    FPDF_BYTESTRING password,
  ) {
    return _Avail_GetDocument(
      avail,
      password,
    );
  }

  late final _Avail_GetDocumentPtr = _lookup<
          ffi
          .NativeFunction<FPDF_DOCUMENT Function(FPDF_AVAIL, FPDF_BYTESTRING)>>(
      'PDFIUM_FPDFAvail_GetDocument');
  late final _Avail_GetDocument = _Avail_GetDocumentPtr.asFunction<
      FPDF_DOCUMENT Function(FPDF_AVAIL, FPDF_BYTESTRING)>();

  /// Get the page number for the first available page in a linearized PDF.
  /// doc - document handle.
  /// Returns the zero-based index for the first available page.
  /// For most linearized PDFs, the first available page will be the first page,
  /// however, some PDFs might make another page the first available page.
  /// For non-linearized PDFs, this function will always return zero.
  int Avail_GetFirstPageNum(
    FPDF_DOCUMENT doc,
  ) {
    return _Avail_GetFirstPageNum(
      doc,
    );
  }

  late final _Avail_GetFirstPageNumPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDFAvail_GetFirstPageNum');
  late final _Avail_GetFirstPageNum =
      _Avail_GetFirstPageNumPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Check if |page_index| is ready for loading, if not, get the
  /// |FX_DOWNLOADHINTS|.
  /// avail      - handle to document availability provider.
  /// page_index - index number of the page. Zero for the first page.
  /// hints      - pointer to a download hints interface. Populated if
  /// |page_index| is not available.
  /// Returns one of:
  /// PDF_DATA_ERROR: A common error is returned. Data availability unknown.
  /// PDF_DATA_NOTAVAIL: Data not yet available.
  /// PDF_DATA_AVAIL: Data available.
  /// This function can be called only after FPDFAvail_GetDocument() is called.
  /// Applications should call this function whenever new data arrives and process
  /// all the generated download |hints|, if any, until this function returns
  /// |PDF_DATA_ERROR| or |PDF_DATA_AVAIL|. Applications can then perform page
  /// loading.
  /// if hints is nullptr, the function just check current availability of
  /// specified page.
  int Avail_IsPageAvail(
    FPDF_AVAIL avail,
    int page_index,
    ffi.Pointer<FX_DOWNLOADHINTS> hints,
  ) {
    return _Avail_IsPageAvail(
      avail,
      page_index,
      hints,
    );
  }

  late final _Avail_IsPageAvailPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(FPDF_AVAIL, ffi.Int,
              ffi.Pointer<FX_DOWNLOADHINTS>)>>('PDFIUM_FPDFAvail_IsPageAvail');
  late final _Avail_IsPageAvail = _Avail_IsPageAvailPtr.asFunction<
      int Function(FPDF_AVAIL, int, ffi.Pointer<FX_DOWNLOADHINTS>)>();

  /// Check if form data is ready for initialization, if not, get the
  /// |FX_DOWNLOADHINTS|.
  /// avail - handle to document availability provider.
  /// hints - pointer to a download hints interface. Populated if form is not
  /// ready for initialization.
  /// Returns one of:
  /// PDF_FORM_ERROR: A common eror, in general incorrect parameters.
  /// PDF_FORM_NOTAVAIL: Data not available.
  /// PDF_FORM_AVAIL: Data available.
  /// PDF_FORM_NOTEXIST: No form data.
  /// This function can be called only after FPDFAvail_GetDocument() is called.
  /// The application should call this function whenever new data arrives and
  /// process all the generated download |hints|, if any, until the function
  /// |PDF_FORM_ERROR|, |PDF_FORM_AVAIL| or |PDF_FORM_NOTEXIST|.
  /// if hints is nullptr, the function just check current form availability.
  /// Applications can then perform page loading. It is recommend to call
  /// FPDFDOC_InitFormFillEnvironment() when |PDF_FORM_AVAIL| is returned.
  int Avail_IsFormAvail(
    FPDF_AVAIL avail,
    ffi.Pointer<FX_DOWNLOADHINTS> hints,
  ) {
    return _Avail_IsFormAvail(
      avail,
      hints,
    );
  }

  late final _Avail_IsFormAvailPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(FPDF_AVAIL,
              ffi.Pointer<FX_DOWNLOADHINTS>)>>('PDFIUM_FPDFAvail_IsFormAvail');
  late final _Avail_IsFormAvail = _Avail_IsFormAvailPtr.asFunction<
      int Function(FPDF_AVAIL, ffi.Pointer<FX_DOWNLOADHINTS>)>();

  /// Check whether a document is a linearized PDF.
  /// avail - handle to document availability provider.
  /// Returns one of:
  /// PDF_LINEARIZED
  /// PDF_NOT_LINEARIZED
  /// PDF_LINEARIZATION_UNKNOWN
  /// FPDFAvail_IsLinearized() will return |PDF_LINEARIZED| or |PDF_NOT_LINEARIZED|
  /// when we have 1k  of data. If the files size less than 1k, it returns
  /// |PDF_LINEARIZATION_UNKNOWN| as there is insufficient information to determine
  /// if the PDF is linearlized.
  int Avail_IsLinearized(
    FPDF_AVAIL avail,
  ) {
    return _Avail_IsLinearized(
      avail,
    );
  }

  late final _Avail_IsLinearizedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_AVAIL)>>(
          'PDFIUM_FPDFAvail_IsLinearized');
  late final _Avail_IsLinearized =
      _Avail_IsLinearizedPtr.asFunction<int Function(FPDF_AVAIL)>();

  /// Experimental API.
  /// Function: FPDF_RenderPageBitmapWithColorScheme_Start
  /// Start to render page contents to a device independent bitmap
  /// progressively with a specified color scheme for the content.
  /// Parameters:
  /// bitmap       -   Handle to the device independent bitmap (as the
  /// output buffer). Bitmap handle can be created by
  /// FPDFBitmap_Create function.
  /// page         -   Handle to the page as returned by FPDF_LoadPage
  /// function.
  /// start_x      -   Left pixel position of the display area in the
  /// bitmap coordinate.
  /// start_y      -   Top pixel position of the display area in the
  /// bitmap coordinate.
  /// size_x       -   Horizontal size (in pixels) for displaying the
  /// page.
  /// size_y       -   Vertical size (in pixels) for displaying the page.
  /// rotate       -   Page orientation: 0 (normal), 1 (rotated 90
  /// degrees clockwise), 2 (rotated 180 degrees),
  /// 3 (rotated 90 degrees counter-clockwise).
  /// flags        -   0 for normal display, or combination of flags
  /// defined in fpdfview.h. With FPDF_ANNOT flag, it
  /// renders all annotations that does not require
  /// user-interaction, which are all annotations except
  /// widget and popup annotations.
  /// color_scheme -   Color scheme to be used in rendering the |page|.
  /// If null, this function will work similar to
  /// FPDF_RenderPageBitmap_Start().
  /// pause        -   The IFSDK_PAUSE interface. A callback mechanism
  /// allowing the page rendering process.
  /// Return value:
  /// Rendering Status. See flags for progressive process status for the
  /// details.
  int RenderPageBitmapWithColorScheme_Start(
    FPDF_BITMAP bitmap,
    FPDF_PAGE page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    int flags,
    ffi.Pointer<FPDF_COLORSCHEME> color_scheme,
    ffi.Pointer<IFSDK_PAUSE> pause,
  ) {
    return _RenderPageBitmapWithColorScheme_Start(
      bitmap,
      page,
      start_x,
      start_y,
      size_x,
      size_y,
      rotate,
      flags,
      color_scheme,
      pause,
    );
  }

  late final _RenderPageBitmapWithColorScheme_StartPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  FPDF_BITMAP,
                  FPDF_PAGE,
                  ffi.Int,
                  ffi.Int,
                  ffi.Int,
                  ffi.Int,
                  ffi.Int,
                  ffi.Int,
                  ffi.Pointer<FPDF_COLORSCHEME>,
                  ffi.Pointer<IFSDK_PAUSE>)>>(
      'PDFIUM_FPDF_RenderPageBitmapWithColorScheme_Start');
  late final _RenderPageBitmapWithColorScheme_Start =
      _RenderPageBitmapWithColorScheme_StartPtr.asFunction<
          int Function(FPDF_BITMAP, FPDF_PAGE, int, int, int, int, int, int,
              ffi.Pointer<FPDF_COLORSCHEME>, ffi.Pointer<IFSDK_PAUSE>)>();

  /// Function: FPDF_RenderPageBitmap_Start
  /// Start to render page contents to a device independent bitmap
  /// progressively.
  /// Parameters:
  /// bitmap      -   Handle to the device independent bitmap (as the
  /// output buffer). Bitmap handle can be created by
  /// FPDFBitmap_Create().
  /// page        -   Handle to the page, as returned by FPDF_LoadPage().
  /// start_x     -   Left pixel position of the display area in the
  /// bitmap coordinates.
  /// start_y     -   Top pixel position of the display area in the bitmap
  /// coordinates.
  /// size_x      -   Horizontal size (in pixels) for displaying the page.
  /// size_y      -   Vertical size (in pixels) for displaying the page.
  /// rotate      -   Page orientation: 0 (normal), 1 (rotated 90 degrees
  /// clockwise), 2 (rotated 180 degrees), 3 (rotated 90
  /// degrees counter-clockwise).
  /// flags       -   0 for normal display, or combination of flags
  /// defined in fpdfview.h. With FPDF_ANNOT flag, it
  /// renders all annotations that does not require
  /// user-interaction, which are all annotations except
  /// widget and popup annotations.
  /// pause       -   The IFSDK_PAUSE interface.A callback mechanism
  /// allowing the page rendering process
  /// Return value:
  /// Rendering Status. See flags for progressive process status for the
  /// details.
  int RenderPageBitmap_Start(
    FPDF_BITMAP bitmap,
    FPDF_PAGE page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    int flags,
    ffi.Pointer<IFSDK_PAUSE> pause,
  ) {
    return _RenderPageBitmap_Start(
      bitmap,
      page,
      start_x,
      start_y,
      size_x,
      size_y,
      rotate,
      flags,
      pause,
    );
  }

  late final _RenderPageBitmap_StartPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              FPDF_BITMAP,
              FPDF_PAGE,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<IFSDK_PAUSE>)>>('PDFIUM_FPDF_RenderPageBitmap_Start');
  late final _RenderPageBitmap_Start = _RenderPageBitmap_StartPtr.asFunction<
      int Function(FPDF_BITMAP, FPDF_PAGE, int, int, int, int, int, int,
          ffi.Pointer<IFSDK_PAUSE>)>();

  /// Function: FPDF_RenderPage_Continue
  /// Continue rendering a PDF page.
  /// Parameters:
  /// page        -   Handle to the page, as returned by FPDF_LoadPage().
  /// pause       -   The IFSDK_PAUSE interface (a callback mechanism
  /// allowing the page rendering process to be paused
  /// before it's finished). This can be NULL if you
  /// don't want to pause.
  /// Return value:
  /// The rendering status. See flags for progressive process status for
  /// the details.
  int RenderPage_Continue(
    FPDF_PAGE page,
    ffi.Pointer<IFSDK_PAUSE> pause,
  ) {
    return _RenderPage_Continue(
      page,
      pause,
    );
  }

  late final _RenderPage_ContinuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(FPDF_PAGE,
              ffi.Pointer<IFSDK_PAUSE>)>>('PDFIUM_FPDF_RenderPage_Continue');
  late final _RenderPage_Continue = _RenderPage_ContinuePtr.asFunction<
      int Function(FPDF_PAGE, ffi.Pointer<IFSDK_PAUSE>)>();

  /// Function: FPDF_RenderPage_Close
  /// Release the resource allocate during page rendering. Need to be
  /// called after finishing rendering or
  /// cancel the rendering.
  /// Parameters:
  /// page        -   Handle to the page, as returned by FPDF_LoadPage().
  /// Return value:
  /// None.
  void RenderPage_Close(
    FPDF_PAGE page,
  ) {
    return _RenderPage_Close(
      page,
    );
  }

  late final _RenderPage_ClosePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_PAGE)>>(
          'PDFIUM_FPDF_RenderPage_Close');
  late final _RenderPage_Close =
      _RenderPage_ClosePtr.asFunction<void Function(FPDF_PAGE)>();

  /// Function: FPDFText_LoadPage
  /// Prepare information about all characters in a page.
  /// Parameters:
  /// page    -   Handle to the page. Returned by FPDF_LoadPage function
  /// (in FPDFVIEW module).
  /// Return value:
  /// A handle to the text page information structure.
  /// NULL if something goes wrong.
  /// Comments:
  /// Application must call FPDFText_ClosePage to release the text page
  /// information.
  FPDF_TEXTPAGE Text_LoadPage(
    FPDF_PAGE page,
  ) {
    return _Text_LoadPage(
      page,
    );
  }

  late final _Text_LoadPagePtr =
      _lookup<ffi.NativeFunction<FPDF_TEXTPAGE Function(FPDF_PAGE)>>(
          'PDFIUM_FPDFText_LoadPage');
  late final _Text_LoadPage =
      _Text_LoadPagePtr.asFunction<FPDF_TEXTPAGE Function(FPDF_PAGE)>();

  /// Function: FPDFText_ClosePage
  /// Release all resources allocated for a text page information
  /// structure.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// Return Value:
  /// None.
  void Text_ClosePage(
    FPDF_TEXTPAGE text_page,
  ) {
    return _Text_ClosePage(
      text_page,
    );
  }

  late final _Text_ClosePagePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_TEXTPAGE)>>(
          'PDFIUM_FPDFText_ClosePage');
  late final _Text_ClosePage =
      _Text_ClosePagePtr.asFunction<void Function(FPDF_TEXTPAGE)>();

  /// Function: FPDFText_CountChars
  /// Get number of characters in a page.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// Return value:
  /// Number of characters in the page. Return -1 for error.
  /// Generated characters, like additional space characters, new line
  /// characters, are also counted.
  /// Comments:
  /// Characters in a page form a "stream", inside the stream, each
  /// character has an index.
  /// We will use the index parameters in many of FPDFTEXT functions. The
  /// first character in the page
  /// has an index value of zero.
  int Text_CountChars(
    FPDF_TEXTPAGE text_page,
  ) {
    return _Text_CountChars(
      text_page,
    );
  }

  late final _Text_CountCharsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_TEXTPAGE)>>(
          'PDFIUM_FPDFText_CountChars');
  late final _Text_CountChars =
      _Text_CountCharsPtr.asFunction<int Function(FPDF_TEXTPAGE)>();

  /// Function: FPDFText_GetUnicode
  /// Get Unicode of a character in a page.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// Return value:
  /// The Unicode of the particular character.
  /// If a character is not encoded in Unicode and Foxit engine can't
  /// convert to Unicode,
  /// the return value will be zero.
  int Text_GetUnicode(
    FPDF_TEXTPAGE text_page,
    int index,
  ) {
    return _Text_GetUnicode(
      text_page,
      index,
    );
  }

  late final _Text_GetUnicodePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(FPDF_TEXTPAGE, ffi.Int)>>(
      'PDFIUM_FPDFText_GetUnicode');
  late final _Text_GetUnicode =
      _Text_GetUnicodePtr.asFunction<int Function(FPDF_TEXTPAGE, int)>();

  /// Experimental API.
  /// Function: FPDFText_GetTextObject
  /// Get the FPDF_PAGEOBJECT associated with a given character.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// Return value:
  /// The associated text object for the character at |index|, or NULL on
  /// error. The returned text object, if non-null, is of type
  /// |FPDF_PAGEOBJ_TEXT|. The caller does not own the returned object.
  FPDF_PAGEOBJECT Text_GetTextObject(
    FPDF_TEXTPAGE text_page,
    int index,
  ) {
    return _Text_GetTextObject(
      text_page,
      index,
    );
  }

  late final _Text_GetTextObjectPtr = _lookup<
          ffi.NativeFunction<FPDF_PAGEOBJECT Function(FPDF_TEXTPAGE, ffi.Int)>>(
      'PDFIUM_FPDFText_GetTextObject');
  late final _Text_GetTextObject = _Text_GetTextObjectPtr.asFunction<
      FPDF_PAGEOBJECT Function(FPDF_TEXTPAGE, int)>();

  /// Experimental API.
  /// Function: FPDFText_IsGenerated
  /// Get if a character in a page is generated by PDFium.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// Return value:
  /// 1 if the character is generated by PDFium.
  /// 0 if the character is not generated by PDFium.
  /// -1 if there was an error.
  int Text_IsGenerated(
    FPDF_TEXTPAGE text_page,
    int index,
  ) {
    return _Text_IsGenerated(
      text_page,
      index,
    );
  }

  late final _Text_IsGeneratedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_TEXTPAGE, ffi.Int)>>(
          'PDFIUM_FPDFText_IsGenerated');
  late final _Text_IsGenerated =
      _Text_IsGeneratedPtr.asFunction<int Function(FPDF_TEXTPAGE, int)>();

  /// Experimental API.
  /// Function: FPDFText_IsHyphen
  /// Get if a character in a page is a hyphen.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// Return value:
  /// 1 if the character is a hyphen.
  /// 0 if the character is not a hyphen.
  /// -1 if there was an error.
  int Text_IsHyphen(
    FPDF_TEXTPAGE text_page,
    int index,
  ) {
    return _Text_IsHyphen(
      text_page,
      index,
    );
  }

  late final _Text_IsHyphenPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_TEXTPAGE, ffi.Int)>>(
          'PDFIUM_FPDFText_IsHyphen');
  late final _Text_IsHyphen =
      _Text_IsHyphenPtr.asFunction<int Function(FPDF_TEXTPAGE, int)>();

  /// Experimental API.
  /// Function: FPDFText_HasUnicodeMapError
  /// Get if a character in a page has an invalid unicode mapping.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// Return value:
  /// 1 if the character has an invalid unicode mapping.
  /// 0 if the character has no known unicode mapping issues.
  /// -1 if there was an error.
  int Text_HasUnicodeMapError(
    FPDF_TEXTPAGE text_page,
    int index,
  ) {
    return _Text_HasUnicodeMapError(
      text_page,
      index,
    );
  }

  late final _Text_HasUnicodeMapErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_TEXTPAGE, ffi.Int)>>(
          'PDFIUM_FPDFText_HasUnicodeMapError');
  late final _Text_HasUnicodeMapError = _Text_HasUnicodeMapErrorPtr.asFunction<
      int Function(FPDF_TEXTPAGE, int)>();

  /// Function: FPDFText_GetFontSize
  /// Get the font size of a particular character.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// Return value:
  /// The font size of the particular character, measured in points (about
  /// 1/72 inch). This is the typographic size of the font (so called
  /// "em size").
  double Text_GetFontSize(
    FPDF_TEXTPAGE text_page,
    int index,
  ) {
    return _Text_GetFontSize(
      text_page,
      index,
    );
  }

  late final _Text_GetFontSizePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(FPDF_TEXTPAGE, ffi.Int)>>(
          'PDFIUM_FPDFText_GetFontSize');
  late final _Text_GetFontSize =
      _Text_GetFontSizePtr.asFunction<double Function(FPDF_TEXTPAGE, int)>();

  /// Experimental API.
  /// Function: FPDFText_GetFontInfo
  /// Get the font name and flags of a particular character.
  /// Parameters:
  /// text_page - Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index     - Zero-based index of the character.
  /// buffer    - A buffer receiving the font name.
  /// buflen    - The length of |buffer| in bytes.
  /// flags     - Optional pointer to an int receiving the font flags.
  /// These flags should be interpreted per PDF spec 1.7
  /// Section 5.7.1 Font Descriptor Flags.
  /// Return value:
  /// On success, return the length of the font name, including the
  /// trailing NUL character, in bytes. If this length is less than or
  /// equal to |length|, |buffer| is set to the font name, |flags| is
  /// set to the font flags. |buffer| is in UTF-8 encoding. Return 0 on
  /// failure.
  int Text_GetFontInfo(
    FPDF_TEXTPAGE text_page,
    int index,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
    ffi.Pointer<ffi.Int> flags,
  ) {
    return _Text_GetFontInfo(
      text_page,
      index,
      buffer,
      buflen,
      flags,
    );
  }

  late final _Text_GetFontInfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_TEXTPAGE,
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Int>)>>('PDFIUM_FPDFText_GetFontInfo');
  late final _Text_GetFontInfo = _Text_GetFontInfoPtr.asFunction<
      int Function(FPDF_TEXTPAGE, int, ffi.Pointer<ffi.Void>, int,
          ffi.Pointer<ffi.Int>)>();

  /// Experimental API.
  /// Function: FPDFText_GetFontWeight
  /// Get the font weight of a particular character.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// Return value:
  /// On success, return the font weight of the particular character. If
  /// |text_page| is invalid, if |index| is out of bounds, or if the
  /// character's text object is undefined, return -1.
  int Text_GetFontWeight(
    FPDF_TEXTPAGE text_page,
    int index,
  ) {
    return _Text_GetFontWeight(
      text_page,
      index,
    );
  }

  late final _Text_GetFontWeightPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_TEXTPAGE, ffi.Int)>>(
          'PDFIUM_FPDFText_GetFontWeight');
  late final _Text_GetFontWeight =
      _Text_GetFontWeightPtr.asFunction<int Function(FPDF_TEXTPAGE, int)>();

  /// Experimental API.
  /// Function: FPDFText_GetFillColor
  /// Get the fill color of a particular character.
  /// Parameters:
  /// text_page      -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index          -   Zero-based index of the character.
  /// R              -   Pointer to an unsigned int number receiving the
  /// red value of the fill color.
  /// G              -   Pointer to an unsigned int number receiving the
  /// green value of the fill color.
  /// B              -   Pointer to an unsigned int number receiving the
  /// blue value of the fill color.
  /// A              -   Pointer to an unsigned int number receiving the
  /// alpha value of the fill color.
  /// Return value:
  /// Whether the call succeeded. If false, |R|, |G|, |B| and |A| are
  /// unchanged.
  int Text_GetFillColor(
    FPDF_TEXTPAGE text_page,
    int index,
    ffi.Pointer<ffi.UnsignedInt> R,
    ffi.Pointer<ffi.UnsignedInt> G,
    ffi.Pointer<ffi.UnsignedInt> B,
    ffi.Pointer<ffi.UnsignedInt> A,
  ) {
    return _Text_GetFillColor(
      text_page,
      index,
      R,
      G,
      B,
      A,
    );
  }

  late final _Text_GetFillColorPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_TEXTPAGE,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>)>>('PDFIUM_FPDFText_GetFillColor');
  late final _Text_GetFillColor = _Text_GetFillColorPtr.asFunction<
      int Function(
          FPDF_TEXTPAGE,
          int,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// Experimental API.
  /// Function: FPDFText_GetStrokeColor
  /// Get the stroke color of a particular character.
  /// Parameters:
  /// text_page      -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index          -   Zero-based index of the character.
  /// R              -   Pointer to an unsigned int number receiving the
  /// red value of the stroke color.
  /// G              -   Pointer to an unsigned int number receiving the
  /// green value of the stroke color.
  /// B              -   Pointer to an unsigned int number receiving the
  /// blue value of the stroke color.
  /// A              -   Pointer to an unsigned int number receiving the
  /// alpha value of the stroke color.
  /// Return value:
  /// Whether the call succeeded. If false, |R|, |G|, |B| and |A| are
  /// unchanged.
  int Text_GetStrokeColor(
    FPDF_TEXTPAGE text_page,
    int index,
    ffi.Pointer<ffi.UnsignedInt> R,
    ffi.Pointer<ffi.UnsignedInt> G,
    ffi.Pointer<ffi.UnsignedInt> B,
    ffi.Pointer<ffi.UnsignedInt> A,
  ) {
    return _Text_GetStrokeColor(
      text_page,
      index,
      R,
      G,
      B,
      A,
    );
  }

  late final _Text_GetStrokeColorPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_TEXTPAGE,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>)>>('PDFIUM_FPDFText_GetStrokeColor');
  late final _Text_GetStrokeColor = _Text_GetStrokeColorPtr.asFunction<
      int Function(
          FPDF_TEXTPAGE,
          int,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// Experimental API.
  /// Function: FPDFText_GetCharAngle
  /// Get character rotation angle.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// Return Value:
  /// On success, return the angle value in radian. Value will always be
  /// greater or equal to 0. If |text_page| is invalid, or if |index| is
  /// out of bounds, then return -1.
  double Text_GetCharAngle(
    FPDF_TEXTPAGE text_page,
    int index,
  ) {
    return _Text_GetCharAngle(
      text_page,
      index,
    );
  }

  late final _Text_GetCharAnglePtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(FPDF_TEXTPAGE, ffi.Int)>>(
          'PDFIUM_FPDFText_GetCharAngle');
  late final _Text_GetCharAngle =
      _Text_GetCharAnglePtr.asFunction<double Function(FPDF_TEXTPAGE, int)>();

  /// Function: FPDFText_GetCharBox
  /// Get bounding box of a particular character.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// left        -   Pointer to a double number receiving left position
  /// of the character box.
  /// right       -   Pointer to a double number receiving right position
  /// of the character box.
  /// bottom      -   Pointer to a double number receiving bottom position
  /// of the character box.
  /// top         -   Pointer to a double number receiving top position of
  /// the character box.
  /// Return Value:
  /// On success, return TRUE and fill in |left|, |right|, |bottom|, and
  /// |top|. If |text_page| is invalid, or if |index| is out of bounds,
  /// then return FALSE, and the out parameters remain unmodified.
  /// Comments:
  /// All positions are measured in PDF "user space".
  int Text_GetCharBox(
    FPDF_TEXTPAGE text_page,
    int index,
    ffi.Pointer<ffi.Double> left,
    ffi.Pointer<ffi.Double> right,
    ffi.Pointer<ffi.Double> bottom,
    ffi.Pointer<ffi.Double> top,
  ) {
    return _Text_GetCharBox(
      text_page,
      index,
      left,
      right,
      bottom,
      top,
    );
  }

  late final _Text_GetCharBoxPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_TEXTPAGE,
              ffi.Int,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>)>>('PDFIUM_FPDFText_GetCharBox');
  late final _Text_GetCharBox = _Text_GetCharBoxPtr.asFunction<
      int Function(
          FPDF_TEXTPAGE,
          int,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>)>();

  /// Experimental API.
  /// Function: FPDFText_GetLooseCharBox
  /// Get a "loose" bounding box of a particular character, i.e., covering
  /// the entire glyph bounds, without taking the actual glyph shape into
  /// account.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// rect        -   Pointer to a FS_RECTF receiving the character box.
  /// Return Value:
  /// On success, return TRUE and fill in |rect|. If |text_page| is
  /// invalid, or if |index| is out of bounds, then return FALSE, and the
  /// |rect| out parameter remains unmodified.
  /// Comments:
  /// All positions are measured in PDF "user space".
  int Text_GetLooseCharBox(
    FPDF_TEXTPAGE text_page,
    int index,
    ffi.Pointer<FS_RECTF> rect,
  ) {
    return _Text_GetLooseCharBox(
      text_page,
      index,
      rect,
    );
  }

  late final _Text_GetLooseCharBoxPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_TEXTPAGE, ffi.Int,
              ffi.Pointer<FS_RECTF>)>>('PDFIUM_FPDFText_GetLooseCharBox');
  late final _Text_GetLooseCharBox = _Text_GetLooseCharBoxPtr.asFunction<
      int Function(FPDF_TEXTPAGE, int, ffi.Pointer<FS_RECTF>)>();

  /// Experimental API.
  /// Function: FPDFText_GetMatrix
  /// Get the effective transformation matrix for a particular character.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage().
  /// index       -   Zero-based index of the character.
  /// matrix      -   Pointer to a FS_MATRIX receiving the transformation
  /// matrix.
  /// Return Value:
  /// On success, return TRUE and fill in |matrix|. If |text_page| is
  /// invalid, or if |index| is out of bounds, or if |matrix| is NULL,
  /// then return FALSE, and |matrix| remains unmodified.
  int Text_GetMatrix(
    FPDF_TEXTPAGE text_page,
    int index,
    ffi.Pointer<FS_MATRIX> matrix,
  ) {
    return _Text_GetMatrix(
      text_page,
      index,
      matrix,
    );
  }

  late final _Text_GetMatrixPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_TEXTPAGE, ffi.Int,
              ffi.Pointer<FS_MATRIX>)>>('PDFIUM_FPDFText_GetMatrix');
  late final _Text_GetMatrix = _Text_GetMatrixPtr.asFunction<
      int Function(FPDF_TEXTPAGE, int, ffi.Pointer<FS_MATRIX>)>();

  /// Function: FPDFText_GetCharOrigin
  /// Get origin of a particular character.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// x           -   Pointer to a double number receiving x coordinate of
  /// the character origin.
  /// y           -   Pointer to a double number receiving y coordinate of
  /// the character origin.
  /// Return Value:
  /// Whether the call succeeded. If false, x and y are unchanged.
  /// Comments:
  /// All positions are measured in PDF "user space".
  int Text_GetCharOrigin(
    FPDF_TEXTPAGE text_page,
    int index,
    ffi.Pointer<ffi.Double> x,
    ffi.Pointer<ffi.Double> y,
  ) {
    return _Text_GetCharOrigin(
      text_page,
      index,
      x,
      y,
    );
  }

  late final _Text_GetCharOriginPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_TEXTPAGE, ffi.Int, ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>)>>('PDFIUM_FPDFText_GetCharOrigin');
  late final _Text_GetCharOrigin = _Text_GetCharOriginPtr.asFunction<
      int Function(FPDF_TEXTPAGE, int, ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>)>();

  /// Function: FPDFText_GetCharIndexAtPos
  /// Get the index of a character at or nearby a certain position on the
  /// page.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// x           -   X position in PDF "user space".
  /// y           -   Y position in PDF "user space".
  /// xTolerance  -   An x-axis tolerance value for character hit
  /// detection, in point units.
  /// yTolerance  -   A y-axis tolerance value for character hit
  /// detection, in point units.
  /// Return Value:
  /// The zero-based index of the character at, or nearby the point (x,y).
  /// If there is no character at or nearby the point, return value will
  /// be -1. If an error occurs, -3 will be returned.
  int Text_GetCharIndexAtPos(
    FPDF_TEXTPAGE text_page,
    double x,
    double y,
    double xTolerance,
    double yTolerance,
  ) {
    return _Text_GetCharIndexAtPos(
      text_page,
      x,
      y,
      xTolerance,
      yTolerance,
    );
  }

  late final _Text_GetCharIndexAtPosPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(FPDF_TEXTPAGE, ffi.Double, ffi.Double, ffi.Double,
              ffi.Double)>>('PDFIUM_FPDFText_GetCharIndexAtPos');
  late final _Text_GetCharIndexAtPos = _Text_GetCharIndexAtPosPtr.asFunction<
      int Function(FPDF_TEXTPAGE, double, double, double, double)>();

  /// Function: FPDFText_GetText
  /// Extract unicode text string from the page.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// start_index -   Index for the start characters.
  /// count       -   Number of UCS-2 values to be extracted.
  /// result      -   A buffer (allocated by application) receiving the
  /// extracted UCS-2 values. The buffer must be able to
  /// hold `count` UCS-2 values plus a terminator.
  /// Return Value:
  /// Number of characters written into the result buffer, including the
  /// trailing terminator.
  /// Comments:
  /// This function ignores characters without UCS-2 representations.
  /// It considers all characters on the page, even those that are not
  /// visible when the page has a cropbox. To filter out the characters
  /// outside of the cropbox, use FPDF_GetPageBoundingBox() and
  /// FPDFText_GetCharBox().
  int Text_GetText(
    FPDF_TEXTPAGE text_page,
    int start_index,
    int count,
    ffi.Pointer<ffi.UnsignedShort> result,
  ) {
    return _Text_GetText(
      text_page,
      start_index,
      count,
      result,
    );
  }

  late final _Text_GetTextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(FPDF_TEXTPAGE, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.UnsignedShort>)>>('PDFIUM_FPDFText_GetText');
  late final _Text_GetText = _Text_GetTextPtr.asFunction<
      int Function(FPDF_TEXTPAGE, int, int, ffi.Pointer<ffi.UnsignedShort>)>();

  /// Function: FPDFText_CountRects
  /// Counts number of rectangular areas occupied by a segment of text,
  /// and caches the result for subsequent FPDFText_GetRect() calls.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// start_index -   Index for the start character.
  /// count       -   Number of characters, or -1 for all remaining.
  /// Return value:
  /// Number of rectangles, 0 if text_page is null, or -1 on bad
  /// start_index.
  /// Comments:
  /// This function, along with FPDFText_GetRect can be used by
  /// applications to detect the position on the page for a text segment,
  /// so proper areas can be highlighted. The FPDFText_* functions will
  /// automatically merge small character boxes into bigger one if those
  /// characters are on the same line and use same font settings.
  int Text_CountRects(
    FPDF_TEXTPAGE text_page,
    int start_index,
    int count,
  ) {
    return _Text_CountRects(
      text_page,
      start_index,
      count,
    );
  }

  late final _Text_CountRectsPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(FPDF_TEXTPAGE, ffi.Int, ffi.Int)>>(
      'PDFIUM_FPDFText_CountRects');
  late final _Text_CountRects =
      _Text_CountRectsPtr.asFunction<int Function(FPDF_TEXTPAGE, int, int)>();

  /// Function: FPDFText_GetRect
  /// Get a rectangular area from the result generated by
  /// FPDFText_CountRects.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// rect_index  -   Zero-based index for the rectangle.
  /// left        -   Pointer to a double value receiving the rectangle
  /// left boundary.
  /// top         -   Pointer to a double value receiving the rectangle
  /// top boundary.
  /// right       -   Pointer to a double value receiving the rectangle
  /// right boundary.
  /// bottom      -   Pointer to a double value receiving the rectangle
  /// bottom boundary.
  /// Return Value:
  /// On success, return TRUE and fill in |left|, |top|, |right|, and
  /// |bottom|. If |text_page| is invalid then return FALSE, and the out
  /// parameters remain unmodified. If |text_page| is valid but
  /// |rect_index| is out of bounds, then return FALSE and set the out
  /// parameters to 0.
  int Text_GetRect(
    FPDF_TEXTPAGE text_page,
    int rect_index,
    ffi.Pointer<ffi.Double> left,
    ffi.Pointer<ffi.Double> top,
    ffi.Pointer<ffi.Double> right,
    ffi.Pointer<ffi.Double> bottom,
  ) {
    return _Text_GetRect(
      text_page,
      rect_index,
      left,
      top,
      right,
      bottom,
    );
  }

  late final _Text_GetRectPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_TEXTPAGE,
              ffi.Int,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>)>>('PDFIUM_FPDFText_GetRect');
  late final _Text_GetRect = _Text_GetRectPtr.asFunction<
      int Function(
          FPDF_TEXTPAGE,
          int,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>)>();

  /// Function: FPDFText_GetBoundedText
  /// Extract unicode text within a rectangular boundary on the page.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// left        -   Left boundary.
  /// top         -   Top boundary.
  /// right       -   Right boundary.
  /// bottom      -   Bottom boundary.
  /// buffer      -   Caller-allocated buffer to receive UTF-16 values.
  /// buflen      -   Number of UTF-16 values (not bytes) that `buffer`
  /// is capable of holding.
  /// Return Value:
  /// If buffer is NULL or buflen is zero, return number of UTF-16
  /// values (not bytes) of text present within the rectangle, excluding
  /// a terminating NUL. Generally you should pass a buffer at least one
  /// larger than this if you want a terminating NUL, which will be
  /// provided if space is available. Otherwise, return number of UTF-16
  /// values copied into the buffer, including the terminating NUL when
  /// space for it is available.
  /// Comment:
  /// If the buffer is too small, as much text as will fit is copied into
  /// it. May return a split surrogate in that case.
  int Text_GetBoundedText(
    FPDF_TEXTPAGE text_page,
    double left,
    double top,
    double right,
    double bottom,
    ffi.Pointer<ffi.UnsignedShort> buffer,
    int buflen,
  ) {
    return _Text_GetBoundedText(
      text_page,
      left,
      top,
      right,
      bottom,
      buffer,
      buflen,
    );
  }

  late final _Text_GetBoundedTextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              FPDF_TEXTPAGE,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Pointer<ffi.UnsignedShort>,
              ffi.Int)>>('PDFIUM_FPDFText_GetBoundedText');
  late final _Text_GetBoundedText = _Text_GetBoundedTextPtr.asFunction<
      int Function(FPDF_TEXTPAGE, double, double, double, double,
          ffi.Pointer<ffi.UnsignedShort>, int)>();

  /// Function: FPDFText_FindStart
  /// Start a search.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// findwhat    -   A unicode match pattern.
  /// flags       -   Option flags.
  /// start_index -   Start from this character. -1 for end of the page.
  /// Return Value:
  /// A handle for the search context. FPDFText_FindClose must be called
  /// to release this handle.
  FPDF_SCHHANDLE Text_FindStart(
    FPDF_TEXTPAGE text_page,
    FPDF_WIDESTRING findwhat,
    int flags,
    int start_index,
  ) {
    return _Text_FindStart(
      text_page,
      findwhat,
      flags,
      start_index,
    );
  }

  late final _Text_FindStartPtr = _lookup<
      ffi.NativeFunction<
          FPDF_SCHHANDLE Function(FPDF_TEXTPAGE, FPDF_WIDESTRING,
              ffi.UnsignedLong, ffi.Int)>>('PDFIUM_FPDFText_FindStart');
  late final _Text_FindStart = _Text_FindStartPtr.asFunction<
      FPDF_SCHHANDLE Function(FPDF_TEXTPAGE, FPDF_WIDESTRING, int, int)>();

  /// Function: FPDFText_FindNext
  /// Search in the direction from page start to end.
  /// Parameters:
  /// handle      -   A search context handle returned by
  /// FPDFText_FindStart.
  /// Return Value:
  /// Whether a match is found.
  int Text_FindNext(
    FPDF_SCHHANDLE handle,
  ) {
    return _Text_FindNext(
      handle,
    );
  }

  late final _Text_FindNextPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_SCHHANDLE)>>(
          'PDFIUM_FPDFText_FindNext');
  late final _Text_FindNext =
      _Text_FindNextPtr.asFunction<int Function(FPDF_SCHHANDLE)>();

  /// Function: FPDFText_FindPrev
  /// Search in the direction from page end to start.
  /// Parameters:
  /// handle      -   A search context handle returned by
  /// FPDFText_FindStart.
  /// Return Value:
  /// Whether a match is found.
  int Text_FindPrev(
    FPDF_SCHHANDLE handle,
  ) {
    return _Text_FindPrev(
      handle,
    );
  }

  late final _Text_FindPrevPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_SCHHANDLE)>>(
          'PDFIUM_FPDFText_FindPrev');
  late final _Text_FindPrev =
      _Text_FindPrevPtr.asFunction<int Function(FPDF_SCHHANDLE)>();

  /// Function: FPDFText_GetSchResultIndex
  /// Get the starting character index of the search result.
  /// Parameters:
  /// handle      -   A search context handle returned by
  /// FPDFText_FindStart.
  /// Return Value:
  /// Index for the starting character.
  int Text_GetSchResultIndex(
    FPDF_SCHHANDLE handle,
  ) {
    return _Text_GetSchResultIndex(
      handle,
    );
  }

  late final _Text_GetSchResultIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_SCHHANDLE)>>(
          'PDFIUM_FPDFText_GetSchResultIndex');
  late final _Text_GetSchResultIndex =
      _Text_GetSchResultIndexPtr.asFunction<int Function(FPDF_SCHHANDLE)>();

  /// Function: FPDFText_GetSchCount
  /// Get the number of matched characters in the search result.
  /// Parameters:
  /// handle      -   A search context handle returned by
  /// FPDFText_FindStart.
  /// Return Value:
  /// Number of matched characters.
  int Text_GetSchCount(
    FPDF_SCHHANDLE handle,
  ) {
    return _Text_GetSchCount(
      handle,
    );
  }

  late final _Text_GetSchCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_SCHHANDLE)>>(
          'PDFIUM_FPDFText_GetSchCount');
  late final _Text_GetSchCount =
      _Text_GetSchCountPtr.asFunction<int Function(FPDF_SCHHANDLE)>();

  /// Function: FPDFText_FindClose
  /// Release a search context.
  /// Parameters:
  /// handle      -   A search context handle returned by
  /// FPDFText_FindStart.
  /// Return Value:
  /// None.
  void Text_FindClose(
    FPDF_SCHHANDLE handle,
  ) {
    return _Text_FindClose(
      handle,
    );
  }

  late final _Text_FindClosePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_SCHHANDLE)>>(
          'PDFIUM_FPDFText_FindClose');
  late final _Text_FindClose =
      _Text_FindClosePtr.asFunction<void Function(FPDF_SCHHANDLE)>();

  /// Function: FPDFLink_LoadWebLinks
  /// Prepare information about weblinks in a page.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// Return Value:
  /// A handle to the page's links information structure, or
  /// NULL if something goes wrong.
  /// Comments:
  /// Weblinks are those links implicitly embedded in PDF pages. PDF also
  /// has a type of annotation called "link" (FPDFTEXT doesn't deal with
  /// that kind of link). FPDFTEXT weblink feature is useful for
  /// automatically detecting links in the page contents. For example,
  /// things like "https://www.example.com" will be detected, so
  /// applications can allow user to click on those characters to activate
  /// the link, even the PDF doesn't come with link annotations.
  /// FPDFLink_CloseWebLinks must be called to release resources.
  FPDF_PAGELINK Link_LoadWebLinks(
    FPDF_TEXTPAGE text_page,
  ) {
    return _Link_LoadWebLinks(
      text_page,
    );
  }

  late final _Link_LoadWebLinksPtr =
      _lookup<ffi.NativeFunction<FPDF_PAGELINK Function(FPDF_TEXTPAGE)>>(
          'PDFIUM_FPDFLink_LoadWebLinks');
  late final _Link_LoadWebLinks =
      _Link_LoadWebLinksPtr.asFunction<FPDF_PAGELINK Function(FPDF_TEXTPAGE)>();

  /// Function: FPDFLink_CountWebLinks
  /// Count number of detected web links.
  /// Parameters:
  /// link_page   -   Handle returned by FPDFLink_LoadWebLinks.
  /// Return Value:
  /// Number of detected web links.
  int Link_CountWebLinks(
    FPDF_PAGELINK link_page,
  ) {
    return _Link_CountWebLinks(
      link_page,
    );
  }

  late final _Link_CountWebLinksPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGELINK)>>(
          'PDFIUM_FPDFLink_CountWebLinks');
  late final _Link_CountWebLinks =
      _Link_CountWebLinksPtr.asFunction<int Function(FPDF_PAGELINK)>();

  /// Function: FPDFLink_GetURL
  /// Fetch the URL information for a detected web link.
  /// Parameters:
  /// link_page   -   Handle returned by FPDFLink_LoadWebLinks.
  /// link_index  -   Zero-based index for the link.
  /// buffer      -   A unicode buffer for the result.
  /// buflen      -   Number of 16-bit code units (not bytes) for the
  /// buffer, including an additional terminator.
  /// Return Value:
  /// If |buffer| is NULL or |buflen| is zero, return the number of 16-bit
  /// code units (not bytes) needed to buffer the result (an additional
  /// terminator is included in this count).
  /// Otherwise, copy the result into |buffer|, truncating at |buflen| if
  /// the result is too large to fit, and return the number of 16-bit code
  /// units actually copied into the buffer (the additional terminator is
  /// also included in this count).
  /// If |link_index| does not correspond to a valid link, then the result
  /// is an empty string.
  int Link_GetURL(
    FPDF_PAGELINK link_page,
    int link_index,
    ffi.Pointer<ffi.UnsignedShort> buffer,
    int buflen,
  ) {
    return _Link_GetURL(
      link_page,
      link_index,
      buffer,
      buflen,
    );
  }

  late final _Link_GetURLPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              FPDF_PAGELINK,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedShort>,
              ffi.Int)>>('PDFIUM_FPDFLink_GetURL');
  late final _Link_GetURL = _Link_GetURLPtr.asFunction<
      int Function(FPDF_PAGELINK, int, ffi.Pointer<ffi.UnsignedShort>, int)>();

  /// Function: FPDFLink_CountRects
  /// Count number of rectangular areas for the link.
  /// Parameters:
  /// link_page   -   Handle returned by FPDFLink_LoadWebLinks.
  /// link_index  -   Zero-based index for the link.
  /// Return Value:
  /// Number of rectangular areas for the link.  If |link_index| does
  /// not correspond to a valid link, then 0 is returned.
  int Link_CountRects(
    FPDF_PAGELINK link_page,
    int link_index,
  ) {
    return _Link_CountRects(
      link_page,
      link_index,
    );
  }

  late final _Link_CountRectsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGELINK, ffi.Int)>>(
          'PDFIUM_FPDFLink_CountRects');
  late final _Link_CountRects =
      _Link_CountRectsPtr.asFunction<int Function(FPDF_PAGELINK, int)>();

  /// Function: FPDFLink_GetRect
  /// Fetch the boundaries of a rectangle for a link.
  /// Parameters:
  /// link_page   -   Handle returned by FPDFLink_LoadWebLinks.
  /// link_index  -   Zero-based index for the link.
  /// rect_index  -   Zero-based index for a rectangle.
  /// left        -   Pointer to a double value receiving the rectangle
  /// left boundary.
  /// top         -   Pointer to a double value receiving the rectangle
  /// top boundary.
  /// right       -   Pointer to a double value receiving the rectangle
  /// right boundary.
  /// bottom      -   Pointer to a double value receiving the rectangle
  /// bottom boundary.
  /// Return Value:
  /// On success, return TRUE and fill in |left|, |top|, |right|, and
  /// |bottom|. If |link_page| is invalid or if |link_index| does not
  /// correspond to a valid link, then return FALSE, and the out
  /// parameters remain unmodified.
  int Link_GetRect(
    FPDF_PAGELINK link_page,
    int link_index,
    int rect_index,
    ffi.Pointer<ffi.Double> left,
    ffi.Pointer<ffi.Double> top,
    ffi.Pointer<ffi.Double> right,
    ffi.Pointer<ffi.Double> bottom,
  ) {
    return _Link_GetRect(
      link_page,
      link_index,
      rect_index,
      left,
      top,
      right,
      bottom,
    );
  }

  late final _Link_GetRectPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGELINK,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>)>>('PDFIUM_FPDFLink_GetRect');
  late final _Link_GetRect = _Link_GetRectPtr.asFunction<
      int Function(
          FPDF_PAGELINK,
          int,
          int,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>)>();

  /// Experimental API.
  /// Function: FPDFLink_GetTextRange
  /// Fetch the start char index and char count for a link.
  /// Parameters:
  /// link_page         -   Handle returned by FPDFLink_LoadWebLinks.
  /// link_index        -   Zero-based index for the link.
  /// start_char_index  -   pointer to int receiving the start char index
  /// char_count        -   pointer to int receiving the char count
  /// Return Value:
  /// On success, return TRUE and fill in |start_char_index| and
  /// |char_count|. if |link_page| is invalid or if |link_index| does
  /// not correspond to a valid link, then return FALSE and the out
  /// parameters remain unmodified.
  int Link_GetTextRange(
    FPDF_PAGELINK link_page,
    int link_index,
    ffi.Pointer<ffi.Int> start_char_index,
    ffi.Pointer<ffi.Int> char_count,
  ) {
    return _Link_GetTextRange(
      link_page,
      link_index,
      start_char_index,
      char_count,
    );
  }

  late final _Link_GetTextRangePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGELINK, ffi.Int, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('PDFIUM_FPDFLink_GetTextRange');
  late final _Link_GetTextRange = _Link_GetTextRangePtr.asFunction<
      int Function(
          FPDF_PAGELINK, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Function: FPDFLink_CloseWebLinks
  /// Release resources used by weblink feature.
  /// Parameters:
  /// link_page   -   Handle returned by FPDFLink_LoadWebLinks.
  /// Return Value:
  /// None.
  void Link_CloseWebLinks(
    FPDF_PAGELINK link_page,
  ) {
    return _Link_CloseWebLinks(
      link_page,
    );
  }

  late final _Link_CloseWebLinksPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_PAGELINK)>>(
          'PDFIUM_FPDFLink_CloseWebLinks');
  late final _Link_CloseWebLinks =
      _Link_CloseWebLinksPtr.asFunction<void Function(FPDF_PAGELINK)>();

  /// Get the document's PageMode.
  /// doc - Handle to document.
  /// Returns one of the |PAGEMODE_*| flags defined above.
  /// The page mode defines how the document should be initially displayed.
  int Doc_GetPageMode(
    FPDF_DOCUMENT document,
  ) {
    return _Doc_GetPageMode(
      document,
    );
  }

  late final _Doc_GetPageModePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDFDoc_GetPageMode');
  late final _Doc_GetPageMode =
      _Doc_GetPageModePtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Experimental API.
  /// Get the number of embedded files in |document|.
  /// document - handle to a document.
  /// Returns the number of embedded files in |document|.
  int Doc_GetAttachmentCount(
    FPDF_DOCUMENT document,
  ) {
    return _Doc_GetAttachmentCount(
      document,
    );
  }

  late final _Doc_GetAttachmentCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT)>>(
          'PDFIUM_FPDFDoc_GetAttachmentCount');
  late final _Doc_GetAttachmentCount =
      _Doc_GetAttachmentCountPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Experimental API.
  /// Add an embedded file with |name| in |document|. If |name| is empty, or if
  /// |name| is the name of a existing embedded file in |document|, or if
  /// |document|'s embedded file name tree is too deep (i.e. |document| has too
  /// many embedded files already), then a new attachment will not be added.
  /// document - handle to a document.
  /// name     - name of the new attachment.
  /// Returns a handle to the new attachment object, or NULL on failure.
  FPDF_ATTACHMENT Doc_AddAttachment(
    FPDF_DOCUMENT document,
    FPDF_WIDESTRING name,
  ) {
    return _Doc_AddAttachment(
      document,
      name,
    );
  }

  late final _Doc_AddAttachmentPtr = _lookup<
      ffi.NativeFunction<
          FPDF_ATTACHMENT Function(
              FPDF_DOCUMENT, FPDF_WIDESTRING)>>('PDFIUM_FPDFDoc_AddAttachment');
  late final _Doc_AddAttachment = _Doc_AddAttachmentPtr.asFunction<
      FPDF_ATTACHMENT Function(FPDF_DOCUMENT, FPDF_WIDESTRING)>();

  /// Experimental API.
  /// Get the embedded attachment at |index| in |document|. Note that the returned
  /// attachment handle is only valid while |document| is open.
  /// document - handle to a document.
  /// index    - the index of the requested embedded file.
  /// Returns the handle to the attachment object, or NULL on failure.
  FPDF_ATTACHMENT Doc_GetAttachment(
    FPDF_DOCUMENT document,
    int index,
  ) {
    return _Doc_GetAttachment(
      document,
      index,
    );
  }

  late final _Doc_GetAttachmentPtr = _lookup<
          ffi.NativeFunction<FPDF_ATTACHMENT Function(FPDF_DOCUMENT, ffi.Int)>>(
      'PDFIUM_FPDFDoc_GetAttachment');
  late final _Doc_GetAttachment = _Doc_GetAttachmentPtr.asFunction<
      FPDF_ATTACHMENT Function(FPDF_DOCUMENT, int)>();

  /// Experimental API.
  /// Delete the embedded attachment at |index| in |document|. Note that this does
  /// not remove the attachment data from the PDF file; it simply removes the
  /// file's entry in the embedded files name tree so that it does not appear in
  /// the attachment list. This behavior may change in the future.
  /// document - handle to a document.
  /// index    - the index of the embedded file to be deleted.
  /// Returns true if successful.
  int Doc_DeleteAttachment(
    FPDF_DOCUMENT document,
    int index,
  ) {
    return _Doc_DeleteAttachment(
      document,
      index,
    );
  }

  late final _Doc_DeleteAttachmentPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_DOCUMENT, ffi.Int)>>(
          'PDFIUM_FPDFDoc_DeleteAttachment');
  late final _Doc_DeleteAttachment =
      _Doc_DeleteAttachmentPtr.asFunction<int Function(FPDF_DOCUMENT, int)>();

  /// Experimental API.
  /// Get the name of the |attachment| file. |buffer| is only modified if |buflen|
  /// is longer than the length of the file name. On errors, |buffer| is unmodified
  /// and the returned length is 0.
  /// attachment - handle to an attachment.
  /// buffer     - buffer for holding the file name, encoded in UTF-16LE.
  /// buflen     - length of the buffer in bytes.
  /// Returns the length of the file name in bytes.
  int Attachment_GetName(
    FPDF_ATTACHMENT attachment,
    ffi.Pointer<FPDF_WCHAR> buffer,
    int buflen,
  ) {
    return _Attachment_GetName(
      attachment,
      buffer,
      buflen,
    );
  }

  late final _Attachment_GetNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_ATTACHMENT, ffi.Pointer<FPDF_WCHAR>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFAttachment_GetName');
  late final _Attachment_GetName = _Attachment_GetNamePtr.asFunction<
      int Function(FPDF_ATTACHMENT, ffi.Pointer<FPDF_WCHAR>, int)>();

  /// Experimental API.
  /// Check if the params dictionary of |attachment| has |key| as a key.
  /// attachment - handle to an attachment.
  /// key        - the key to look for, encoded in UTF-8.
  /// Returns true if |key| exists.
  int Attachment_HasKey(
    FPDF_ATTACHMENT attachment,
    FPDF_BYTESTRING key,
  ) {
    return _Attachment_HasKey(
      attachment,
      key,
    );
  }

  late final _Attachment_HasKeyPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_ATTACHMENT,
              FPDF_BYTESTRING)>>('PDFIUM_FPDFAttachment_HasKey');
  late final _Attachment_HasKey = _Attachment_HasKeyPtr.asFunction<
      int Function(FPDF_ATTACHMENT, FPDF_BYTESTRING)>();

  /// Experimental API.
  /// Get the type of the value corresponding to |key| in the params dictionary of
  /// the embedded |attachment|.
  /// attachment - handle to an attachment.
  /// key        - the key to look for, encoded in UTF-8.
  /// Returns the type of the dictionary value.
  int Attachment_GetValueType(
    FPDF_ATTACHMENT attachment,
    FPDF_BYTESTRING key,
  ) {
    return _Attachment_GetValueType(
      attachment,
      key,
    );
  }

  late final _Attachment_GetValueTypePtr = _lookup<
      ffi.NativeFunction<
          FPDF_OBJECT_TYPE Function(FPDF_ATTACHMENT,
              FPDF_BYTESTRING)>>('PDFIUM_FPDFAttachment_GetValueType');
  late final _Attachment_GetValueType = _Attachment_GetValueTypePtr.asFunction<
      int Function(FPDF_ATTACHMENT, FPDF_BYTESTRING)>();

  /// Experimental API.
  /// Set the string value corresponding to |key| in the params dictionary of the
  /// embedded file |attachment|, overwriting the existing value if any. The value
  /// type should be FPDF_OBJECT_STRING after this function call succeeds.
  /// attachment - handle to an attachment.
  /// key        - the key to the dictionary entry, encoded in UTF-8.
  /// value      - the string value to be set, encoded in UTF-16LE.
  /// Returns true if successful.
  int Attachment_SetStringValue(
    FPDF_ATTACHMENT attachment,
    FPDF_BYTESTRING key,
    FPDF_WIDESTRING value,
  ) {
    return _Attachment_SetStringValue(
      attachment,
      key,
      value,
    );
  }

  late final _Attachment_SetStringValuePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_ATTACHMENT, FPDF_BYTESTRING,
              FPDF_WIDESTRING)>>('PDFIUM_FPDFAttachment_SetStringValue');
  late final _Attachment_SetStringValue =
      _Attachment_SetStringValuePtr.asFunction<
          int Function(FPDF_ATTACHMENT, FPDF_BYTESTRING, FPDF_WIDESTRING)>();

  /// Experimental API.
  /// Get the string value corresponding to |key| in the params dictionary of the
  /// embedded file |attachment|. |buffer| is only modified if |buflen| is longer
  /// than the length of the string value. Note that if |key| does not exist in the
  /// dictionary or if |key|'s corresponding value in the dictionary is not a
  /// string (i.e. the value is not of type FPDF_OBJECT_STRING or
  /// FPDF_OBJECT_NAME), then an empty string would be copied to |buffer| and the
  /// return value would be 2. On other errors, nothing would be added to |buffer|
  /// and the return value would be 0.
  /// attachment - handle to an attachment.
  /// key        - the key to the requested string value, encoded in UTF-8.
  /// buffer     - buffer for holding the string value encoded in UTF-16LE.
  /// buflen     - length of the buffer in bytes.
  /// Returns the length of the dictionary value string in bytes.
  int Attachment_GetStringValue(
    FPDF_ATTACHMENT attachment,
    FPDF_BYTESTRING key,
    ffi.Pointer<FPDF_WCHAR> buffer,
    int buflen,
  ) {
    return _Attachment_GetStringValue(
      attachment,
      key,
      buffer,
      buflen,
    );
  }

  late final _Attachment_GetStringValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_ATTACHMENT,
              FPDF_BYTESTRING,
              ffi.Pointer<FPDF_WCHAR>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFAttachment_GetStringValue');
  late final _Attachment_GetStringValue =
      _Attachment_GetStringValuePtr.asFunction<
          int Function(FPDF_ATTACHMENT, FPDF_BYTESTRING,
              ffi.Pointer<FPDF_WCHAR>, int)>();

  /// Experimental API.
  /// Set the file data of |attachment|, overwriting the existing file data if any.
  /// The creation date and checksum will be updated, while all other dictionary
  /// entries will be deleted. Note that only contents with |len| smaller than
  /// INT_MAX is supported.
  /// attachment - handle to an attachment.
  /// contents   - buffer holding the file data to write to |attachment|.
  /// len        - length of file data in bytes.
  /// Returns true if successful.
  int Attachment_SetFile(
    FPDF_ATTACHMENT attachment,
    FPDF_DOCUMENT document,
    ffi.Pointer<ffi.Void> contents,
    int len,
  ) {
    return _Attachment_SetFile(
      attachment,
      document,
      contents,
      len,
    );
  }

  late final _Attachment_SetFilePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_ATTACHMENT,
              FPDF_DOCUMENT,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFAttachment_SetFile');
  late final _Attachment_SetFile = _Attachment_SetFilePtr.asFunction<
      int Function(
          FPDF_ATTACHMENT, FPDF_DOCUMENT, ffi.Pointer<ffi.Void>, int)>();

  /// Experimental API.
  /// Get the file data of |attachment|.
  /// When the attachment file data is readable, true is returned, and |out_buflen|
  /// is updated to indicate the file data size. |buffer| is only modified if
  /// |buflen| is non-null and long enough to contain the entire file data. Callers
  /// must check both the return value and the input |buflen| is no less than the
  /// returned |out_buflen| before using the data.
  /// Otherwise, when the attachment file data is unreadable or when |out_buflen|
  /// is null, false is returned and |buffer| and |out_buflen| remain unmodified.
  /// attachment - handle to an attachment.
  /// buffer     - buffer for holding the file data from |attachment|.
  /// buflen     - length of the buffer in bytes.
  /// out_buflen - pointer to the variable that will receive the minimum buffer
  /// size to contain the file data of |attachment|.
  /// Returns true on success, false otherwise.
  int Attachment_GetFile(
    FPDF_ATTACHMENT attachment,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
    ffi.Pointer<ffi.UnsignedLong> out_buflen,
  ) {
    return _Attachment_GetFile(
      attachment,
      buffer,
      buflen,
      out_buflen,
    );
  }

  late final _Attachment_GetFilePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_ATTACHMENT,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.UnsignedLong>)>>('PDFIUM_FPDFAttachment_GetFile');
  late final _Attachment_GetFile = _Attachment_GetFilePtr.asFunction<
      int Function(FPDF_ATTACHMENT, ffi.Pointer<ffi.Void>, int,
          ffi.Pointer<ffi.UnsignedLong>)>();

  /// Experimental API.
  /// Get the MIME type (Subtype) of the embedded file |attachment|. |buffer| is
  /// only modified if |buflen| is longer than the length of the MIME type string.
  /// If the Subtype is not found or if there is no file stream, an empty string
  /// would be copied to |buffer| and the return value would be 2. On other errors,
  /// nothing would be added to |buffer| and the return value would be 0.
  /// attachment - handle to an attachment.
  /// buffer     - buffer for holding the MIME type string encoded in UTF-16LE.
  /// buflen     - length of the buffer in bytes.
  /// Returns the length of the MIME type string in bytes.
  int Attachment_GetSubtype(
    FPDF_ATTACHMENT attachment,
    ffi.Pointer<FPDF_WCHAR> buffer,
    int buflen,
  ) {
    return _Attachment_GetSubtype(
      attachment,
      buffer,
      buflen,
    );
  }

  late final _Attachment_GetSubtypePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_ATTACHMENT, ffi.Pointer<FPDF_WCHAR>,
              ffi.UnsignedLong)>>('PDFIUM_FPDFAttachment_GetSubtype');
  late final _Attachment_GetSubtype = _Attachment_GetSubtypePtr.asFunction<
      int Function(FPDF_ATTACHMENT, ffi.Pointer<FPDF_WCHAR>, int)>();
}

/// mbstate_t is an opaque object to keep conversion state, during multibyte
/// stream conversions.  The content must not be referenced by user programs.
final class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  /// for alignment
  @ffi.LongLong()
  external int _mbstateL;
}

final class __darwin_pthread_handler_rec extends ffi.Struct {
  /// Routine to call
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  /// Argument to pass
  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

final class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

/// stdio buffers
final class __sbuf extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> _base;

  @ffi.Int()
  external int _size;
}

/// hold a buncha junk that would grow the ABI
final class __sFILEX extends ffi.Opaque {}

/// stdio state variables.
///
/// The following always hold:
///
/// if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
/// _lbfsize is -_bf._size, else _lbfsize is 0
/// if _flags&__SRD, _w is 0
/// if _flags&__SWR, _r is 0
///
/// This ensures that the getc and putc macros (or inline functions) never
/// try to write or read from a file that is in `read' or `write' mode.
/// (Moreover, they can, and do, automatically switch from read mode to
/// write mode, and back, on "r+" and "w+" files.)
///
/// _lbfsize is used only to make the inline line-buffered output stream
/// code as compact as possible.
///
/// _ub, _up, and _ur are used when ungetc() pushes back more characters
/// than fit in the current _bf, or when ungetc() pushes back a character
/// that does not match the previous one in _bf.  When this happens,
/// _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
/// _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
///
/// NB: see WARNING above before changing the layout of this structure!
final class __sFILE extends ffi.Struct {
  /// current position in (some) buffer
  external ffi.Pointer<ffi.UnsignedChar> _p;

  /// read space left for getc()
  @ffi.Int()
  external int _r;

  /// write space left for putc()
  @ffi.Int()
  external int _w;

  /// flags, below; this FILE is free if 0
  @ffi.Short()
  external int _flags;

  /// fileno, if Unix descriptor, else -1
  @ffi.Short()
  external int _file;

  /// the buffer (at least 1 byte, if !NULL)
  external __sbuf _bf;

  /// 0 or -_bf._size, for inline putc
  @ffi.Int()
  external int _lbfsize;

  /// cookie passed to io functions
  external ffi.Pointer<ffi.Void> _cookie;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>
      _close;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>> _read;

  external ffi.Pointer<
      ffi.NativeFunction<
          fpos_t Function(ffi.Pointer<ffi.Void>, fpos_t, ffi.Int)>> _seek;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>> _write;

  /// ungetc buffer
  external __sbuf _ub;

  /// additions to FILE to not break ABI
  external ffi.Pointer<__sFILEX> _extra;

  /// saved _r when _r is counting ungetc data
  @ffi.Int()
  external int _ur;

  /// guarantee an ungetc() buffer
  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedChar> _ubuf;

  /// guarantee a getc() buffer
  @ffi.Array.multi([1])
  external ffi.Array<ffi.UnsignedChar> _nbuf;

  /// buffer for fgetln()
  external __sbuf _lb;

  /// stat.st_blksize (may be != _bf._size)
  @ffi.Int()
  external int _blksize;

  /// current lseek offset (see WARNING)
  @fpos_t()
  external int _offset;
}

typedef fpos_t = __darwin_off_t;
typedef __darwin_off_t = __int64_t;
typedef __int64_t = ffi.LongLong;
typedef Dart__int64_t = int;

/// stdio state variables.
///
/// The following always hold:
///
/// if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
/// _lbfsize is -_bf._size, else _lbfsize is 0
/// if _flags&__SRD, _w is 0
/// if _flags&__SWR, _r is 0
///
/// This ensures that the getc and putc macros (or inline functions) never
/// try to write or read from a file that is in `read' or `write' mode.
/// (Moreover, they can, and do, automatically switch from read mode to
/// write mode, and back, on "r+" and "w+" files.)
///
/// _lbfsize is used only to make the inline line-buffered output stream
/// code as compact as possible.
///
/// _ub, _up, and _ur are used when ungetc() pushes back more characters
/// than fit in the current _bf, or when ungetc() pushes back a character
/// that does not match the previous one in _bf.  When this happens,
/// _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
/// _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
///
/// NB: see WARNING above before changing the layout of this structure!
typedef FILE = __sFILE;

/// [XSI] The type idtype_t shall be defined as an enumeration type whose
/// possible values shall include at least P_ALL, P_PID, and P_PGID.
abstract class idtype_t {
  static const int P_ALL = 0;
  static const int P_PID = 1;
  static const int P_PGID = 2;
}

final class __darwin_arm_exception_state extends ffi.Struct {
  /// number of arm exception taken
  @__uint32_t()
  external int __exception;

  /// Fault status
  @__uint32_t()
  external int __fsr;

  /// Virtual Fault Address
  @__uint32_t()
  external int __far;
}

typedef __uint32_t = ffi.UnsignedInt;
typedef Dart__uint32_t = int;

final class __darwin_arm_exception_state64 extends ffi.Struct {
  /// Virtual Fault Address
  @__uint64_t()
  external int __far;

  /// Exception syndrome
  @__uint32_t()
  external int __esr;

  /// number of arm exception taken
  @__uint32_t()
  external int __exception;
}

typedef __uint64_t = ffi.UnsignedLongLong;
typedef Dart__uint64_t = int;

final class __darwin_arm_exception_state64_v2 extends ffi.Struct {
  /// Virtual Fault Address
  @__uint64_t()
  external int __far;

  /// Exception syndrome
  @__uint64_t()
  external int __esr;
}

final class __darwin_arm_thread_state extends ffi.Struct {
  /// General purpose register r0-r12
  @ffi.Array.multi([13])
  external ffi.Array<__uint32_t> __r;

  /// Stack pointer r13
  @__uint32_t()
  external int __sp;

  /// Link register r14
  @__uint32_t()
  external int __lr;

  /// Program counter r15
  @__uint32_t()
  external int __pc;

  /// Current program status register
  @__uint32_t()
  external int __cpsr;
}

final class __darwin_arm_thread_state64 extends ffi.Struct {
  /// General purpose registers x0-x28
  @ffi.Array.multi([29])
  external ffi.Array<__uint64_t> __x;

  /// Frame pointer x29
  @__uint64_t()
  external int __fp;

  /// Link register x30
  @__uint64_t()
  external int __lr;

  /// Stack pointer x31
  @__uint64_t()
  external int __sp;

  /// Program counter
  @__uint64_t()
  external int __pc;

  /// Current program status register
  @__uint32_t()
  external int __cpsr;

  /// Same size for 32-bit or 64-bit clients
  @__uint32_t()
  external int __pad;
}

final class __darwin_arm_vfp_state extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<__uint32_t> __r;

  @__uint32_t()
  external int __fpscr;
}

final class __darwin_arm_neon_state64 extends ffi.Opaque {}

final class __darwin_arm_neon_state extends ffi.Opaque {}

final class __arm_pagein_state extends ffi.Struct {
  @ffi.Int()
  external int __pagein_error;
}

final class __darwin_arm_sme_state extends ffi.Struct {
  @__uint64_t()
  external int __svcr;

  @__uint64_t()
  external int __tpidr2_el0;

  @__uint16_t()
  external int __svl_b;
}

typedef __uint16_t = ffi.UnsignedShort;
typedef Dart__uint16_t = int;

final class __darwin_arm_sve_z_state extends ffi.Struct {
  @ffi.Array.multi([16, 256])
  external ffi.Array<ffi.Array<ffi.Char>> __z;
}

final class __darwin_arm_sve_p_state extends ffi.Struct {
  @ffi.Array.multi([16, 32])
  external ffi.Array<ffi.Array<ffi.Char>> __p;
}

final class __darwin_arm_sme_za_state extends ffi.Struct {
  @ffi.Array.multi([4096])
  external ffi.Array<ffi.Char> __za;
}

final class __darwin_arm_sme2_state extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.Char> __zt0;
}

final class __arm_legacy_debug_state extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;
}

final class __darwin_arm_debug_state32 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;

  /// Bit 0 is SS (Hardware Single Step)
  @__uint64_t()
  external int __mdscr_el1;
}

final class __darwin_arm_debug_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wcr;

  /// Bit 0 is SS (Hardware Single Step)
  @__uint64_t()
  external int __mdscr_el1;
}

final class __darwin_arm_cpmu_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __ctrs;
}

final class __darwin_mcontext32 extends ffi.Struct {
  external __darwin_arm_exception_state __es;

  external __darwin_arm_thread_state __ss;

  external __darwin_arm_vfp_state __fs;
}

final class __darwin_mcontext64 extends ffi.Opaque {}

final class __darwin_sigaltstack extends ffi.Struct {
  /// signal stack base
  external ffi.Pointer<ffi.Void> ss_sp;

  /// signal stack length
  @__darwin_size_t()
  external int ss_size;

  /// SA_DISABLE and/or SA_ONSTACK
  @ffi.Int()
  external int ss_flags;
}

typedef __darwin_size_t = ffi.UnsignedLong;
typedef Dart__darwin_size_t = int;

final class __darwin_ucontext extends ffi.Struct {
  @ffi.Int()
  external int uc_onstack;

  /// signal mask used by this context
  @__darwin_sigset_t()
  external int uc_sigmask;

  /// stack used by this context
  external __darwin_sigaltstack uc_stack;

  /// pointer to resuming context
  external ffi.Pointer<__darwin_ucontext> uc_link;

  /// size of the machine context passed in
  @__darwin_size_t()
  external int uc_mcsize;

  /// pointer to machine specific context
  external ffi.Pointer<__darwin_mcontext64> uc_mcontext;
}

typedef __darwin_sigset_t = __uint32_t;

final class sigval extends ffi.Union {
  /// Members as suggested by Annex C of POSIX 1003.1b.
  @ffi.Int()
  external int sival_int;

  external ffi.Pointer<ffi.Void> sival_ptr;
}

final class sigevent extends ffi.Struct {
  /// Notification type
  @ffi.Int()
  external int sigev_notify;

  /// Signal number
  @ffi.Int()
  external int sigev_signo;

  /// Signal value
  external sigval sigev_value;

  /// Notification function
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(sigval)>>
      sigev_notify_function;

  /// Notification attributes
  external ffi.Pointer<pthread_attr_t> sigev_notify_attributes;
}

typedef pthread_attr_t = __darwin_pthread_attr_t;
typedef __darwin_pthread_attr_t = _opaque_pthread_attr_t;

final class __siginfo extends ffi.Struct {
  /// signal number
  @ffi.Int()
  external int si_signo;

  /// errno association
  @ffi.Int()
  external int si_errno;

  /// signal code
  @ffi.Int()
  external int si_code;

  /// sending process
  @pid_t()
  external int si_pid;

  /// sender's ruid
  @uid_t()
  external int si_uid;

  /// exit value
  @ffi.Int()
  external int si_status;

  /// faulting instruction
  external ffi.Pointer<ffi.Void> si_addr;

  /// signal value
  external sigval si_value;

  /// band event for SIGPOLL
  @ffi.Long()
  external int si_band;

  /// Reserved for Future Use
  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedLong> __pad;
}

typedef pid_t = __darwin_pid_t;
typedef __darwin_pid_t = __int32_t;
typedef __int32_t = ffi.Int;
typedef Dart__int32_t = int;
typedef uid_t = __darwin_uid_t;
typedef __darwin_uid_t = __uint32_t;

/// union for signal handlers
final class __sigaction_u extends ffi.Union {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      __sa_handler;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Int, ffi.Pointer<__siginfo>, ffi.Pointer<ffi.Void>)>>
      __sa_sigaction;
}

/// Signal vector template for Kernel user boundary
final class __sigaction extends ffi.Struct {
  /// signal handler
  external __sigaction_u __sigaction_u1;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int,
              ffi.Pointer<siginfo_t>, ffi.Pointer<ffi.Void>)>> sa_tramp;

  /// signal mask to apply
  @sigset_t()
  external int sa_mask;

  /// see signal options below
  @ffi.Int()
  external int sa_flags;
}

typedef siginfo_t = __siginfo;
typedef sigset_t = __darwin_sigset_t;

/// Signal vector "template" used in sigaction call.
final class sigaction extends ffi.Struct {
  /// signal handler
  external __sigaction_u __sigaction_u1;

  /// signal mask to apply
  @sigset_t()
  external int sa_mask;

  /// see signal options below
  @ffi.Int()
  external int sa_flags;
}

/// 4.3 compatibility:
/// Signal vector "template" used in sigvec call.
final class sigvec extends ffi.Struct {
  /// signal handler
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      sv_handler;

  /// signal mask to apply
  @ffi.Int()
  external int sv_mask;

  /// see signal options below
  @ffi.Int()
  external int sv_flags;
}

/// Structure used in sigstack call.
final class sigstack extends ffi.Struct {
  /// signal stack pointer
  external ffi.Pointer<ffi.Char> ss_sp;

  /// current status
  @ffi.Int()
  external int ss_onstack;
}

final class timeval extends ffi.Struct {
  /// seconds
  @__darwin_time_t()
  external int tv_sec;

  /// and microseconds
  @__darwin_suseconds_t()
  external int tv_usec;
}

typedef __darwin_time_t = ffi.Long;
typedef Dart__darwin_time_t = int;
typedef __darwin_suseconds_t = __int32_t;

/// A structure representing an accounting of resource utilization.  The
/// address of an instance of this structure is the second parameter to
/// getrusage().
///
/// Note: All values other than ru_utime and ru_stime are implementaiton
/// defined and subject to change in a future release.  Their use
/// is discouraged for standards compliant programs.
final class rusage extends ffi.Struct {
  /// user time used (PL)
  external timeval ru_utime;

  /// system time used (PL)
  external timeval ru_stime;

  /// max resident set size (PL)
  @ffi.Long()
  external int ru_maxrss;

  /// integral shared memory size (NU)
  @ffi.Long()
  external int ru_ixrss;

  /// integral unshared data (NU)
  @ffi.Long()
  external int ru_idrss;

  /// integral unshared stack (NU)
  @ffi.Long()
  external int ru_isrss;

  /// page reclaims (NU)
  @ffi.Long()
  external int ru_minflt;

  /// page faults (NU)
  @ffi.Long()
  external int ru_majflt;

  /// swaps (NU)
  @ffi.Long()
  external int ru_nswap;

  /// block input operations (atomic)
  @ffi.Long()
  external int ru_inblock;

  /// block output operations (atomic)
  @ffi.Long()
  external int ru_oublock;

  /// messages sent (atomic)
  @ffi.Long()
  external int ru_msgsnd;

  /// messages received (atomic)
  @ffi.Long()
  external int ru_msgrcv;

  /// signals received (atomic)
  @ffi.Long()
  external int ru_nsignals;

  /// voluntary context switches (atomic)
  @ffi.Long()
  external int ru_nvcsw;

  /// involuntary "
  @ffi.Long()
  external int ru_nivcsw;
}

final class rusage_info_v0 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;
}

final class rusage_info_v1 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;
}

final class rusage_info_v2 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;
}

final class rusage_info_v3 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;
}

final class rusage_info_v4 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;
}

final class rusage_info_v5 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;
}

final class rusage_info_v6 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;

  @ffi.Uint64()
  external int ri_user_ptime;

  @ffi.Uint64()
  external int ri_system_ptime;

  @ffi.Uint64()
  external int ri_pinstructions;

  @ffi.Uint64()
  external int ri_pcycles;

  @ffi.Uint64()
  external int ri_energy_nj;

  @ffi.Uint64()
  external int ri_penergy_nj;

  @ffi.Uint64()
  external int ri_secure_time_in_system;

  @ffi.Uint64()
  external int ri_secure_ptime_in_system;

  @ffi.Uint64()
  external int ri_neural_footprint;

  @ffi.Uint64()
  external int ri_lifetime_max_neural_footprint;

  @ffi.Uint64()
  external int ri_interval_max_neural_footprint;

  @ffi.Array.multi([9])
  external ffi.Array<ffi.Uint64> ri_reserved;
}

/// A structure representing a resource limit.  The address of an instance
/// of this structure is the second parameter to getrlimit()/setrlimit().
final class rlimit extends ffi.Struct {
  /// current (soft) limit
  @rlim_t()
  external int rlim_cur;

  /// maximum value for rlim_cur
  @rlim_t()
  external int rlim_max;
}

/// Resource limit type (low 63 bits, excluding the sign bit)
typedef rlim_t = __uint64_t;

final class proc_rlimit_control_wakeupmon extends ffi.Struct {
  @ffi.Uint32()
  external int wm_flags;

  @ffi.Int32()
  external int wm_rate;
}

/// Deprecated:
/// Structure of the information in the status word returned by wait4.
/// If w_stopval==_WSTOPPED, then the second structure describes
/// the information returned, else the first.
final class wait extends ffi.Opaque {}

final class div_t extends ffi.Struct {
  /// quotient
  @ffi.Int()
  external int quot;

  /// remainder
  @ffi.Int()
  external int rem;
}

final class ldiv_t extends ffi.Struct {
  /// quotient
  @ffi.Long()
  external int quot;

  /// remainder
  @ffi.Long()
  external int rem;
}

final class lldiv_t extends ffi.Struct {
  @ffi.LongLong()
  external int quot;

  @ffi.LongLong()
  external int rem;
}

final class _malloc_zone_t extends ffi.Opaque {}

final class sched_param extends ffi.Struct {
  @ffi.Int()
  external int sched_priority;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __opaque;
}

final class timespec extends ffi.Struct {
  @__darwin_time_t()
  external int tv_sec;

  @ffi.Long()
  external int tv_nsec;
}

final class tm extends ffi.Struct {
  /// seconds after the minute [0-60]
  @ffi.Int()
  external int tm_sec;

  /// minutes after the hour [0-59]
  @ffi.Int()
  external int tm_min;

  /// hours since midnight [0-23]
  @ffi.Int()
  external int tm_hour;

  /// day of the month [1-31]
  @ffi.Int()
  external int tm_mday;

  /// months since January [0-11]
  @ffi.Int()
  external int tm_mon;

  /// years since 1900
  @ffi.Int()
  external int tm_year;

  /// days since Sunday [0-6]
  @ffi.Int()
  external int tm_wday;

  /// days since January 1 [0-365]
  @ffi.Int()
  external int tm_yday;

  /// Daylight Savings Time flag
  @ffi.Int()
  external int tm_isdst;

  /// offset from UTC in seconds
  @ffi.Long()
  external int tm_gmtoff;

  /// timezone abbreviation
  external ffi.Pointer<ffi.Char> tm_zone;
}

abstract class clockid_t {
  static const int _CLOCK_REALTIME = 0;
  static const int _CLOCK_MONOTONIC = 6;
  static const int _CLOCK_MONOTONIC_RAW = 4;
  static const int _CLOCK_MONOTONIC_RAW_APPROX = 5;
  static const int _CLOCK_UPTIME_RAW = 8;
  static const int _CLOCK_UPTIME_RAW_APPROX = 9;
  static const int _CLOCK_PROCESS_CPUTIME_ID = 12;
  static const int _CLOCK_THREAD_CPUTIME_ID = 16;
}

final class pthread_override_s extends ffi.Opaque {}

final class accessx_descriptor extends ffi.Struct {
  @ffi.UnsignedInt()
  external int ad_name_offset;

  @ffi.Int()
  external int ad_flags;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> ad_pad;
}

final class fd_set extends ffi.Struct {
  @ffi.Array.multi([32])
  external ffi.Array<__int32_t> fds_bits;
}

final class fssearchblock extends ffi.Opaque {}

final class searchstate extends ffi.Opaque {}

/// PDF text rendering modes
abstract class FPDF_TEXT_RENDERMODE {
  static const int FPDF_TEXTRENDERMODE_UNKNOWN = -1;
  static const int FPDF_TEXTRENDERMODE_FILL = 0;
  static const int FPDF_TEXTRENDERMODE_STROKE = 1;
  static const int FPDF_TEXTRENDERMODE_FILL_STROKE = 2;
  static const int FPDF_TEXTRENDERMODE_INVISIBLE = 3;
  static const int FPDF_TEXTRENDERMODE_FILL_CLIP = 4;
  static const int FPDF_TEXTRENDERMODE_STROKE_CLIP = 5;
  static const int FPDF_TEXTRENDERMODE_FILL_STROKE_CLIP = 6;
  static const int FPDF_TEXTRENDERMODE_CLIP = 7;
  static const int FPDF_TEXTRENDERMODE_LAST = 7;
}

final class fpdf_action_t__ extends ffi.Opaque {}

final class fpdf_annotation_t__ extends ffi.Opaque {}

final class fpdf_attachment_t__ extends ffi.Opaque {}

final class fpdf_avail_t__ extends ffi.Opaque {}

final class fpdf_bitmap_t__ extends ffi.Opaque {}

final class fpdf_bookmark_t__ extends ffi.Opaque {}

final class fpdf_clippath_t__ extends ffi.Opaque {}

final class fpdf_dest_t__ extends ffi.Opaque {}

final class fpdf_document_t__ extends ffi.Opaque {}

final class fpdf_font_t__ extends ffi.Opaque {}

final class fpdf_form_handle_t__ extends ffi.Opaque {}

final class fpdf_glyphpath_t__ extends ffi.Opaque {}

final class fpdf_javascript_action_t extends ffi.Opaque {}

final class fpdf_link_t__ extends ffi.Opaque {}

final class fpdf_page_t__ extends ffi.Opaque {}

final class fpdf_pagelink_t__ extends ffi.Opaque {}

final class fpdf_pageobject_t__ extends ffi.Opaque {}

final class fpdf_pageobjectmark_t__ extends ffi.Opaque {}

final class fpdf_pagerange_t__ extends ffi.Opaque {}

final class fpdf_pathsegment_t extends ffi.Opaque {}

final class fpdf_schhandle_t__ extends ffi.Opaque {}

final class fpdf_signature_t__ extends ffi.Opaque {}

final class fpdf_structelement_t__ extends ffi.Opaque {}

final class fpdf_structelement_attr_t__ extends ffi.Opaque {}

final class fpdf_structelement_attr_value_t__ extends ffi.Opaque {}

final class fpdf_structtree_t__ extends ffi.Opaque {}

final class fpdf_textpage_t__ extends ffi.Opaque {}

final class fpdf_widget_t__ extends ffi.Opaque {}

final class fpdf_xobject_t__ extends ffi.Opaque {}

/// Duplex types
abstract class _FPDF_DUPLEXTYPE_ {
  static const int DuplexUndefined = 0;
  static const int Simplex = 1;
  static const int DuplexFlipShortEdge = 2;
  static const int DuplexFlipLongEdge = 3;
}

/// Structure for persisting a string beyond the duration of a callback.
/// Note: although represented as a char*, string may be interpreted as
/// a UTF-16LE formated string. Used only by XFA callbacks.
final class FPDF_BSTR_ extends ffi.Struct {
  /// String buffer, manipulate only with FPDF_BStr_* methods.
  external ffi.Pointer<ffi.Char> str;

  /// Length of the string, in bytes.
  @ffi.Int()
  external int len;
}

/// Matrix for transformation, in the form [a b c d e f], equivalent to:
/// | a  b  0 |
/// | c  d  0 |
/// | e  f  1 |
///
/// Translation is performed with [1 0 0 1 tx ty].
/// Scaling is performed with [sx 0 0 sy 0 0].
/// See PDF Reference 1.7, 4.2.2 Common Transformations for more.
final class _FS_MATRIX_ extends ffi.Struct {
  @ffi.Float()
  external double a;

  @ffi.Float()
  external double b;

  @ffi.Float()
  external double c;

  @ffi.Float()
  external double d;

  @ffi.Float()
  external double e;

  @ffi.Float()
  external double f;
}

/// Rectangle area(float) in device or page coordinate system.
final class _FS_RECTF_ extends ffi.Struct {
  /// The x-coordinate of the left-top corner.
  @ffi.Float()
  external double left;

  /// The y-coordinate of the left-top corner.
  @ffi.Float()
  external double top;

  /// The x-coordinate of the right-bottom corner.
  @ffi.Float()
  external double right;

  /// The y-coordinate of the right-bottom corner.
  @ffi.Float()
  external double bottom;
}

/// Rectangle size. Coordinate system agnostic.
final class FS_SIZEF_ extends ffi.Struct {
  @ffi.Float()
  external double width;

  @ffi.Float()
  external double height;
}

/// 2D Point. Coordinate system agnostic.
final class FS_POINTF_ extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;
}

final class _FS_QUADPOINTSF extends ffi.Struct {
  @FS_FLOAT()
  external double x1;

  @FS_FLOAT()
  external double y1;

  @FS_FLOAT()
  external double x2;

  @FS_FLOAT()
  external double y2;

  @FS_FLOAT()
  external double x3;

  @FS_FLOAT()
  external double y3;

  @FS_FLOAT()
  external double x4;

  @FS_FLOAT()
  external double y4;
}

typedef FS_FLOAT = ffi.Float;
typedef DartFS_FLOAT = double;

/// PDF renderer types - Experimental.
/// Selection of 2D graphics library to use for rendering to FPDF_BITMAPs.
abstract class FPDF_RENDERER_TYPE {
  /// Anti-Grain Geometry - https://sourceforge.net/projects/agg/
  static const int FPDF_RENDERERTYPE_AGG = 0;

  /// Skia - https://skia.org/
  static const int FPDF_RENDERERTYPE_SKIA = 1;
}

/// Process-wide options for initializing the library.
final class FPDF_LIBRARY_CONFIG_ extends ffi.Struct {
  /// Version number of the interface. Currently must be 2.
  /// Support for version 1 will be deprecated in the future.
  @ffi.Int()
  external int version;

  /// Array of paths to scan in place of the defaults when using built-in
  /// FXGE font loading code. The array is terminated by a NULL pointer.
  /// The Array may be NULL itself to use the default paths. May be ignored
  /// entirely depending upon the platform.
  external ffi.Pointer<ffi.Pointer<ffi.Char>> m_pUserFontPaths;

  /// Pointer to the v8::Isolate to use, or NULL to force PDFium to create one.
  external ffi.Pointer<ffi.Void> m_pIsolate;

  /// The embedder data slot to use in the v8::Isolate to store PDFium's
  /// per-isolate data. The value needs to be in the range
  /// [0, |v8::Internals::kNumIsolateDataLots|). Note that 0 is fine for most
  /// embedders.
  @ffi.UnsignedInt()
  external int m_v8EmbedderSlot;

  /// Pointer to the V8::Platform to use.
  external ffi.Pointer<ffi.Void> m_pPlatform;

  /// Explicit specification of core renderer to use. |m_RendererType| must be
  /// a valid value for |FPDF_LIBRARY_CONFIG| versions of this level or higher,
  /// or else the initialization will fail with an immediate crash.
  /// Note that use of a specified |FPDF_RENDERER_TYPE| value for which the
  /// corresponding render library is not included in the build will similarly
  /// fail with an immediate crash.
  @ffi.Int32()
  external int m_RendererType;
}

/// Structure for custom file access.
final class FPDF_FILEACCESS extends ffi.Struct {
  /// File length, in bytes.
  @ffi.UnsignedLong()
  external int m_FileLen;

  /// A function pointer for getting a block of data from a specific position.
  /// Position is specified by byte offset from the beginning of the file.
  /// The pointer to the buffer is never NULL and the size is never 0.
  /// The position and size will never go out of range of the file length.
  /// It may be possible for PDFium to call this function multiple times for
  /// the same position.
  /// Return value: should be non-zero if successful, zero for error.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void> param,
              ffi.UnsignedLong position,
              ffi.Pointer<ffi.UnsignedChar> pBuf,
              ffi.UnsignedLong size)>> m_GetBlock;

  /// A custom pointer for all implementation specific data.  This pointer will
  /// be used as the first parameter to the m_GetBlock callback.
  external ffi.Pointer<ffi.Void> m_Param;
}

/// Structure for file reading or writing (I/O).
///
/// Note: This is a handler and should be implemented by callers,
/// and is only used from XFA.
final class FPDF_FILEHANDLER_ extends ffi.Struct {
  /// User-defined data.
  /// Note: Callers can use this field to track controls.
  external ffi.Pointer<ffi.Void> clientData;

  /// Callback function to release the current file stream object.
  ///
  /// Parameters:
  /// clientData   -  Pointer to user-defined data.
  /// Returns:
  /// None.
  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> clientData)>>
      Release;

  /// Callback function to retrieve the current file stream size.
  ///
  /// Parameters:
  /// clientData   -  Pointer to user-defined data.
  /// Returns:
  /// Size of file stream.
  external ffi.Pointer<
      ffi.NativeFunction<
          FPDF_DWORD Function(ffi.Pointer<ffi.Void> clientData)>> GetSize;

  /// Callback function to read data from the current file stream.
  ///
  /// Parameters:
  /// clientData   -  Pointer to user-defined data.
  /// offset       -  Offset position starts from the beginning of file
  /// stream. This parameter indicates reading position.
  /// buffer       -  Memory buffer to store data which are read from
  /// file stream. This parameter should not be NULL.
  /// size         -  Size of data which should be read from file stream,
  /// in bytes. The buffer indicated by |buffer| must be
  /// large enough to store specified data.
  /// Returns:
  /// 0 for success, other value for failure.
  external ffi.Pointer<
      ffi.NativeFunction<
          FPDF_RESULT Function(
              ffi.Pointer<ffi.Void> clientData,
              FPDF_DWORD offset,
              ffi.Pointer<ffi.Void> buffer,
              FPDF_DWORD size)>> ReadBlock;

  /// Callback function to write data into the current file stream.
  ///
  /// Parameters:
  /// clientData   -  Pointer to user-defined data.
  /// offset       -  Offset position starts from the beginning of file
  /// stream. This parameter indicates writing position.
  /// buffer       -  Memory buffer contains data which is written into
  /// file stream. This parameter should not be NULL.
  /// size         -  Size of data which should be written into file
  /// stream, in bytes.
  /// Returns:
  /// 0 for success, other value for failure.
  external ffi.Pointer<
      ffi.NativeFunction<
          FPDF_RESULT Function(
              ffi.Pointer<ffi.Void> clientData,
              FPDF_DWORD offset,
              ffi.Pointer<ffi.Void> buffer,
              FPDF_DWORD size)>> WriteBlock;

  /// Callback function to flush all internal accessing buffers.
  ///
  /// Parameters:
  /// clientData   -  Pointer to user-defined data.
  /// Returns:
  /// 0 for success, other value for failure.
  external ffi.Pointer<
      ffi.NativeFunction<
          FPDF_RESULT Function(ffi.Pointer<ffi.Void> clientData)>> Flush;

  /// Callback function to change file size.
  ///
  /// Description:
  /// This function is called under writing mode usually. Implementer
  /// can determine whether to realize it based on application requests.
  /// Parameters:
  /// clientData   -  Pointer to user-defined data.
  /// size         -  New size of file stream, in bytes.
  /// Returns:
  /// 0 for success, other value for failure.
  external ffi.Pointer<
      ffi.NativeFunction<
          FPDF_RESULT Function(
              ffi.Pointer<ffi.Void> clientData, FPDF_DWORD size)>> Truncate;
}

typedef FPDF_DWORD = ffi.UnsignedLong;
typedef DartFPDF_DWORD = int;
typedef FPDF_RESULT = ffi.Int;
typedef DartFPDF_RESULT = int;

/// Struct for color scheme.
/// Each should be a 32-bit value specifying the color, in 8888 ARGB format.
final class FPDF_COLORSCHEME_ extends ffi.Struct {
  @FPDF_DWORD()
  external int path_fill_color;

  @FPDF_DWORD()
  external int path_stroke_color;

  @FPDF_DWORD()
  external int text_fill_color;

  @FPDF_DWORD()
  external int text_stroke_color;
}

typedef FPDF_PAGE = ffi.Pointer<fpdf_page_t__>;

/// Basic data types
typedef FPDF_BOOL = ffi.Int;
typedef DartFPDF_BOOL = int;

/// Matrix for transformation, in the form [a b c d e f], equivalent to:
/// | a  b  0 |
/// | c  d  0 |
/// | e  f  1 |
///
/// Translation is performed with [1 0 0 1 tx ty].
/// Scaling is performed with [sx 0 0 sy 0 0].
/// See PDF Reference 1.7, 4.2.2 Common Transformations for more.
typedef FS_MATRIX = _FS_MATRIX_;

/// Rectangle area(float) in device or page coordinate system.
typedef FS_RECTF = _FS_RECTF_;
typedef FPDF_PAGEOBJECT = ffi.Pointer<fpdf_pageobject_t__>;
typedef FPDF_CLIPPATH = ffi.Pointer<fpdf_clippath_t__>;
typedef FPDF_PATHSEGMENT = ffi.Pointer<fpdf_pathsegment_t>;

final class _IPDF_JsPlatform extends ffi.Struct {
  /// Version number of the interface. Currently must be 2.
  @ffi.Int()
  external int version;

  /// Method: app_alert
  /// Pop up a dialog to show warning or hint.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// yes
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself.
  /// Msg         -   A string containing the message to be displayed.
  /// Title       -   The title of the dialog.
  /// Type        -   The type of button group, one of the
  /// JSPLATFORM_ALERT_BUTTON_* values above.
  /// nIcon       -   The type of the icon, one of the
  /// JSPLATFORM_ALERT_ICON_* above.
  /// Return Value:
  /// Option selected by user in dialogue, one of the
  /// JSPLATFORM_ALERT_RETURN_* values above.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<_IPDF_JsPlatform> pThis,
              FPDF_WIDESTRING Msg,
              FPDF_WIDESTRING Title,
              ffi.Int Type,
              ffi.Int Icon)>> app_alert;

  /// Method: app_beep
  /// Causes the system to play a sound.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// yes
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself
  /// nType       -   The sound type, see JSPLATFORM_BEEP_TYPE_*
  /// above.
  /// Return Value:
  /// None
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<_IPDF_JsPlatform> pThis, ffi.Int nType)>> app_beep;

  /// Method: app_response
  /// Displays a dialog box containing a question and an entry field for
  /// the user to reply to the question.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// yes
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself
  /// Question    -   The question to be posed to the user.
  /// Title       -   The title of the dialog box.
  /// Default     -   A default value for the answer to the question. If
  /// not specified, no default value is presented.
  /// cLabel      -   A short string to appear in front of and on the
  /// same line as the edit text field.
  /// bPassword   -   If true, indicates that the user's response should
  /// be shown as asterisks (*) or bullets (?) to mask
  /// the response, which might be sensitive information.
  /// response    -   A string buffer allocated by PDFium, to receive the
  /// user's response.
  /// length      -   The length of the buffer in bytes. Currently, it is
  /// always 2048.
  /// Return Value:
  /// Number of bytes the complete user input would actually require, not
  /// including trailing zeros, regardless of the value of the length
  /// parameter or the presence of the response buffer.
  /// Comments:
  /// No matter on what platform, the response buffer should be always
  /// written using UTF-16LE encoding. If a response buffer is
  /// present and the size of the user input exceeds the capacity of the
  /// buffer as specified by the length parameter, only the
  /// first "length" bytes of the user input are to be written to the
  /// buffer.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<_IPDF_JsPlatform> pThis,
              FPDF_WIDESTRING Question,
              FPDF_WIDESTRING Title,
              FPDF_WIDESTRING Default,
              FPDF_WIDESTRING cLabel,
              FPDF_BOOL bPassword,
              ffi.Pointer<ffi.Void> response,
              ffi.Int length)>> app_response;

  /// Method: Doc_getFilePath
  /// Get the file path of the current document.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// yes
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself
  /// filePath    -   The string buffer to receive the file path. Can
  /// be NULL.
  /// length      -   The length of the buffer, number of bytes. Can
  /// be 0.
  /// Return Value:
  /// Number of bytes the filePath consumes, including trailing zeros.
  /// Comments:
  /// The filePath should always be provided in the local encoding.
  /// The return value always indicated number of bytes required for
  /// the buffer, even when there is no buffer specified, or the buffer
  /// size is less than required. In this case, the buffer will not
  /// be modified.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<_IPDF_JsPlatform> pThis,
              ffi.Pointer<ffi.Void> filePath, ffi.Int length)>> Doc_getFilePath;

  /// Method: Doc_mail
  /// Mails the data buffer as an attachment to all recipients, with or
  /// without user interaction.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// yes
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself
  /// mailData    -   Pointer to the data buffer to be sent. Can be NULL.
  /// length      -   The size,in bytes, of the buffer pointed by
  /// mailData parameter. Can be 0.
  /// bUI         -   If true, the rest of the parameters are used in a
  /// compose-new-message window that is displayed to the
  /// user. If false, the cTo parameter is required and
  /// all others are optional.
  /// To          -   A semicolon-delimited list of recipients for the
  /// message.
  /// Subject     -   The subject of the message. The length limit is
  /// 64 KB.
  /// CC          -   A semicolon-delimited list of CC recipients for
  /// the message.
  /// BCC         -   A semicolon-delimited list of BCC recipients for
  /// the message.
  /// Msg         -   The content of the message. The length limit is
  /// 64 KB.
  /// Return Value:
  /// None.
  /// Comments:
  /// If the parameter mailData is NULL or length is 0, the current
  /// document will be mailed as an attachment to all recipients.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<_IPDF_JsPlatform> pThis,
              ffi.Pointer<ffi.Void> mailData,
              ffi.Int length,
              FPDF_BOOL bUI,
              FPDF_WIDESTRING To,
              FPDF_WIDESTRING Subject,
              FPDF_WIDESTRING CC,
              FPDF_WIDESTRING BCC,
              FPDF_WIDESTRING Msg)>> Doc_mail;

  /// Method: Doc_print
  /// Prints all or a specific number of pages of the document.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// yes
  /// Parameters:
  /// pThis         -   Pointer to the interface structure itself.
  /// bUI           -   If true, will cause a UI to be presented to the
  /// user to obtain printing information and confirm
  /// the action.
  /// nStart        -   A 0-based index that defines the start of an
  /// inclusive range of pages.
  /// nEnd          -   A 0-based index that defines the end of an
  /// inclusive page range.
  /// bSilent       -   If true, suppresses the cancel dialog box while
  /// the document is printing. The default is false.
  /// bShrinkToFit  -   If true, the page is shrunk (if necessary) to
  /// fit within the imageable area of the printed page.
  /// bPrintAsImage -   If true, print pages as an image.
  /// bReverse      -   If true, print from nEnd to nStart.
  /// bAnnotations  -   If true (the default), annotations are
  /// printed.
  /// Return Value:
  /// None.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<_IPDF_JsPlatform> pThis,
              FPDF_BOOL bUI,
              ffi.Int nStart,
              ffi.Int nEnd,
              FPDF_BOOL bSilent,
              FPDF_BOOL bShrinkToFit,
              FPDF_BOOL bPrintAsImage,
              FPDF_BOOL bReverse,
              FPDF_BOOL bAnnotations)>> Doc_print;

  /// Method: Doc_submitForm
  /// Send the form data to a specified URL.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// yes
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself
  /// formData    -   Pointer to the data buffer to be sent.
  /// length      -   The size,in bytes, of the buffer pointed by
  /// formData parameter.
  /// URL         -   The URL to send to.
  /// Return Value:
  /// None.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<_IPDF_JsPlatform> pThis,
              ffi.Pointer<ffi.Void> formData,
              ffi.Int length,
              FPDF_WIDESTRING URL)>> Doc_submitForm;

  /// Method: Doc_gotoPage
  /// Jump to a specified page.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// yes
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself
  /// nPageNum    -   The specified page number, zero for the first page.
  /// Return Value:
  /// None.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<_IPDF_JsPlatform> pThis, ffi.Int nPageNum)>>
      Doc_gotoPage;

  /// Method: Field_browse
  /// Show a file selection dialog, and return the selected file path.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// yes
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself.
  /// filePath    -   Pointer to the data buffer to receive the file
  /// path. Can be NULL.
  /// length      -   The length of the buffer, in bytes. Can be 0.
  /// Return Value:
  /// Number of bytes the filePath consumes, including trailing zeros.
  /// Comments:
  /// The filePath should always be provided in local encoding.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<_IPDF_JsPlatform> pThis,
              ffi.Pointer<ffi.Void> filePath, ffi.Int length)>> Field_browse;

  /// Pointer for embedder-specific data. Unused by PDFium, and despite
  /// its name, can be any data the embedder desires, though traditionally
  /// a FPDF_FORMFILLINFO interface.
  external ffi.Pointer<ffi.Void> m_pFormfillinfo;

  /// Unused in v3, retain for compatibility.
  external ffi.Pointer<ffi.Void> m_isolate;

  /// Unused in v3, retain for compatibility.
  @ffi.UnsignedInt()
  external int m_v8EmbedderSlot;
}

/// The public PDFium API always uses UTF-16LE encoded wide strings, each
/// character uses 2 bytes (except surrogation), with the low byte first.
typedef FPDF_WIDESTRING = ffi.Pointer<FPDF_WCHAR>;

/// String types
typedef FPDF_WCHAR = ffi.UnsignedShort;
typedef DartFPDF_WCHAR = int;

/// Declares of a struct type to the local system time.
final class _FPDF_SYSTEMTIME extends ffi.Struct {
  /// years since 1900
  @ffi.UnsignedShort()
  external int wYear;

  /// months since January - [0,11]
  @ffi.UnsignedShort()
  external int wMonth;

  /// days since Sunday - [0,6]
  @ffi.UnsignedShort()
  external int wDayOfWeek;

  /// day of the month - [1,31]
  @ffi.UnsignedShort()
  external int wDay;

  /// hours since midnight - [0,23]
  @ffi.UnsignedShort()
  external int wHour;

  /// minutes after the hour - [0,59]
  @ffi.UnsignedShort()
  external int wMinute;

  /// seconds after the minute - [0,59]
  @ffi.UnsignedShort()
  external int wSecond;

  /// milliseconds after the second - [0,999]
  @ffi.UnsignedShort()
  external int wMilliseconds;
}

final class _FPDF_FORMFILLINFO extends ffi.Struct {
  /// Version number of the interface.
  /// Version 1 contains stable interfaces. Version 2 has additional
  /// experimental interfaces.
  /// When PDFium is built without the XFA module, version can be 1 or 2.
  /// With version 1, only stable interfaces are called. With version 2,
  /// additional experimental interfaces are also called.
  /// When PDFium is built with the XFA module, version must be 2.
  /// All the XFA related interfaces are experimental. If PDFium is built with
  /// the XFA module and version 1 then none of the XFA related interfaces
  /// would be called. When PDFium is built with XFA module then the version
  /// must be 2.
  @ffi.Int()
  external int version;

  /// Method: Release
  /// Give the implementation a chance to release any resources after the
  /// interface is no longer used.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// No
  /// Comments:
  /// Called by PDFium during the final cleanup process.
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself
  /// Return Value:
  /// None
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<_FPDF_FORMFILLINFO> pThis)>> Release;

  /// Method: FFI_Invalidate
  /// Invalidate the client area within the specified rectangle.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// yes
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself.
  /// page        -   Handle to the page. Returned by FPDF_LoadPage().
  /// left        -   Left position of the client area in PDF page
  /// coordinates.
  /// top         -   Top position of the client area in PDF page
  /// coordinates.
  /// right       -   Right position of the client area in PDF page
  /// coordinates.
  /// bottom      -   Bottom position of the client area in PDF page
  /// coordinates.
  /// Return Value:
  /// None.
  /// Comments:
  /// All positions are measured in PDF "user space".
  /// Implementation should call FPDF_RenderPageBitmap() for repainting
  /// the specified page area.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              FPDF_PAGE page,
              ffi.Double left,
              ffi.Double top,
              ffi.Double right,
              ffi.Double bottom)>> FFI_Invalidate;

  /// Method: FFI_OutputSelectedRect
  /// When the user selects text in form fields with the mouse, this
  /// callback function will be invoked with the selected areas.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// No
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself.
  /// page        -   Handle to the page. Returned by FPDF_LoadPage()/
  /// left        -   Left position of the client area in PDF page
  /// coordinates.
  /// top         -   Top position of the client area in PDF page
  /// coordinates.
  /// right       -   Right position of the client area in PDF page
  /// coordinates.
  /// bottom      -   Bottom position of the client area in PDF page
  /// coordinates.
  /// Return Value:
  /// None.
  /// Comments:
  /// This callback function is useful for implementing special text
  /// selection effects. An implementation should first record the
  /// returned rectangles, then draw them one by one during the next
  /// painting period. Lastly, it should remove all the recorded
  /// rectangles when finished painting.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              FPDF_PAGE page,
              ffi.Double left,
              ffi.Double top,
              ffi.Double right,
              ffi.Double bottom)>> FFI_OutputSelectedRect;

  /// Method: FFI_SetCursor
  /// Set the Cursor shape.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// yes
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself.
  /// nCursorType -   Cursor type, see Flags for Cursor type for details.
  /// Return value:
  /// None.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<_FPDF_FORMFILLINFO> pThis, ffi.Int nCursorType)>>
      FFI_SetCursor;

  /// Method: FFI_SetTimer
  /// This method installs a system timer. An interval value is specified,
  /// and every time that interval elapses, the system must call into the
  /// callback function with the timer ID as returned by this function.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// yes
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself.
  /// uElapse     -   Specifies the time-out value, in milliseconds.
  /// lpTimerFunc -   A pointer to the callback function-TimerCallback.
  /// Return value:
  /// The timer identifier of the new timer if the function is successful.
  /// An application passes this value to the FFI_KillTimer method to kill
  /// the timer. Nonzero if it is successful; otherwise, it is zero.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              ffi.Int uElapse, TimerCallback lpTimerFunc)>> FFI_SetTimer;

  /// Method: FFI_KillTimer
  /// This method uninstalls a system timer, as set by an earlier call to
  /// FFI_SetTimer.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// yes
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself.
  /// nTimerID    -   The timer ID returned by FFI_SetTimer function.
  /// Return value:
  /// None.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<_FPDF_FORMFILLINFO> pThis, ffi.Int nTimerID)>>
      FFI_KillTimer;

  /// Method: FFI_GetLocalTime
  /// This method receives the current local time on the system.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// yes
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself.
  /// Return value:
  /// The local time. See FPDF_SYSTEMTIME above for details.
  /// Note: Unused.
  external ffi.Pointer<
          ffi.NativeFunction<
              FPDF_SYSTEMTIME Function(ffi.Pointer<_FPDF_FORMFILLINFO> pThis)>>
      FFI_GetLocalTime;

  /// Method: FFI_OnChange
  /// This method will be invoked to notify the implementation when the
  /// value of any FormField on the document had been changed.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// no
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself.
  /// Return value:
  /// None.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<_FPDF_FORMFILLINFO> pThis)>>
      FFI_OnChange;

  /// Method: FFI_GetPage
  /// This method receives the page handle associated with a specified
  /// page index.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// yes
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself.
  /// document    -   Handle to document. Returned by FPDF_LoadDocument().
  /// nPageIndex  -   Index number of the page. 0 for the first page.
  /// Return value:
  /// Handle to the page, as previously returned to the implementation by
  /// FPDF_LoadPage().
  /// Comments:
  /// The implementation is expected to keep track of the page handles it
  /// receives from PDFium, and their mappings to page numbers. In some
  /// cases, the document-level JavaScript action may refer to a page
  /// which hadn't been loaded yet. To successfully run the Javascript
  /// action, the implementation needs to load the page.
  external ffi.Pointer<
      ffi.NativeFunction<
          FPDF_PAGE Function(ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              FPDF_DOCUMENT document, ffi.Int nPageIndex)>> FFI_GetPage;

  /// Method: FFI_GetCurrentPage
  /// This method receives the handle to the current page.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// Yes when V8 support is present, otherwise unused.
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself.
  /// document    -   Handle to document. Returned by FPDF_LoadDocument().
  /// Return value:
  /// Handle to the page. Returned by FPDF_LoadPage().
  /// Comments:
  /// PDFium doesn't keep keep track of the "current page" (e.g. the one
  /// that is most visible on screen), so it must ask the embedder for
  /// this information.
  external ffi.Pointer<
      ffi.NativeFunction<
          FPDF_PAGE Function(ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              FPDF_DOCUMENT document)>> FFI_GetCurrentPage;

  /// Method: FFI_GetRotation
  /// This method receives currently rotation of the page view.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// yes
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself.
  /// page        -   Handle to page, as returned by FPDF_LoadPage().
  /// Return value:
  /// A number to indicate the page rotation in 90 degree increments
  /// in a clockwise direction:
  /// 0 - 0 degrees
  /// 1 - 90 degrees
  /// 2 - 180 degrees
  /// 3 - 270 degrees
  /// Note: Unused.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<_FPDF_FORMFILLINFO> pThis, FPDF_PAGE page)>>
      FFI_GetRotation;

  /// Method: FFI_ExecuteNamedAction
  /// This method will execute a named action.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// yes
  /// Parameters:
  /// pThis           -   Pointer to the interface structure itself.
  /// namedAction     -   A byte string which indicates the named action,
  /// terminated by 0.
  /// Return value:
  /// None.
  /// Comments:
  /// See ISO 32000-1:2008, section 12.6.4.11 for descriptions of the
  /// standard named actions, but note that a document may supply any
  /// name of its choosing.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              FPDF_BYTESTRING namedAction)>> FFI_ExecuteNamedAction;

  /// Method: FFI_SetTextFieldFocus
  /// Called when a text field is getting or losing focus.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// no
  /// Parameters:
  /// pThis           -   Pointer to the interface structure itself.
  /// value           -   The string value of the form field, in UTF-16LE
  /// format.
  /// valueLen        -   The length of the string value. This is the
  /// number of characters, not bytes.
  /// is_focus        -   True if the form field is getting focus, false
  /// if the form field is losing focus.
  /// Return value:
  /// None.
  /// Comments:
  /// Only supports text fields and combobox fields.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              FPDF_WIDESTRING value,
              FPDF_DWORD valueLen,
              FPDF_BOOL is_focus)>> FFI_SetTextFieldFocus;

  /// Method: FFI_DoURIAction
  /// Ask the implementation to navigate to a uniform resource identifier.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// No
  /// Parameters:
  /// pThis           -   Pointer to the interface structure itself.
  /// bsURI           -   A byte string which indicates the uniform
  /// resource identifier, terminated by 0.
  /// Return value:
  /// None.
  /// Comments:
  /// If the embedder is version 2 or higher and have implementation for
  /// FFI_DoURIActionWithKeyboardModifier, then
  /// FFI_DoURIActionWithKeyboardModifier takes precedence over
  /// FFI_DoURIAction.
  /// See the URI actions description of <<PDF Reference, version 1.7>>
  /// for more details.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              FPDF_BYTESTRING bsURI)>> FFI_DoURIAction;

  /// Method: FFI_DoGoToAction
  /// This action changes the view to a specified destination.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// No
  /// Parameters:
  /// pThis           -   Pointer to the interface structure itself.
  /// nPageIndex      -   The index of the PDF page.
  /// zoomMode        -   The zoom mode for viewing page. See below.
  /// fPosArray       -   The float array which carries the position info.
  /// sizeofArray     -   The size of float array.
  /// PDFZoom values:
  /// - XYZ = 1
  /// - FITPAGE = 2
  /// - FITHORZ = 3
  /// - FITVERT = 4
  /// - FITRECT = 5
  /// - FITBBOX = 6
  /// - FITBHORZ = 7
  /// - FITBVERT = 8
  /// Return value:
  /// None.
  /// Comments:
  /// See the Destinations description of <<PDF Reference, version 1.7>>
  /// in 8.2.1 for more details.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              ffi.Int nPageIndex,
              ffi.Int zoomMode,
              ffi.Pointer<ffi.Float> fPosArray,
              ffi.Int sizeofArray)>> FFI_DoGoToAction;

  /// Pointer to IPDF_JSPLATFORM interface.
  /// Unused if PDFium is built without V8 support. Otherwise, if NULL, then
  /// JavaScript will be prevented from executing while rendering the document.
  external ffi.Pointer<IPDF_JSPLATFORM> m_pJsPlatform;

  /// Whether the XFA module is disabled when built with the XFA module.
  /// Interface Version:
  /// Ignored if |version| < 2.
  @FPDF_BOOL()
  external int xfa_disabled;

  /// Method: FFI_DisplayCaret
  /// This method will show the caret at specified position.
  /// Interface Version:
  /// Ignored if |version| < 2.
  /// Implementation Required:
  /// Required for XFA, otherwise set to NULL.
  /// Parameters:
  /// pThis           -   Pointer to the interface structure itself.
  /// page            -   Handle to page. Returned by FPDF_LoadPage().
  /// left            -   Left position of the client area in PDF page
  /// coordinates.
  /// top             -   Top position of the client area in PDF page
  /// coordinates.
  /// right           -   Right position of the client area in PDF page
  /// coordinates.
  /// bottom          -   Bottom position of the client area in PDF page
  /// coordinates.
  /// Return value:
  /// None.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              FPDF_PAGE page,
              FPDF_BOOL bVisible,
              ffi.Double left,
              ffi.Double top,
              ffi.Double right,
              ffi.Double bottom)>> FFI_DisplayCaret;

  /// Method: FFI_GetCurrentPageIndex
  /// This method will get the current page index.
  /// Interface Version:
  /// Ignored if |version| < 2.
  /// Implementation Required:
  /// Required for XFA, otherwise set to NULL.
  /// Parameters:
  /// pThis           -   Pointer to the interface structure itself.
  /// document        -   Handle to document from FPDF_LoadDocument().
  /// Return value:
  /// The index of current page.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              FPDF_DOCUMENT document)>> FFI_GetCurrentPageIndex;

  /// Method: FFI_SetCurrentPage
  /// This method will set the current page.
  /// Interface Version:
  /// Ignored if |version| < 2.
  /// Implementation Required:
  /// Required for XFA, otherwise set to NULL.
  /// Parameters:
  /// pThis           -   Pointer to the interface structure itself.
  /// document        -   Handle to document from FPDF_LoadDocument().
  /// iCurPage        -   The index of the PDF page.
  /// Return value:
  /// None.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              FPDF_DOCUMENT document, ffi.Int iCurPage)>> FFI_SetCurrentPage;

  /// Method: FFI_GotoURL
  /// This method will navigate to the specified URL.
  /// Interface Version:
  /// Ignored if |version| < 2.
  /// Implementation Required:
  /// Required for XFA, otherwise set to NULL.
  /// Parameters:
  /// pThis            -   Pointer to the interface structure itself.
  /// document         -   Handle to document from FPDF_LoadDocument().
  /// wsURL            -   The string value of the URL, in UTF-16LE format.
  /// Return value:
  /// None.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              FPDF_DOCUMENT document, FPDF_WIDESTRING wsURL)>> FFI_GotoURL;

  /// Method: FFI_GetPageViewRect
  /// This method will get the current page view rectangle.
  /// Interface Version:
  /// Ignored if |version| < 2.
  /// Implementation Required:
  /// Required for XFA, otherwise set to NULL.
  /// Parameters:
  /// pThis           -   Pointer to the interface structure itself.
  /// page            -   Handle to page. Returned by FPDF_LoadPage().
  /// left            -   The pointer to receive left position of the page
  /// view area in PDF page coordinates.
  /// top             -   The pointer to receive top position of the page
  /// view area in PDF page coordinates.
  /// right           -   The pointer to receive right position of the
  /// page view area in PDF page coordinates.
  /// bottom          -   The pointer to receive bottom position of the
  /// page view area in PDF page coordinates.
  /// Return value:
  /// None.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              FPDF_PAGE page,
              ffi.Pointer<ffi.Double> left,
              ffi.Pointer<ffi.Double> top,
              ffi.Pointer<ffi.Double> right,
              ffi.Pointer<ffi.Double> bottom)>> FFI_GetPageViewRect;

  /// Method: FFI_PageEvent
  /// This method fires when pages have been added to or deleted from
  /// the XFA document.
  /// Interface Version:
  /// Ignored if |version| < 2.
  /// Implementation Required:
  /// Required for XFA, otherwise set to NULL.
  /// Parameters:
  /// pThis           -   Pointer to the interface structure itself.
  /// page_count      -   The number of pages to be added or deleted.
  /// event_type      -   See FXFA_PAGEVIEWEVENT_* above.
  /// Return value:
  /// None.
  /// Comments:
  /// The pages to be added or deleted always start from the last page
  /// of document. This means that if parameter page_count is 2 and
  /// event type is FXFA_PAGEVIEWEVENT_POSTADDED, 2 new pages have been
  /// appended to the tail of document; If page_count is 2 and
  /// event type is FXFA_PAGEVIEWEVENT_POSTREMOVED, the last 2 pages
  /// have been deleted.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              ffi.Int page_count, FPDF_DWORD event_type)>> FFI_PageEvent;

  /// Method: FFI_PopupMenu
  /// This method will track the right context menu for XFA fields.
  /// Interface Version:
  /// Ignored if |version| < 2.
  /// Implementation Required:
  /// Required for XFA, otherwise set to NULL.
  /// Parameters:
  /// pThis           -   Pointer to the interface structure itself.
  /// page            -   Handle to page. Returned by FPDF_LoadPage().
  /// hWidget         -   Always null, exists for compatibility.
  /// menuFlag        -   The menu flags. Please refer to macro definition
  /// of FXFA_MENU_XXX and this can be one or a
  /// combination of these macros.
  /// x               -   X position of the client area in PDF page
  /// coordinates.
  /// y               -   Y position of the client area in PDF page
  /// coordinates.
  /// Return value:
  /// TRUE indicates success; otherwise false.
  external ffi.Pointer<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              FPDF_PAGE page,
              FPDF_WIDGET hWidget,
              ffi.Int menuFlag,
              ffi.Float x,
              ffi.Float y)>> FFI_PopupMenu;

  /// Method: FFI_OpenFile
  /// This method will open the specified file with the specified mode.
  /// Interface Version:
  /// Ignored if |version| < 2.
  /// Implementation Required:
  /// Required for XFA, otherwise set to NULL.
  /// Parameters:
  /// pThis           -   Pointer to the interface structure itself.
  /// fileFlag        -   The file flag. Please refer to macro definition
  /// of FXFA_SAVEAS_XXX and use one of these macros.
  /// wsURL           -   The string value of the file URL, in UTF-16LE
  /// format.
  /// mode            -   The mode for open file, e.g. "rb" or "wb".
  /// Return value:
  /// The handle to FPDF_FILEHANDLER.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<FPDF_FILEHANDLER> Function(
              ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              ffi.Int fileFlag,
              FPDF_WIDESTRING wsURL,
              ffi.Pointer<ffi.Char> mode)>> FFI_OpenFile;

  /// Method: FFI_EmailTo
  /// This method will email the specified file stream to the specified
  /// contact.
  /// Interface Version:
  /// Ignored if |version| < 2.
  /// Implementation Required:
  /// Required for XFA, otherwise set to NULL.
  /// Parameters:
  /// pThis           -   Pointer to the interface structure itself.
  /// pFileHandler    -   Handle to the FPDF_FILEHANDLER.
  /// pTo             -   A semicolon-delimited list of recipients for the
  /// message,in UTF-16LE format.
  /// pSubject        -   The subject of the message,in UTF-16LE format.
  /// pCC             -   A semicolon-delimited list of CC recipients for
  /// the message,in UTF-16LE format.
  /// pBcc            -   A semicolon-delimited list of BCC recipients for
  /// the message,in UTF-16LE format.
  /// pMsg            -   Pointer to the data buffer to be sent.Can be
  /// NULL,in UTF-16LE format.
  /// Return value:
  /// None.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              ffi.Pointer<FPDF_FILEHANDLER> fileHandler,
              FPDF_WIDESTRING pTo,
              FPDF_WIDESTRING pSubject,
              FPDF_WIDESTRING pCC,
              FPDF_WIDESTRING pBcc,
              FPDF_WIDESTRING pMsg)>> FFI_EmailTo;

  /// Method: FFI_UploadTo
  /// This method will upload the specified file stream to the
  /// specified URL.
  /// Interface Version:
  /// Ignored if |version| < 2.
  /// Implementation Required:
  /// Required for XFA, otherwise set to NULL.
  /// Parameters:
  /// pThis           -   Pointer to the interface structure itself.
  /// pFileHandler    -   Handle to the FPDF_FILEHANDLER.
  /// fileFlag        -   The file flag. Please refer to macro definition
  /// of FXFA_SAVEAS_XXX and use one of these macros.
  /// uploadTo        -   Pointer to the URL path, in UTF-16LE format.
  /// Return value:
  /// None.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              ffi.Pointer<FPDF_FILEHANDLER> fileHandler,
              ffi.Int fileFlag,
              FPDF_WIDESTRING uploadTo)>> FFI_UploadTo;

  /// Method: FFI_GetPlatform
  /// This method will get the current platform.
  /// Interface Version:
  /// Ignored if |version| < 2.
  /// Implementation Required:
  /// Required for XFA, otherwise set to NULL.
  /// Parameters:
  /// pThis           -   Pointer to the interface structure itself.
  /// platform        -   Pointer to the data buffer to receive the
  /// platform,in UTF-16LE format. Can be NULL.
  /// length          -   The length of the buffer in bytes. Can be
  /// 0 to query the required size.
  /// Return value:
  /// The length of the buffer, number of bytes.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              ffi.Pointer<ffi.Void> platform, ffi.Int length)>> FFI_GetPlatform;

  /// Method: FFI_GetLanguage
  /// This method will get the current language.
  /// Interface Version:
  /// Ignored if |version| < 2.
  /// Implementation Required:
  /// Required for XFA, otherwise set to NULL.
  /// Parameters:
  /// pThis           -   Pointer to the interface structure itself.
  /// language        -   Pointer to the data buffer to receive the
  /// current language. Can be NULL.
  /// length          -   The length of the buffer in bytes. Can be
  /// 0 to query the required size.
  /// Return value:
  /// The length of the buffer, number of bytes.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              ffi.Pointer<ffi.Void> language, ffi.Int length)>> FFI_GetLanguage;

  /// Method: FFI_DownloadFromURL
  /// This method will download the specified file from the URL.
  /// Interface Version:
  /// Ignored if |version| < 2.
  /// Implementation Required:
  /// Required for XFA, otherwise set to NULL.
  /// Parameters:
  /// pThis           -   Pointer to the interface structure itself.
  /// URL             -   The string value of the file URL, in UTF-16LE
  /// format.
  /// Return value:
  /// The handle to FPDF_FILEHANDLER.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<FPDF_FILEHANDLER> Function(
                  ffi.Pointer<_FPDF_FORMFILLINFO> pThis, FPDF_WIDESTRING URL)>>
      FFI_DownloadFromURL;

  /// Method: FFI_PostRequestURL
  /// This method will post the request to the server URL.
  /// Interface Version:
  /// Ignored if |version| < 2.
  /// Implementation Required:
  /// Required for XFA, otherwise set to NULL.
  /// Parameters:
  /// pThis           -   Pointer to the interface structure itself.
  /// wsURL           -   The string value of the server URL, in UTF-16LE
  /// format.
  /// wsData          -   The post data,in UTF-16LE format.
  /// wsContentType   -   The content type of the request data, in
  /// UTF-16LE format.
  /// wsEncode        -   The encode type, in UTF-16LE format.
  /// wsHeader        -   The request header,in UTF-16LE format.
  /// response        -   Pointer to the FPDF_BSTR to receive the response
  /// data from the server, in UTF-16LE format.
  /// Return value:
  /// TRUE indicates success, otherwise FALSE.
  external ffi.Pointer<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              FPDF_WIDESTRING wsURL,
              FPDF_WIDESTRING wsData,
              FPDF_WIDESTRING wsContentType,
              FPDF_WIDESTRING wsEncode,
              FPDF_WIDESTRING wsHeader,
              ffi.Pointer<FPDF_BSTR> response)>> FFI_PostRequestURL;

  /// Method: FFI_PutRequestURL
  /// This method will put the request to the server URL.
  /// Interface Version:
  /// Ignored if |version| < 2.
  /// Implementation Required:
  /// Required for XFA, otherwise set to NULL.
  /// Parameters:
  /// pThis           -   Pointer to the interface structure itself.
  /// wsURL           -   The string value of the server URL, in UTF-16LE
  /// format.
  /// wsData          -   The put data, in UTF-16LE format.
  /// wsEncode        -   The encode type, in UTR-16LE format.
  /// Return value:
  /// TRUE indicates success, otherwise FALSE.
  external ffi.Pointer<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              ffi.Pointer<_FPDF_FORMFILLINFO> pThis,
              FPDF_WIDESTRING wsURL,
              FPDF_WIDESTRING wsData,
              FPDF_WIDESTRING wsEncode)>> FFI_PutRequestURL;

  /// Method: FFI_OnFocusChange
  /// Called when the focused annotation is updated.
  /// Interface Version:
  /// Ignored if |version| < 2.
  /// Implementation Required:
  /// No
  /// Parameters:
  /// param           -   Pointer to the interface structure itself.
  /// annot           -   The focused annotation.
  /// page_index      -   Index number of the page which contains the
  /// focused annotation. 0 for the first page.
  /// Return value:
  /// None.
  /// Comments:
  /// This callback function is useful for implementing any view based
  /// action such as scrolling the annotation rect into view. The
  /// embedder should not copy and store the annot as its scope is
  /// limited to this call only.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<_FPDF_FORMFILLINFO> param,
              FPDF_ANNOTATION annot, ffi.Int page_index)>> FFI_OnFocusChange;

  /// Method: FFI_DoURIActionWithKeyboardModifier
  /// Ask the implementation to navigate to a uniform resource identifier
  /// with the specified modifiers.
  /// Interface Version:
  /// Ignored if |version| < 2.
  /// Implementation Required:
  /// No
  /// Parameters:
  /// param           -   Pointer to the interface structure itself.
  /// uri             -   A byte string which indicates the uniform
  /// resource identifier, terminated by 0.
  /// modifiers       -   Keyboard modifier that indicates which of
  /// the virtual keys are down, if any.
  /// Return value:
  /// None.
  /// Comments:
  /// If the embedder who is version 2 and does not implement this API,
  /// then a call will be redirected to FFI_DoURIAction.
  /// See the URI actions description of <<PDF Reference, version 1.7>>
  /// for more details.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<_FPDF_FORMFILLINFO> param,
              FPDF_BYTESTRING uri,
              ffi.Int modifiers)>> FFI_DoURIActionWithKeyboardModifier;
}

/// Function signature for the callback function passed to the FFI_SetTimer
/// method.
/// Parameters:
/// idEvent     -   Identifier of the timer.
/// Return value:
/// None.
typedef TimerCallback = ffi.Pointer<ffi.NativeFunction<TimerCallbackFunction>>;
typedef TimerCallbackFunction = ffi.Void Function(ffi.Int idEvent);
typedef DartTimerCallbackFunction = void Function(int idEvent);

/// Declares of a struct type to the local system time.
typedef FPDF_SYSTEMTIME = _FPDF_SYSTEMTIME;
typedef FPDF_DOCUMENT = ffi.Pointer<fpdf_document_t__>;

/// Public PDFium API type for byte strings.
typedef FPDF_BYTESTRING = ffi.Pointer<ffi.Char>;
typedef IPDF_JSPLATFORM = _IPDF_JsPlatform;
typedef FPDF_WIDGET = ffi.Pointer<fpdf_widget_t__>;

/// Structure for file reading or writing (I/O).
///
/// Note: This is a handler and should be implemented by callers,
/// and is only used from XFA.
typedef FPDF_FILEHANDLER = FPDF_FILEHANDLER_;

/// Structure for persisting a string beyond the duration of a callback.
/// Note: although represented as a char*, string may be interpreted as
/// a UTF-16LE formated string. Used only by XFA callbacks.
typedef FPDF_BSTR = FPDF_BSTR_;
typedef FPDF_ANNOTATION = ffi.Pointer<fpdf_annotation_t__>;

abstract class FPDFANNOT_COLORTYPE {
  static const int FPDFANNOT_COLORTYPE_Color = 0;
  static const int FPDFANNOT_COLORTYPE_InteriorColor = 1;
}

/// Annotation enums.
typedef FPDF_ANNOTATION_SUBTYPE = ffi.Int;
typedef DartFPDF_ANNOTATION_SUBTYPE = int;

/// 2D Point. Coordinate system agnostic.
typedef FS_POINTF = FS_POINTF_;
typedef FS_QUADPOINTSF = _FS_QUADPOINTSF;
typedef FPDF_FORMHANDLE = ffi.Pointer<fpdf_form_handle_t__>;

/// Dictionary value types.
typedef FPDF_OBJECT_TYPE = ffi.Int;
typedef DartFPDF_OBJECT_TYPE = int;
typedef FPDF_ANNOT_APPEARANCEMODE = ffi.Int;
typedef DartFPDF_ANNOT_APPEARANCEMODE = int;
typedef FPDF_LINK = ffi.Pointer<fpdf_link_t__>;
typedef FPDF_ATTACHMENT = ffi.Pointer<fpdf_attachment_t__>;
typedef FPDF_TEXTPAGE = ffi.Pointer<fpdf_textpage_t__>;

/// Structure for custom file write
final class FPDF_FILEWRITE_ extends ffi.Struct {
  /// Version number of the interface. Currently must be 1.
  @ffi.Int()
  external int version;

  /// Method: WriteBlock
  /// Output a block of data in your custom way.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// Yes
  /// Comments:
  /// Called by function FPDF_SaveDocument
  /// Parameters:
  /// pThis       -   Pointer to the structure itself
  /// pData       -   Pointer to a buffer to output
  /// size        -   The size of the buffer.
  /// Return value:
  /// Should be non-zero if successful, zero for error.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FPDF_FILEWRITE_> pThis,
              ffi.Pointer<ffi.Void> pData, ffi.UnsignedLong size)>> WriteBlock;
}

/// Structure for custom file write
typedef FPDF_FILEWRITE = FPDF_FILEWRITE_;

/// The file identifier entry type. See section 14.4 "File Identifiers" of the
/// ISO 32000-1:2008 spec.
abstract class FPDF_FILEIDTYPE {
  static const int FILEIDTYPE_PERMANENT = 0;
  static const int FILEIDTYPE_CHANGING = 1;
}

typedef FPDF_BOOKMARK = ffi.Pointer<fpdf_bookmark_t__>;
typedef FPDF_DEST = ffi.Pointer<fpdf_dest_t__>;

/// PDF types - use incomplete types (never completed) to force API type safety.
typedef FPDF_ACTION = ffi.Pointer<fpdf_action_t__>;
typedef FPDF_FORMFILLINFO = _FPDF_FORMFILLINFO;
typedef FPDF_BITMAP = ffi.Pointer<fpdf_bitmap_t__>;

/// Key flags.
abstract class FWL_EVENTFLAG {
  static const int FWL_EVENTFLAG_ShiftKey = 1;
  static const int FWL_EVENTFLAG_ControlKey = 2;
  static const int FWL_EVENTFLAG_AltKey = 4;
  static const int FWL_EVENTFLAG_MetaKey = 8;
  static const int FWL_EVENTFLAG_KeyPad = 16;
  static const int FWL_EVENTFLAG_AutoRepeat = 32;
  static const int FWL_EVENTFLAG_LeftButtonDown = 64;
  static const int FWL_EVENTFLAG_MiddleButtonDown = 128;
  static const int FWL_EVENTFLAG_RightButtonDown = 256;
}

/// Virtual keycodes.
abstract class FWL_VKEYCODE {
  static const int FWL_VKEY_Back = 8;
  static const int FWL_VKEY_Tab = 9;
  static const int FWL_VKEY_NewLine = 10;
  static const int FWL_VKEY_Clear = 12;
  static const int FWL_VKEY_Return = 13;
  static const int FWL_VKEY_Shift = 16;
  static const int FWL_VKEY_Control = 17;
  static const int FWL_VKEY_Menu = 18;
  static const int FWL_VKEY_Pause = 19;
  static const int FWL_VKEY_Capital = 20;
  static const int FWL_VKEY_Kana = 21;
  static const int FWL_VKEY_Hangul = 21;
  static const int FWL_VKEY_Junja = 23;
  static const int FWL_VKEY_Final = 24;
  static const int FWL_VKEY_Hanja = 25;
  static const int FWL_VKEY_Kanji = 25;
  static const int FWL_VKEY_Escape = 27;
  static const int FWL_VKEY_Convert = 28;
  static const int FWL_VKEY_NonConvert = 29;
  static const int FWL_VKEY_Accept = 30;
  static const int FWL_VKEY_ModeChange = 31;
  static const int FWL_VKEY_Space = 32;
  static const int FWL_VKEY_Prior = 33;
  static const int FWL_VKEY_Next = 34;
  static const int FWL_VKEY_End = 35;
  static const int FWL_VKEY_Home = 36;
  static const int FWL_VKEY_Left = 37;
  static const int FWL_VKEY_Up = 38;
  static const int FWL_VKEY_Right = 39;
  static const int FWL_VKEY_Down = 40;
  static const int FWL_VKEY_Select = 41;
  static const int FWL_VKEY_Print = 42;
  static const int FWL_VKEY_Execute = 43;
  static const int FWL_VKEY_Snapshot = 44;
  static const int FWL_VKEY_Insert = 45;
  static const int FWL_VKEY_Delete = 46;
  static const int FWL_VKEY_Help = 47;
  static const int FWL_VKEY_0 = 48;
  static const int FWL_VKEY_1 = 49;
  static const int FWL_VKEY_2 = 50;
  static const int FWL_VKEY_3 = 51;
  static const int FWL_VKEY_4 = 52;
  static const int FWL_VKEY_5 = 53;
  static const int FWL_VKEY_6 = 54;
  static const int FWL_VKEY_7 = 55;
  static const int FWL_VKEY_8 = 56;
  static const int FWL_VKEY_9 = 57;
  static const int FWL_VKEY_A = 65;
  static const int FWL_VKEY_B = 66;
  static const int FWL_VKEY_C = 67;
  static const int FWL_VKEY_D = 68;
  static const int FWL_VKEY_E = 69;
  static const int FWL_VKEY_F = 70;
  static const int FWL_VKEY_G = 71;
  static const int FWL_VKEY_H = 72;
  static const int FWL_VKEY_I = 73;
  static const int FWL_VKEY_J = 74;
  static const int FWL_VKEY_K = 75;
  static const int FWL_VKEY_L = 76;
  static const int FWL_VKEY_M = 77;
  static const int FWL_VKEY_N = 78;
  static const int FWL_VKEY_O = 79;
  static const int FWL_VKEY_P = 80;
  static const int FWL_VKEY_Q = 81;
  static const int FWL_VKEY_R = 82;
  static const int FWL_VKEY_S = 83;
  static const int FWL_VKEY_T = 84;
  static const int FWL_VKEY_U = 85;
  static const int FWL_VKEY_V = 86;
  static const int FWL_VKEY_W = 87;
  static const int FWL_VKEY_X = 88;
  static const int FWL_VKEY_Y = 89;
  static const int FWL_VKEY_Z = 90;
  static const int FWL_VKEY_LWin = 91;
  static const int FWL_VKEY_Command = 91;
  static const int FWL_VKEY_RWin = 92;
  static const int FWL_VKEY_Apps = 93;
  static const int FWL_VKEY_Sleep = 95;
  static const int FWL_VKEY_NumPad0 = 96;
  static const int FWL_VKEY_NumPad1 = 97;
  static const int FWL_VKEY_NumPad2 = 98;
  static const int FWL_VKEY_NumPad3 = 99;
  static const int FWL_VKEY_NumPad4 = 100;
  static const int FWL_VKEY_NumPad5 = 101;
  static const int FWL_VKEY_NumPad6 = 102;
  static const int FWL_VKEY_NumPad7 = 103;
  static const int FWL_VKEY_NumPad8 = 104;
  static const int FWL_VKEY_NumPad9 = 105;
  static const int FWL_VKEY_Multiply = 106;
  static const int FWL_VKEY_Add = 107;
  static const int FWL_VKEY_Separator = 108;
  static const int FWL_VKEY_Subtract = 109;
  static const int FWL_VKEY_Decimal = 110;
  static const int FWL_VKEY_Divide = 111;
  static const int FWL_VKEY_F1 = 112;
  static const int FWL_VKEY_F2 = 113;
  static const int FWL_VKEY_F3 = 114;
  static const int FWL_VKEY_F4 = 115;
  static const int FWL_VKEY_F5 = 116;
  static const int FWL_VKEY_F6 = 117;
  static const int FWL_VKEY_F7 = 118;
  static const int FWL_VKEY_F8 = 119;
  static const int FWL_VKEY_F9 = 120;
  static const int FWL_VKEY_F10 = 121;
  static const int FWL_VKEY_F11 = 122;
  static const int FWL_VKEY_F12 = 123;
  static const int FWL_VKEY_F13 = 124;
  static const int FWL_VKEY_F14 = 125;
  static const int FWL_VKEY_F15 = 126;
  static const int FWL_VKEY_F16 = 127;
  static const int FWL_VKEY_F17 = 128;
  static const int FWL_VKEY_F18 = 129;
  static const int FWL_VKEY_F19 = 130;
  static const int FWL_VKEY_F20 = 131;
  static const int FWL_VKEY_F21 = 132;
  static const int FWL_VKEY_F22 = 133;
  static const int FWL_VKEY_F23 = 134;
  static const int FWL_VKEY_F24 = 135;
  static const int FWL_VKEY_NunLock = 144;
  static const int FWL_VKEY_Scroll = 145;
  static const int FWL_VKEY_LShift = 160;
  static const int FWL_VKEY_RShift = 161;
  static const int FWL_VKEY_LControl = 162;
  static const int FWL_VKEY_RControl = 163;
  static const int FWL_VKEY_LMenu = 164;
  static const int FWL_VKEY_RMenu = 165;
  static const int FWL_VKEY_BROWSER_Back = 166;
  static const int FWL_VKEY_BROWSER_Forward = 167;
  static const int FWL_VKEY_BROWSER_Refresh = 168;
  static const int FWL_VKEY_BROWSER_Stop = 169;
  static const int FWL_VKEY_BROWSER_Search = 170;
  static const int FWL_VKEY_BROWSER_Favorites = 171;
  static const int FWL_VKEY_BROWSER_Home = 172;
  static const int FWL_VKEY_VOLUME_Mute = 173;
  static const int FWL_VKEY_VOLUME_Down = 174;
  static const int FWL_VKEY_VOLUME_Up = 175;
  static const int FWL_VKEY_MEDIA_NEXT_Track = 176;
  static const int FWL_VKEY_MEDIA_PREV_Track = 177;
  static const int FWL_VKEY_MEDIA_Stop = 178;
  static const int FWL_VKEY_MEDIA_PLAY_Pause = 179;
  static const int FWL_VKEY_MEDIA_LAUNCH_Mail = 180;
  static const int FWL_VKEY_MEDIA_LAUNCH_MEDIA_Select = 181;
  static const int FWL_VKEY_MEDIA_LAUNCH_APP1 = 182;
  static const int FWL_VKEY_MEDIA_LAUNCH_APP2 = 183;
  static const int FWL_VKEY_OEM_1 = 186;
  static const int FWL_VKEY_OEM_Plus = 187;
  static const int FWL_VKEY_OEM_Comma = 188;
  static const int FWL_VKEY_OEM_Minus = 189;
  static const int FWL_VKEY_OEM_Period = 190;
  static const int FWL_VKEY_OEM_2 = 191;
  static const int FWL_VKEY_OEM_3 = 192;
  static const int FWL_VKEY_OEM_4 = 219;
  static const int FWL_VKEY_OEM_5 = 220;
  static const int FWL_VKEY_OEM_6 = 221;
  static const int FWL_VKEY_OEM_7 = 222;
  static const int FWL_VKEY_OEM_8 = 223;
  static const int FWL_VKEY_OEM_102 = 226;
  static const int FWL_VKEY_ProcessKey = 229;
  static const int FWL_VKEY_Packet = 231;
  static const int FWL_VKEY_Attn = 246;
  static const int FWL_VKEY_Crsel = 247;
  static const int FWL_VKEY_Exsel = 248;
  static const int FWL_VKEY_Ereof = 249;
  static const int FWL_VKEY_Play = 250;
  static const int FWL_VKEY_Zoom = 251;
  static const int FWL_VKEY_NoName = 252;
  static const int FWL_VKEY_PA1 = 253;
  static const int FWL_VKEY_OEM_Clear = 254;
  static const int FWL_VKEY_Unknown = 0;
}

typedef FPDF_SIGNATURE = ffi.Pointer<fpdf_signature_t__>;
typedef FPDF_STRUCTTREE = ffi.Pointer<fpdf_structtree_t__>;
typedef FPDF_STRUCTELEMENT = ffi.Pointer<fpdf_structelement_t__>;
typedef FPDF_STRUCTELEMENT_ATTR = ffi.Pointer<fpdf_structelement_attr_t__>;
typedef FPDF_STRUCTELEMENT_ATTR_VALUE
    = ffi.Pointer<fpdf_structelement_attr_value_t__>;
typedef FPDF_XOBJECT = ffi.Pointer<fpdf_xobject_t__>;

/// Process-wide options for initializing the library.
typedef FPDF_LIBRARY_CONFIG = FPDF_LIBRARY_CONFIG_;

/// For Windows programmers: In most cases it's OK to treat FPDF_WIDESTRING as a
/// Windows unicode string, however, special care needs to be taken if you
/// expect to process Unicode larger than 0xffff.
///
/// For Linux/Unix programmers: most compiler/library environments use 4 bytes
/// for a Unicode character, and you have to convert between FPDF_WIDESTRING and
/// system wide string by yourself.
typedef FPDF_STRING = ffi.Pointer<ffi.Char>;

/// Rectangle size. Coordinate system agnostic.
typedef FS_SIZEF = FS_SIZEF_;
typedef FPDF_PAGERANGE = ffi.Pointer<fpdf_pagerange_t__>;

final class FPDF_IMAGEOBJ_METADATA extends ffi.Struct {
  /// The image width in pixels.
  @ffi.UnsignedInt()
  external int width;

  /// The image height in pixels.
  @ffi.UnsignedInt()
  external int height;

  /// The image's horizontal pixel-per-inch.
  @ffi.Float()
  external double horizontal_dpi;

  /// The image's vertical pixel-per-inch.
  @ffi.Float()
  external double vertical_dpi;

  /// The number of bits used to represent each pixel.
  @ffi.UnsignedInt()
  external int bits_per_pixel;

  /// The image's colorspace. See above for the list of FPDF_COLORSPACE_*.
  @ffi.Int()
  external int colorspace;

  /// The image's marked content ID. Useful for pairing with associated alt-text.
  /// A value of -1 indicates no ID.
  @ffi.Int()
  external int marked_content_id;
}

typedef FPDF_PAGEOBJECTMARK = ffi.Pointer<fpdf_pageobjectmark_t__>;
typedef FPDF_FONT = ffi.Pointer<fpdf_font_t__>;
typedef FPDF_GLYPHPATH = ffi.Pointer<fpdf_glyphpath_t__>;
typedef FPDF_JAVASCRIPT_ACTION = ffi.Pointer<fpdf_javascript_action_t>;

/// Interface: FPDF_SYSFONTINFO
/// Interface for getting system font information and font mapping
final class _FPDF_SYSFONTINFO extends ffi.Struct {
  /// Version number of the interface. Currently must be 1.
  @ffi.Int()
  external int version;

  /// Method: Release
  /// Give implementation a chance to release any data after the
  /// interface is no longer used.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// No
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself
  /// Return Value:
  /// None
  /// Comments:
  /// Called by PDFium during the final cleanup process.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<_FPDF_SYSFONTINFO> pThis)>> Release;

  /// Method: EnumFonts
  /// Enumerate all fonts installed on the system
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// No
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself
  /// pMapper     -   An opaque pointer to internal font mapper, used
  /// when calling FPDF_AddInstalledFont().
  /// Return Value:
  /// None
  /// Comments:
  /// Implementations should call FPDF_AddInstalledFont() function for
  /// each font found. Only TrueType/OpenType and Type1 fonts are
  /// accepted by PDFium.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<_FPDF_SYSFONTINFO> pThis,
              ffi.Pointer<ffi.Void> pMapper)>> EnumFonts;

  /// Method: MapFont
  /// Use the system font mapper to get a font handle from requested
  /// parameters.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// Required if GetFont method is not implemented.
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself
  /// weight      -   Weight of the requested font. 400 is normal and
  /// 700 is bold.
  /// bItalic     -   Italic option of the requested font, TRUE or
  /// FALSE.
  /// charset     -   Character set identifier for the requested font.
  /// See above defined constants.
  /// pitch_family -  A combination of flags. See above defined
  /// constants.
  /// face        -   Typeface name. Currently use system local encoding
  /// only.
  /// bExact      -   Obsolete: this parameter is now ignored.
  /// Return Value:
  /// An opaque pointer for font handle, or NULL if system mapping is
  /// not supported.
  /// Comments:
  /// If the system supports native font mapper (like Windows),
  /// implementation can implement this method to get a font handle.
  /// Otherwise, PDFium will do the mapping and then call GetFont
  /// method. Only TrueType/OpenType and Type1 fonts are accepted
  /// by PDFium.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<_FPDF_SYSFONTINFO> pThis,
              ffi.Int weight,
              FPDF_BOOL bItalic,
              ffi.Int charset,
              ffi.Int pitch_family,
              ffi.Pointer<ffi.Char> face,
              ffi.Pointer<FPDF_BOOL> bExact)>> MapFont;

  /// Method: GetFont
  /// Get a handle to a particular font by its internal ID
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// Required if MapFont method is not implemented.
  /// Return Value:
  /// An opaque pointer for font handle.
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself
  /// face        -   Typeface name in system local encoding.
  /// Comments:
  /// If the system mapping not supported, PDFium will do the font
  /// mapping and use this method to get a font handle.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<_FPDF_SYSFONTINFO> pThis,
              ffi.Pointer<ffi.Char> face)>> GetFont;

  /// Method: GetFontData
  /// Get font data from a font
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// Yes
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself
  /// hFont       -   Font handle returned by MapFont or GetFont method
  /// table       -   TrueType/OpenType table identifier (refer to
  /// TrueType specification), or 0 for the whole file.
  /// buffer      -   The buffer receiving the font data. Can be NULL if
  /// not provided.
  /// buf_size    -   Buffer size, can be zero if not provided.
  /// Return Value:
  /// Number of bytes needed, if buffer not provided or not large
  /// enough, or number of bytes written into buffer otherwise.
  /// Comments:
  /// Can read either the full font file, or a particular
  /// TrueType/OpenType table.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<_FPDF_SYSFONTINFO> pThis,
              ffi.Pointer<ffi.Void> hFont,
              ffi.UnsignedInt table,
              ffi.Pointer<ffi.UnsignedChar> buffer,
              ffi.UnsignedLong buf_size)>> GetFontData;

  /// Method: GetFaceName
  /// Get face name from a font handle
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// No
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself
  /// hFont       -   Font handle returned by MapFont or GetFont method
  /// buffer      -   The buffer receiving the face name. Can be NULL if
  /// not provided
  /// buf_size    -   Buffer size, can be zero if not provided
  /// Return Value:
  /// Number of bytes needed, if buffer not provided or not large
  /// enough, or number of bytes written into buffer otherwise.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<_FPDF_SYSFONTINFO> pThis,
              ffi.Pointer<ffi.Void> hFont,
              ffi.Pointer<ffi.Char> buffer,
              ffi.UnsignedLong buf_size)>> GetFaceName;

  /// Method: GetFontCharset
  /// Get character set information for a font handle
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// No
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself
  /// hFont       -   Font handle returned by MapFont or GetFont method
  /// Return Value:
  /// Character set identifier. See defined constants above.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<_FPDF_SYSFONTINFO> pThis,
              ffi.Pointer<ffi.Void> hFont)>> GetFontCharset;

  /// Method: DeleteFont
  /// Delete a font handle
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// Yes
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself
  /// hFont       -   Font handle returned by MapFont or GetFont method
  /// Return Value:
  /// None
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<_FPDF_SYSFONTINFO> pThis,
              ffi.Pointer<ffi.Void> hFont)>> DeleteFont;
}

/// Struct: FPDF_CharsetFontMap
/// Provides the name of a font to use for a given charset value.
final class FPDF_CharsetFontMap_ extends ffi.Struct {
  /// Character Set Enum value, see FXFONT_*_CHARSET above.
  @ffi.Int()
  external int charset;

  /// Name of default font to use with that charset.
  external ffi.Pointer<ffi.Char> fontname;
}

/// Struct: FPDF_CharsetFontMap
/// Provides the name of a font to use for a given charset value.
typedef FPDF_CharsetFontMap = FPDF_CharsetFontMap_;

/// Interface: FPDF_SYSFONTINFO
/// Interface for getting system font information and font mapping
typedef FPDF_SYSFONTINFO = _FPDF_SYSFONTINFO;

/// Interface for checking whether sections of the file are available.
final class _FX_FILEAVAIL extends ffi.Struct {
  /// Version number of the interface. Must be 1.
  @ffi.Int()
  external int version;

  /// Reports if the specified data section is currently available. A section is
  /// available if all bytes in the section are available.
  ///
  /// Interface Version: 1
  /// Implementation Required: Yes
  ///
  /// pThis  - pointer to the interface structure.
  /// offset - the offset of the data section in the file.
  /// size   - the size of the data section.
  ///
  /// Returns true if the specified data section at |offset| of |size|
  /// is available.
  external ffi.Pointer<
      ffi.NativeFunction<
          FPDF_BOOL Function(ffi.Pointer<_FX_FILEAVAIL> pThis, ffi.Size offset,
              ffi.Size size)>> IsDataAvail;
}

/// Download hints interface. Used to receive hints for further downloading.
final class _FX_DOWNLOADHINTS extends ffi.Struct {
  /// Version number of the interface. Must be 1.
  @ffi.Int()
  external int version;

  /// Add a section to be downloaded.
  ///
  /// Interface Version: 1
  /// Implementation Required: Yes
  ///
  /// pThis  - pointer to the interface structure.
  /// offset - the offset of the hint reported to be downloaded.
  /// size   - the size of the hint reported to be downloaded.
  ///
  /// The |offset| and |size| of the section may not be unique. Part of the
  /// section might be already available. The download manager must deal with
  /// overlapping sections.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<_FX_DOWNLOADHINTS> pThis,
              ffi.Size offset, ffi.Size size)>> AddSegment;
}

typedef FPDF_AVAIL = ffi.Pointer<fpdf_avail_t__>;

/// Interface for checking whether sections of the file are available.
typedef FX_FILEAVAIL = _FX_FILEAVAIL;

/// Download hints interface. Used to receive hints for further downloading.
typedef FX_DOWNLOADHINTS = _FX_DOWNLOADHINTS;

/// IFPDF_RENDERINFO interface.
final class _IFSDK_PAUSE extends ffi.Struct {
  /// Version number of the interface. Currently must be 1.
  @ffi.Int()
  external int version;

  /// Method: NeedToPauseNow
  /// Check if we need to pause a progressive process now.
  /// Interface Version:
  /// 1
  /// Implementation Required:
  /// yes
  /// Parameters:
  /// pThis       -   Pointer to the interface structure itself
  /// Return Value:
  /// Non-zero for pause now, 0 for continue.
  external ffi.Pointer<
          ffi
          .NativeFunction<FPDF_BOOL Function(ffi.Pointer<_IFSDK_PAUSE> pThis)>>
      NeedToPauseNow;

  /// A user defined data pointer, used by user's application. Can be NULL.
  external ffi.Pointer<ffi.Void> user;
}

/// Struct for color scheme.
/// Each should be a 32-bit value specifying the color, in 8888 ARGB format.
typedef FPDF_COLORSCHEME = FPDF_COLORSCHEME_;

/// IFPDF_RENDERINFO interface.
typedef IFSDK_PAUSE = _IFSDK_PAUSE;
typedef FPDF_SCHHANDLE = ffi.Pointer<fpdf_schhandle_t__>;
typedef FPDF_PAGELINK = ffi.Pointer<fpdf_pagelink_t__>;

/// Interface for unsupported feature notifications.
final class _UNSUPPORT_INFO extends ffi.Struct {
  /// Version number of the interface. Must be 1.
  @ffi.Int()
  external int version;

  /// Unsupported object notification function.
  /// Interface Version: 1
  /// Implementation Required: Yes
  ///
  /// pThis - pointer to the interface structure.
  /// nType - the type of unsupported object. One of the |FPDF_UNSP_*| entries.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<_UNSUPPORT_INFO> pThis, ffi.Int nType)>>
      FSDK_UnSupport_Handler;
}

const int QOS_CLASS_USER_INTERACTIVE = 33;

const int QOS_CLASS_USER_INITIATED = 25;

const int QOS_CLASS_DEFAULT = 21;

const int QOS_CLASS_UTILITY = 17;

const int QOS_CLASS_BACKGROUND = 9;

const int QOS_CLASS_UNSPECIFIED = 0;

const int __WORDSIZE = 64;

const int __has_safe_buffers = 1;

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __has_bounds_safety_attributes = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int __API_TO_BE_DEPRECATED = 100000;

const int __API_TO_BE_DEPRECATED_MACOS = 100000;

const int __API_TO_BE_DEPRECATED_MACOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_IOS = 100000;

const int __API_TO_BE_DEPRECATED_IOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_MACCATALYST = 100000;

const int __API_TO_BE_DEPRECATED_MACCATALYSTAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_WATCHOS = 100000;

const int __API_TO_BE_DEPRECATED_WATCHOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_TVOS = 100000;

const int __API_TO_BE_DEPRECATED_TVOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_DRIVERKIT = 100000;

const int __API_TO_BE_DEPRECATED_VISIONOS = 100000;

const int __API_TO_BE_DEPRECATED_VISIONOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_KERNELKIT = 100000;

const int __MAC_10_0 = 1000;

const int __MAC_10_1 = 1010;

const int __MAC_10_2 = 1020;

const int __MAC_10_3 = 1030;

const int __MAC_10_4 = 1040;

const int __MAC_10_5 = 1050;

const int __MAC_10_6 = 1060;

const int __MAC_10_7 = 1070;

const int __MAC_10_8 = 1080;

const int __MAC_10_9 = 1090;

const int __MAC_10_10 = 101000;

const int __MAC_10_10_2 = 101002;

const int __MAC_10_10_3 = 101003;

const int __MAC_10_11 = 101100;

const int __MAC_10_11_2 = 101102;

const int __MAC_10_11_3 = 101103;

const int __MAC_10_11_4 = 101104;

const int __MAC_10_12 = 101200;

const int __MAC_10_12_1 = 101201;

const int __MAC_10_12_2 = 101202;

const int __MAC_10_12_4 = 101204;

const int __MAC_10_13 = 101300;

const int __MAC_10_13_1 = 101301;

const int __MAC_10_13_2 = 101302;

const int __MAC_10_13_4 = 101304;

const int __MAC_10_14 = 101400;

const int __MAC_10_14_1 = 101401;

const int __MAC_10_14_4 = 101404;

const int __MAC_10_14_5 = 101405;

const int __MAC_10_14_6 = 101406;

const int __MAC_10_15 = 101500;

const int __MAC_10_15_1 = 101501;

const int __MAC_10_15_4 = 101504;

const int __MAC_10_16 = 101600;

const int __MAC_11_0 = 110000;

const int __MAC_11_1 = 110100;

const int __MAC_11_3 = 110300;

const int __MAC_11_4 = 110400;

const int __MAC_11_5 = 110500;

const int __MAC_11_6 = 110600;

const int __MAC_12_0 = 120000;

const int __MAC_12_1 = 120100;

const int __MAC_12_2 = 120200;

const int __MAC_12_3 = 120300;

const int __MAC_12_4 = 120400;

const int __MAC_12_5 = 120500;

const int __MAC_12_6 = 120600;

const int __MAC_12_7 = 120700;

const int __MAC_13_0 = 130000;

const int __MAC_13_1 = 130100;

const int __MAC_13_2 = 130200;

const int __MAC_13_3 = 130300;

const int __MAC_13_4 = 130400;

const int __MAC_13_5 = 130500;

const int __MAC_13_6 = 130600;

const int __MAC_13_7 = 130700;

const int __MAC_14_0 = 140000;

const int __MAC_14_1 = 140100;

const int __MAC_14_2 = 140200;

const int __MAC_14_3 = 140300;

const int __MAC_14_4 = 140400;

const int __MAC_14_5 = 140500;

const int __MAC_14_6 = 140600;

const int __MAC_14_7 = 140700;

const int __MAC_15_0 = 150000;

const int __MAC_15_1 = 150100;

const int __MAC_15_2 = 150200;

const int __MAC_15_3 = 150300;

const int __MAC_15_4 = 150400;

const int __MAC_15_5 = 150500;

const int __MAC_15_6 = 150600;

const int __MAC_16_0 = 160000;

const int __MAC_26_0 = 260000;

const int __MAC_26_1 = 260100;

const int __MAC_26_2 = 260200;

const int __IPHONE_2_0 = 20000;

const int __IPHONE_2_1 = 20100;

const int __IPHONE_2_2 = 20200;

const int __IPHONE_3_0 = 30000;

const int __IPHONE_3_1 = 30100;

const int __IPHONE_3_2 = 30200;

const int __IPHONE_4_0 = 40000;

const int __IPHONE_4_1 = 40100;

const int __IPHONE_4_2 = 40200;

const int __IPHONE_4_3 = 40300;

const int __IPHONE_5_0 = 50000;

const int __IPHONE_5_1 = 50100;

const int __IPHONE_6_0 = 60000;

const int __IPHONE_6_1 = 60100;

const int __IPHONE_7_0 = 70000;

const int __IPHONE_7_1 = 70100;

const int __IPHONE_8_0 = 80000;

const int __IPHONE_8_1 = 80100;

const int __IPHONE_8_2 = 80200;

const int __IPHONE_8_3 = 80300;

const int __IPHONE_8_4 = 80400;

const int __IPHONE_9_0 = 90000;

const int __IPHONE_9_1 = 90100;

const int __IPHONE_9_2 = 90200;

const int __IPHONE_9_3 = 90300;

const int __IPHONE_10_0 = 100000;

const int __IPHONE_10_1 = 100100;

const int __IPHONE_10_2 = 100200;

const int __IPHONE_10_3 = 100300;

const int __IPHONE_11_0 = 110000;

const int __IPHONE_11_1 = 110100;

const int __IPHONE_11_2 = 110200;

const int __IPHONE_11_3 = 110300;

const int __IPHONE_11_4 = 110400;

const int __IPHONE_12_0 = 120000;

const int __IPHONE_12_1 = 120100;

const int __IPHONE_12_2 = 120200;

const int __IPHONE_12_3 = 120300;

const int __IPHONE_12_4 = 120400;

const int __IPHONE_13_0 = 130000;

const int __IPHONE_13_1 = 130100;

const int __IPHONE_13_2 = 130200;

const int __IPHONE_13_3 = 130300;

const int __IPHONE_13_4 = 130400;

const int __IPHONE_13_5 = 130500;

const int __IPHONE_13_6 = 130600;

const int __IPHONE_13_7 = 130700;

const int __IPHONE_14_0 = 140000;

const int __IPHONE_14_1 = 140100;

const int __IPHONE_14_2 = 140200;

const int __IPHONE_14_3 = 140300;

const int __IPHONE_14_5 = 140500;

const int __IPHONE_14_6 = 140600;

const int __IPHONE_14_7 = 140700;

const int __IPHONE_14_8 = 140800;

const int __IPHONE_15_0 = 150000;

const int __IPHONE_15_1 = 150100;

const int __IPHONE_15_2 = 150200;

const int __IPHONE_15_3 = 150300;

const int __IPHONE_15_4 = 150400;

const int __IPHONE_15_5 = 150500;

const int __IPHONE_15_6 = 150600;

const int __IPHONE_15_7 = 150700;

const int __IPHONE_15_8 = 150800;

const int __IPHONE_16_0 = 160000;

const int __IPHONE_16_1 = 160100;

const int __IPHONE_16_2 = 160200;

const int __IPHONE_16_3 = 160300;

const int __IPHONE_16_4 = 160400;

const int __IPHONE_16_5 = 160500;

const int __IPHONE_16_6 = 160600;

const int __IPHONE_16_7 = 160700;

const int __IPHONE_17_0 = 170000;

const int __IPHONE_17_1 = 170100;

const int __IPHONE_17_2 = 170200;

const int __IPHONE_17_3 = 170300;

const int __IPHONE_17_4 = 170400;

const int __IPHONE_17_5 = 170500;

const int __IPHONE_17_6 = 170600;

const int __IPHONE_17_7 = 170700;

const int __IPHONE_18_0 = 180000;

const int __IPHONE_18_1 = 180100;

const int __IPHONE_18_2 = 180200;

const int __IPHONE_18_3 = 180300;

const int __IPHONE_18_4 = 180400;

const int __IPHONE_18_5 = 180500;

const int __IPHONE_18_6 = 180600;

const int __IPHONE_19_0 = 190000;

const int __IPHONE_26_0 = 260000;

const int __IPHONE_26_1 = 260100;

const int __IPHONE_26_2 = 260200;

const int __WATCHOS_1_0 = 10000;

const int __WATCHOS_2_0 = 20000;

const int __WATCHOS_2_1 = 20100;

const int __WATCHOS_2_2 = 20200;

const int __WATCHOS_3_0 = 30000;

const int __WATCHOS_3_1 = 30100;

const int __WATCHOS_3_1_1 = 30101;

const int __WATCHOS_3_2 = 30200;

const int __WATCHOS_4_0 = 40000;

const int __WATCHOS_4_1 = 40100;

const int __WATCHOS_4_2 = 40200;

const int __WATCHOS_4_3 = 40300;

const int __WATCHOS_5_0 = 50000;

const int __WATCHOS_5_1 = 50100;

const int __WATCHOS_5_2 = 50200;

const int __WATCHOS_5_3 = 50300;

const int __WATCHOS_6_0 = 60000;

const int __WATCHOS_6_1 = 60100;

const int __WATCHOS_6_2 = 60200;

const int __WATCHOS_7_0 = 70000;

const int __WATCHOS_7_1 = 70100;

const int __WATCHOS_7_2 = 70200;

const int __WATCHOS_7_3 = 70300;

const int __WATCHOS_7_4 = 70400;

const int __WATCHOS_7_5 = 70500;

const int __WATCHOS_7_6 = 70600;

const int __WATCHOS_8_0 = 80000;

const int __WATCHOS_8_1 = 80100;

const int __WATCHOS_8_3 = 80300;

const int __WATCHOS_8_4 = 80400;

const int __WATCHOS_8_5 = 80500;

const int __WATCHOS_8_6 = 80600;

const int __WATCHOS_8_7 = 80700;

const int __WATCHOS_8_8 = 80800;

const int __WATCHOS_9_0 = 90000;

const int __WATCHOS_9_1 = 90100;

const int __WATCHOS_9_2 = 90200;

const int __WATCHOS_9_3 = 90300;

const int __WATCHOS_9_4 = 90400;

const int __WATCHOS_9_5 = 90500;

const int __WATCHOS_9_6 = 90600;

const int __WATCHOS_10_0 = 100000;

const int __WATCHOS_10_1 = 100100;

const int __WATCHOS_10_2 = 100200;

const int __WATCHOS_10_3 = 100300;

const int __WATCHOS_10_4 = 100400;

const int __WATCHOS_10_5 = 100500;

const int __WATCHOS_10_6 = 100600;

const int __WATCHOS_10_7 = 100700;

const int __WATCHOS_11_0 = 110000;

const int __WATCHOS_11_1 = 110100;

const int __WATCHOS_11_2 = 110200;

const int __WATCHOS_11_3 = 110300;

const int __WATCHOS_11_4 = 110400;

const int __WATCHOS_11_5 = 110500;

const int __WATCHOS_11_6 = 110600;

const int __WATCHOS_12_0 = 120000;

const int __WATCHOS_26_0 = 260000;

const int __WATCHOS_26_1 = 260100;

const int __WATCHOS_26_2 = 260200;

const int __TVOS_9_0 = 90000;

const int __TVOS_9_1 = 90100;

const int __TVOS_9_2 = 90200;

const int __TVOS_10_0 = 100000;

const int __TVOS_10_0_1 = 100001;

const int __TVOS_10_1 = 100100;

const int __TVOS_10_2 = 100200;

const int __TVOS_11_0 = 110000;

const int __TVOS_11_1 = 110100;

const int __TVOS_11_2 = 110200;

const int __TVOS_11_3 = 110300;

const int __TVOS_11_4 = 110400;

const int __TVOS_12_0 = 120000;

const int __TVOS_12_1 = 120100;

const int __TVOS_12_2 = 120200;

const int __TVOS_12_3 = 120300;

const int __TVOS_12_4 = 120400;

const int __TVOS_13_0 = 130000;

const int __TVOS_13_2 = 130200;

const int __TVOS_13_3 = 130300;

const int __TVOS_13_4 = 130400;

const int __TVOS_14_0 = 140000;

const int __TVOS_14_1 = 140100;

const int __TVOS_14_2 = 140200;

const int __TVOS_14_3 = 140300;

const int __TVOS_14_5 = 140500;

const int __TVOS_14_6 = 140600;

const int __TVOS_14_7 = 140700;

const int __TVOS_15_0 = 150000;

const int __TVOS_15_1 = 150100;

const int __TVOS_15_2 = 150200;

const int __TVOS_15_3 = 150300;

const int __TVOS_15_4 = 150400;

const int __TVOS_15_5 = 150500;

const int __TVOS_15_6 = 150600;

const int __TVOS_16_0 = 160000;

const int __TVOS_16_1 = 160100;

const int __TVOS_16_2 = 160200;

const int __TVOS_16_3 = 160300;

const int __TVOS_16_4 = 160400;

const int __TVOS_16_5 = 160500;

const int __TVOS_16_6 = 160600;

const int __TVOS_17_0 = 170000;

const int __TVOS_17_1 = 170100;

const int __TVOS_17_2 = 170200;

const int __TVOS_17_3 = 170300;

const int __TVOS_17_4 = 170400;

const int __TVOS_17_5 = 170500;

const int __TVOS_17_6 = 170600;

const int __TVOS_18_0 = 180000;

const int __TVOS_18_1 = 180100;

const int __TVOS_18_2 = 180200;

const int __TVOS_18_3 = 180300;

const int __TVOS_18_4 = 180400;

const int __TVOS_18_5 = 180500;

const int __TVOS_18_6 = 180600;

const int __TVOS_19_0 = 190000;

const int __TVOS_26_0 = 260000;

const int __TVOS_26_1 = 260100;

const int __TVOS_26_2 = 260200;

const int __BRIDGEOS_2_0 = 20000;

const int __BRIDGEOS_3_0 = 30000;

const int __BRIDGEOS_3_1 = 30100;

const int __BRIDGEOS_3_4 = 30400;

const int __BRIDGEOS_4_0 = 40000;

const int __BRIDGEOS_4_1 = 40100;

const int __BRIDGEOS_5_0 = 50000;

const int __BRIDGEOS_5_1 = 50100;

const int __BRIDGEOS_5_3 = 50300;

const int __BRIDGEOS_6_0 = 60000;

const int __BRIDGEOS_6_2 = 60200;

const int __BRIDGEOS_6_4 = 60400;

const int __BRIDGEOS_6_5 = 60500;

const int __BRIDGEOS_6_6 = 60600;

const int __BRIDGEOS_7_0 = 70000;

const int __BRIDGEOS_7_1 = 70100;

const int __BRIDGEOS_7_2 = 70200;

const int __BRIDGEOS_7_3 = 70300;

const int __BRIDGEOS_7_4 = 70400;

const int __BRIDGEOS_7_6 = 70600;

const int __BRIDGEOS_8_0 = 80000;

const int __BRIDGEOS_8_1 = 80100;

const int __BRIDGEOS_8_2 = 80200;

const int __BRIDGEOS_8_3 = 80300;

const int __BRIDGEOS_8_4 = 80400;

const int __BRIDGEOS_8_5 = 80500;

const int __BRIDGEOS_8_6 = 80600;

const int __BRIDGEOS_9_0 = 90000;

const int __BRIDGEOS_9_1 = 90100;

const int __BRIDGEOS_9_2 = 90200;

const int __BRIDGEOS_9_3 = 90300;

const int __BRIDGEOS_9_4 = 90400;

const int __BRIDGEOS_9_5 = 90500;

const int __BRIDGEOS_9_6 = 90600;

const int __BRIDGEOS_10_0 = 100000;

const int __BRIDGEOS_10_1 = 100100;

const int __BRIDGEOS_10_2 = 100200;

const int __DRIVERKIT_19_0 = 190000;

const int __DRIVERKIT_20_0 = 200000;

const int __DRIVERKIT_21_0 = 210000;

const int __DRIVERKIT_22_0 = 220000;

const int __DRIVERKIT_22_4 = 220400;

const int __DRIVERKIT_22_5 = 220500;

const int __DRIVERKIT_22_6 = 220600;

const int __DRIVERKIT_23_0 = 230000;

const int __DRIVERKIT_23_1 = 230100;

const int __DRIVERKIT_23_2 = 230200;

const int __DRIVERKIT_23_3 = 230300;

const int __DRIVERKIT_23_4 = 230400;

const int __DRIVERKIT_23_5 = 230500;

const int __DRIVERKIT_23_6 = 230600;

const int __DRIVERKIT_24_0 = 240000;

const int __DRIVERKIT_24_1 = 240100;

const int __DRIVERKIT_24_2 = 240200;

const int __DRIVERKIT_24_3 = 240300;

const int __DRIVERKIT_24_4 = 240400;

const int __DRIVERKIT_24_5 = 240500;

const int __DRIVERKIT_24_6 = 240600;

const int __DRIVERKIT_25_0 = 250000;

const int __DRIVERKIT_25_1 = 250100;

const int __DRIVERKIT_25_2 = 250200;

const int __VISIONOS_1_0 = 10000;

const int __VISIONOS_1_1 = 10100;

const int __VISIONOS_1_2 = 10200;

const int __VISIONOS_1_3 = 10300;

const int __VISIONOS_2_0 = 20000;

const int __VISIONOS_2_1 = 20100;

const int __VISIONOS_2_2 = 20200;

const int __VISIONOS_2_3 = 20300;

const int __VISIONOS_2_4 = 20400;

const int __VISIONOS_2_5 = 20500;

const int __VISIONOS_2_6 = 20600;

const int __VISIONOS_3_0 = 30000;

const int __VISIONOS_26_0 = 260000;

const int __VISIONOS_26_1 = 260100;

const int __VISIONOS_26_2 = 260200;

const int MAC_OS_X_VERSION_10_0 = 1000;

const int MAC_OS_X_VERSION_10_1 = 1010;

const int MAC_OS_X_VERSION_10_2 = 1020;

const int MAC_OS_X_VERSION_10_3 = 1030;

const int MAC_OS_X_VERSION_10_4 = 1040;

const int MAC_OS_X_VERSION_10_5 = 1050;

const int MAC_OS_X_VERSION_10_6 = 1060;

const int MAC_OS_X_VERSION_10_7 = 1070;

const int MAC_OS_X_VERSION_10_8 = 1080;

const int MAC_OS_X_VERSION_10_9 = 1090;

const int MAC_OS_X_VERSION_10_10 = 101000;

const int MAC_OS_X_VERSION_10_10_2 = 101002;

const int MAC_OS_X_VERSION_10_10_3 = 101003;

const int MAC_OS_X_VERSION_10_11 = 101100;

const int MAC_OS_X_VERSION_10_11_2 = 101102;

const int MAC_OS_X_VERSION_10_11_3 = 101103;

const int MAC_OS_X_VERSION_10_11_4 = 101104;

const int MAC_OS_X_VERSION_10_12 = 101200;

const int MAC_OS_X_VERSION_10_12_1 = 101201;

const int MAC_OS_X_VERSION_10_12_2 = 101202;

const int MAC_OS_X_VERSION_10_12_4 = 101204;

const int MAC_OS_X_VERSION_10_13 = 101300;

const int MAC_OS_X_VERSION_10_13_1 = 101301;

const int MAC_OS_X_VERSION_10_13_2 = 101302;

const int MAC_OS_X_VERSION_10_13_4 = 101304;

const int MAC_OS_X_VERSION_10_14 = 101400;

const int MAC_OS_X_VERSION_10_14_1 = 101401;

const int MAC_OS_X_VERSION_10_14_4 = 101404;

const int MAC_OS_X_VERSION_10_14_5 = 101405;

const int MAC_OS_X_VERSION_10_14_6 = 101406;

const int MAC_OS_X_VERSION_10_15 = 101500;

const int MAC_OS_X_VERSION_10_15_1 = 101501;

const int MAC_OS_X_VERSION_10_15_4 = 101504;

const int MAC_OS_X_VERSION_10_16 = 101600;

const int MAC_OS_VERSION_11_0 = 110000;

const int MAC_OS_VERSION_11_1 = 110100;

const int MAC_OS_VERSION_11_3 = 110300;

const int MAC_OS_VERSION_11_4 = 110400;

const int MAC_OS_VERSION_11_5 = 110500;

const int MAC_OS_VERSION_11_6 = 110600;

const int MAC_OS_VERSION_12_0 = 120000;

const int MAC_OS_VERSION_12_1 = 120100;

const int MAC_OS_VERSION_12_2 = 120200;

const int MAC_OS_VERSION_12_3 = 120300;

const int MAC_OS_VERSION_12_4 = 120400;

const int MAC_OS_VERSION_12_5 = 120500;

const int MAC_OS_VERSION_12_6 = 120600;

const int MAC_OS_VERSION_12_7 = 120700;

const int MAC_OS_VERSION_13_0 = 130000;

const int MAC_OS_VERSION_13_1 = 130100;

const int MAC_OS_VERSION_13_2 = 130200;

const int MAC_OS_VERSION_13_3 = 130300;

const int MAC_OS_VERSION_13_4 = 130400;

const int MAC_OS_VERSION_13_5 = 130500;

const int MAC_OS_VERSION_13_6 = 130600;

const int MAC_OS_VERSION_13_7 = 130700;

const int MAC_OS_VERSION_14_0 = 140000;

const int MAC_OS_VERSION_14_1 = 140100;

const int MAC_OS_VERSION_14_2 = 140200;

const int MAC_OS_VERSION_14_3 = 140300;

const int MAC_OS_VERSION_14_4 = 140400;

const int MAC_OS_VERSION_14_5 = 140500;

const int MAC_OS_VERSION_14_6 = 140600;

const int MAC_OS_VERSION_14_7 = 140700;

const int MAC_OS_VERSION_15_0 = 150000;

const int MAC_OS_VERSION_15_1 = 150100;

const int MAC_OS_VERSION_15_2 = 150200;

const int MAC_OS_VERSION_15_3 = 150300;

const int MAC_OS_VERSION_15_4 = 150400;

const int MAC_OS_VERSION_15_5 = 150500;

const int MAC_OS_VERSION_15_6 = 150600;

const int MAC_OS_VERSION_16_0 = 160000;

const int MAC_OS_VERSION_26_0 = 260000;

const int MAC_OS_VERSION_26_1 = 260100;

const int MAC_OS_VERSION_26_2 = 260200;

const int __AVAILABILITY_VERSIONS_VERSION_HASH = 93585900;

const String __AVAILABILITY_VERSIONS_VERSION_STRING = 'Local';

const String __AVAILABILITY_FILE = 'AvailabilityVersions.h';

const int __MAC_OS_X_VERSION_MIN_REQUIRED = 150000;

const int __MAC_OS_X_VERSION_MAX_ALLOWED = 260200;

const int __ENABLE_LEGACY_MAC_AVAILABILITY = 1;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int USER_ADDR_NULL = 0;

const int NULL = 0;

const int RENAME_SECLUDE = 1;

const int RENAME_SWAP = 2;

const int RENAME_EXCL = 4;

const int RENAME_RESERVED1 = 8;

const int RENAME_NOFOLLOW_ANY = 16;

const int RENAME_RESOLVE_BENEATH = 32;

const int SEEK_SET = 0;

const int SEEK_CUR = 1;

const int SEEK_END = 2;

const int SEEK_HOLE = 3;

const int SEEK_DATA = 4;

const int __SLBF = 1;

const int __SNBF = 2;

const int __SRD = 4;

const int __SWR = 8;

const int __SRW = 16;

const int __SEOF = 32;

const int __SERR = 64;

const int __SMBF = 128;

const int __SAPP = 256;

const int __SSTR = 512;

const int __SOPT = 1024;

const int __SNPT = 2048;

const int __SOFF = 4096;

const int __SMOD = 8192;

const int __SALC = 16384;

const int __SIGN = 32768;

const int _IOFBF = 0;

const int _IOLBF = 1;

const int _IONBF = 2;

const int BUFSIZ = 1024;

const int EOF = -1;

const int FOPEN_MAX = 20;

const int FILENAME_MAX = 1024;

const String P_tmpdir = '/var/tmp/';

const int L_tmpnam = 1024;

const int TMP_MAX = 308915776;

const int L_ctermid = 1024;

const int __DARWIN_NSIG = 32;

const int NSIG = 32;

const int _ARM_SIGNAL_ = 1;

const int SIGHUP = 1;

const int SIGINT = 2;

const int SIGQUIT = 3;

const int SIGILL = 4;

const int SIGTRAP = 5;

const int SIGABRT = 6;

const int SIGIOT = 6;

const int SIGEMT = 7;

const int SIGFPE = 8;

const int SIGKILL = 9;

const int SIGBUS = 10;

const int SIGSEGV = 11;

const int SIGSYS = 12;

const int SIGPIPE = 13;

const int SIGALRM = 14;

const int SIGTERM = 15;

const int SIGURG = 16;

const int SIGSTOP = 17;

const int SIGTSTP = 18;

const int SIGCONT = 19;

const int SIGCHLD = 20;

const int SIGTTIN = 21;

const int SIGTTOU = 22;

const int SIGIO = 23;

const int SIGXCPU = 24;

const int SIGXFSZ = 25;

const int SIGVTALRM = 26;

const int SIGPROF = 27;

const int SIGWINCH = 28;

const int SIGINFO = 29;

const int SIGUSR1 = 30;

const int SIGUSR2 = 31;

const int __DARWIN_OPAQUE_ARM_THREAD_STATE64 = 0;

const int SIGEV_NONE = 0;

const int SIGEV_SIGNAL = 1;

const int SIGEV_THREAD = 3;

const int SIGEV_KEVENT = 4;

const int ILL_NOOP = 0;

const int ILL_ILLOPC = 1;

const int ILL_ILLTRP = 2;

const int ILL_PRVOPC = 3;

const int ILL_ILLOPN = 4;

const int ILL_ILLADR = 5;

const int ILL_PRVREG = 6;

const int ILL_COPROC = 7;

const int ILL_BADSTK = 8;

const int FPE_NOOP = 0;

const int FPE_FLTDIV = 1;

const int FPE_FLTOVF = 2;

const int FPE_FLTUND = 3;

const int FPE_FLTRES = 4;

const int FPE_FLTINV = 5;

const int FPE_FLTSUB = 6;

const int FPE_INTDIV = 7;

const int FPE_INTOVF = 8;

const int SEGV_NOOP = 0;

const int SEGV_MAPERR = 1;

const int SEGV_ACCERR = 2;

const int BUS_NOOP = 0;

const int BUS_ADRALN = 1;

const int BUS_ADRERR = 2;

const int BUS_OBJERR = 3;

const int TRAP_BRKPT = 1;

const int TRAP_TRACE = 2;

const int CLD_NOOP = 0;

const int CLD_EXITED = 1;

const int CLD_KILLED = 2;

const int CLD_DUMPED = 3;

const int CLD_TRAPPED = 4;

const int CLD_STOPPED = 5;

const int CLD_CONTINUED = 6;

const int POLL_IN = 1;

const int POLL_OUT = 2;

const int POLL_MSG = 3;

const int POLL_ERR = 4;

const int POLL_PRI = 5;

const int POLL_HUP = 6;

const int SA_ONSTACK = 1;

const int SA_RESTART = 2;

const int SA_RESETHAND = 4;

const int SA_NOCLDSTOP = 8;

const int SA_NODEFER = 16;

const int SA_NOCLDWAIT = 32;

const int SA_SIGINFO = 64;

const int SA_USERTRAMP = 256;

const int SA_64REGSET = 512;

const int SA_USERSPACE_MASK = 127;

const int SIG_BLOCK = 1;

const int SIG_UNBLOCK = 2;

const int SIG_SETMASK = 3;

const int SI_USER = 65537;

const int SI_QUEUE = 65538;

const int SI_TIMER = 65539;

const int SI_ASYNCIO = 65540;

const int SI_MESGQ = 65541;

const int SS_ONSTACK = 1;

const int SS_DISABLE = 4;

const int MINSIGSTKSZ = 32768;

const int SIGSTKSZ = 131072;

const int SV_ONSTACK = 1;

const int SV_INTERRUPT = 2;

const int SV_RESETHAND = 4;

const int SV_NODEFER = 16;

const int SV_NOCLDSTOP = 8;

const int SV_SIGINFO = 64;

const int PRIO_PROCESS = 0;

const int PRIO_PGRP = 1;

const int PRIO_USER = 2;

const int PRIO_DARWIN_THREAD = 3;

const int PRIO_DARWIN_PROCESS = 4;

const int PRIO_MIN = -20;

const int PRIO_MAX = 20;

const int PRIO_DARWIN_BG = 4096;

const int PRIO_DARWIN_NONUI = 4097;

const int RUSAGE_SELF = 0;

const int RUSAGE_CHILDREN = -1;

const int RUSAGE_INFO_V0 = 0;

const int RUSAGE_INFO_V1 = 1;

const int RUSAGE_INFO_V2 = 2;

const int RUSAGE_INFO_V3 = 3;

const int RUSAGE_INFO_V4 = 4;

const int RUSAGE_INFO_V5 = 5;

const int RUSAGE_INFO_V6 = 6;

const int RUSAGE_INFO_CURRENT = 6;

const int RU_PROC_RUNS_RESLIDE = 1;

const int RLIM_INFINITY = 9223372036854775807;

const int RLIM_SAVED_MAX = 9223372036854775807;

const int RLIM_SAVED_CUR = 9223372036854775807;

const int RLIMIT_CPU = 0;

const int RLIMIT_FSIZE = 1;

const int RLIMIT_DATA = 2;

const int RLIMIT_STACK = 3;

const int RLIMIT_CORE = 4;

const int RLIMIT_AS = 5;

const int RLIMIT_RSS = 5;

const int RLIMIT_MEMLOCK = 6;

const int RLIMIT_NPROC = 7;

const int RLIMIT_NOFILE = 8;

const int RLIM_NLIMITS = 9;

const int _RLIMIT_POSIX_FLAG = 4096;

const int RLIMIT_WAKEUPS_MONITOR = 1;

const int RLIMIT_CPU_USAGE_MONITOR = 2;

const int RLIMIT_THREAD_CPULIMITS = 3;

const int RLIMIT_FOOTPRINT_INTERVAL = 4;

const int WAKEMON_ENABLE = 1;

const int WAKEMON_DISABLE = 2;

const int WAKEMON_GET_PARAMS = 4;

const int WAKEMON_SET_DEFAULTS = 8;

const int WAKEMON_MAKE_FATAL = 16;

const int CPUMON_MAKE_FATAL = 4096;

const int FOOTPRINT_INTERVAL_RESET = 1;

const int IOPOL_TYPE_DISK = 0;

const int IOPOL_TYPE_VFS_ATIME_UPDATES = 2;

const int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = 3;

const int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = 4;

const int IOPOL_TYPE_VFS_TRIGGER_RESOLVE = 5;

const int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = 6;

const int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = 7;

const int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = 8;

const int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = 9;

const int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = 10;

const int IOPOL_TYPE_VFS_ENTITLED_RESERVE_ACCESS = 14;

const int IOPOL_SCOPE_PROCESS = 0;

const int IOPOL_SCOPE_THREAD = 1;

const int IOPOL_SCOPE_DARWIN_BG = 2;

const int IOPOL_DEFAULT = 0;

const int IOPOL_IMPORTANT = 1;

const int IOPOL_PASSIVE = 2;

const int IOPOL_THROTTLE = 3;

const int IOPOL_UTILITY = 4;

const int IOPOL_STANDARD = 5;

const int IOPOL_APPLICATION = 5;

const int IOPOL_NORMAL = 1;

const int IOPOL_ATIME_UPDATES_DEFAULT = 0;

const int IOPOL_ATIME_UPDATES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = 0;

const int IOPOL_MATERIALIZE_DATALESS_FILES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_ON = 2;

const int IOPOL_MATERIALIZE_DATALESS_FILES_ORIG = 4;

const int IOPOL_MATERIALIZE_DATALESS_FILES_BASIC_MASK = 3;

const int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = 0;

const int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = 1;

const int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = 0;

const int IOPOL_VFS_TRIGGER_RESOLVE_OFF = 1;

const int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = 0;

const int IOPOL_VFS_CONTENT_PROTECTION_IGNORE = 1;

const int IOPOL_VFS_IGNORE_PERMISSIONS_OFF = 0;

const int IOPOL_VFS_IGNORE_PERMISSIONS_ON = 1;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = 0;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_ON = 1;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_IGNORE = 2;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = 0;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = 1;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = 0;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = 1;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT = 0;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON = 1;

const int IOPOL_VFS_ENTITLED_RESERVE_ACCESS_OFF = 0;

const int IOPOL_VFS_ENTITLED_RESERVE_ACCESS_ON = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WCOREFLAG = 128;

const int _WSTOPPED = 127;

const int WEXITED = 4;

const int WSTOPPED = 8;

const int WCONTINUED = 16;

const int WNOWAIT = 32;

const int WAIT_ANY = -1;

const int WAIT_MYPGRP = 0;

const int _QUAD_HIGHWORD = 1;

const int _QUAD_LOWWORD = 0;

const int __DARWIN_LITTLE_ENDIAN = 1234;

const int __DARWIN_BIG_ENDIAN = 4321;

const int __DARWIN_PDP_ENDIAN = 3412;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int __DARWIN_BYTE_ORDER = 1234;

const int BYTE_ORDER = 1234;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int RAND_MAX = 2147483647;

const int _MALLOC_TYPE_MALLOC_BACKDEPLOY_PUBLIC = 1;

const int _PTHREAD_MUTEX_SIG_init = 850045863;

const int _PTHREAD_ERRORCHECK_MUTEX_SIG_init = 850045857;

const int _PTHREAD_RECURSIVE_MUTEX_SIG_init = 850045858;

const int _PTHREAD_FIRSTFIT_MUTEX_SIG_init = 850045859;

const int _PTHREAD_COND_SIG_init = 1018212795;

const int _PTHREAD_ONCE_SIG_init = 816954554;

const int _PTHREAD_RWLOCK_SIG_init = 766030772;

const int SCHED_OTHER = 1;

const int SCHED_FIFO = 4;

const int SCHED_RR = 2;

const int __SCHED_PARAM_SIZE__ = 4;

const int CLOCKS_PER_SEC = 1000000;

const int CLOCK_REALTIME = 0;

const int CLOCK_MONOTONIC = 6;

const int CLOCK_MONOTONIC_RAW = 4;

const int CLOCK_MONOTONIC_RAW_APPROX = 5;

const int CLOCK_UPTIME_RAW = 8;

const int CLOCK_UPTIME_RAW_APPROX = 9;

const int CLOCK_PROCESS_CPUTIME_ID = 12;

const int CLOCK_THREAD_CPUTIME_ID = 16;

const int TIME_UTC = 1;

const int QOS_MIN_RELATIVE_PRIORITY = -15;

const int PTHREAD_CREATE_JOINABLE = 1;

const int PTHREAD_CREATE_DETACHED = 2;

const int PTHREAD_INHERIT_SCHED = 1;

const int PTHREAD_EXPLICIT_SCHED = 2;

const int PTHREAD_CANCEL_ENABLE = 1;

const int PTHREAD_CANCEL_DISABLE = 0;

const int PTHREAD_CANCEL_DEFERRED = 2;

const int PTHREAD_CANCEL_ASYNCHRONOUS = 0;

const int PTHREAD_SCOPE_SYSTEM = 1;

const int PTHREAD_SCOPE_PROCESS = 2;

const int PTHREAD_PROCESS_SHARED = 1;

const int PTHREAD_PROCESS_PRIVATE = 2;

const int PTHREAD_PRIO_NONE = 0;

const int PTHREAD_PRIO_INHERIT = 1;

const int PTHREAD_PRIO_PROTECT = 2;

const int PTHREAD_MUTEX_NORMAL = 0;

const int PTHREAD_MUTEX_ERRORCHECK = 1;

const int PTHREAD_MUTEX_RECURSIVE = 2;

const int PTHREAD_MUTEX_DEFAULT = 0;

const int PTHREAD_MUTEX_POLICY_FAIRSHARE_NP = 1;

const int PTHREAD_MUTEX_POLICY_FIRSTFIT_NP = 3;

const int _POSIX_VERSION = 200112;

const int _POSIX2_VERSION = 200112;

const int _POSIX_VDISABLE = 255;

const int _POSIX_THREAD_KEYS_MAX = 128;

const int F_OK = 0;

const int X_OK = 1;

const int W_OK = 2;

const int R_OK = 4;

const int _READ_OK = 512;

const int _WRITE_OK = 1024;

const int _EXECUTE_OK = 2048;

const int _DELETE_OK = 4096;

const int _APPEND_OK = 8192;

const int _RMFILE_OK = 16384;

const int _RATTR_OK = 32768;

const int _WATTR_OK = 65536;

const int _REXT_OK = 131072;

const int _WEXT_OK = 262144;

const int _RPERM_OK = 524288;

const int _WPERM_OK = 1048576;

const int _CHOWN_OK = 2097152;

const int _ACCESS_EXTENDED_MASK = 4193792;

const int L_SET = 0;

const int L_INCR = 1;

const int L_XTND = 2;

const int ACCESSX_MAX_DESCRIPTORS = 100;

const int ACCESSX_MAX_TABLESIZE = 16384;

const int _PC_LINK_MAX = 1;

const int _PC_MAX_CANON = 2;

const int _PC_MAX_INPUT = 3;

const int _PC_NAME_MAX = 4;

const int _PC_PATH_MAX = 5;

const int _PC_PIPE_BUF = 6;

const int _PC_CHOWN_RESTRICTED = 7;

const int _PC_NO_TRUNC = 8;

const int _PC_VDISABLE = 9;

const int _PC_NAME_CHARS_MAX = 10;

const int _PC_CASE_SENSITIVE = 11;

const int _PC_CASE_PRESERVING = 12;

const int _PC_EXTENDED_SECURITY_NP = 13;

const int _PC_AUTH_OPAQUE_NP = 14;

const int _PC_2_SYMLINKS = 15;

const int _PC_ALLOC_SIZE_MIN = 16;

const int _PC_ASYNC_IO = 17;

const int _PC_FILESIZEBITS = 18;

const int _PC_PRIO_IO = 19;

const int _PC_REC_INCR_XFER_SIZE = 20;

const int _PC_REC_MAX_XFER_SIZE = 21;

const int _PC_REC_MIN_XFER_SIZE = 22;

const int _PC_REC_XFER_ALIGN = 23;

const int _PC_SYMLINK_MAX = 24;

const int _PC_SYNC_IO = 25;

const int _PC_XATTR_SIZE_BITS = 26;

const int _PC_MIN_HOLE_SIZE = 27;

const int _CS_PATH = 1;

const int STDIN_FILENO = 0;

const int STDOUT_FILENO = 1;

const int STDERR_FILENO = 2;

const int _XOPEN_VERSION = 600;

const int _XOPEN_XCU_VERSION = 4;

const int _POSIX_ADVISORY_INFO = -1;

const int _POSIX_ASYNCHRONOUS_IO = -1;

const int _POSIX_BARRIERS = -1;

const int _POSIX_CHOWN_RESTRICTED = 200112;

const int _POSIX_CLOCK_SELECTION = -1;

const int _POSIX_CPUTIME = -1;

const int _POSIX_FSYNC = 200112;

const int _POSIX_IPV6 = 200112;

const int _POSIX_JOB_CONTROL = 200112;

const int _POSIX_MAPPED_FILES = 200112;

const int _POSIX_MEMLOCK = -1;

const int _POSIX_MEMLOCK_RANGE = -1;

const int _POSIX_MEMORY_PROTECTION = 200112;

const int _POSIX_MESSAGE_PASSING = -1;

const int _POSIX_MONOTONIC_CLOCK = -1;

const int _POSIX_NO_TRUNC = 200112;

const int _POSIX_PRIORITIZED_IO = -1;

const int _POSIX_PRIORITY_SCHEDULING = -1;

const int _POSIX_RAW_SOCKETS = -1;

const int _POSIX_READER_WRITER_LOCKS = 200112;

const int _POSIX_REALTIME_SIGNALS = -1;

const int _POSIX_REGEXP = 200112;

const int _POSIX_SAVED_IDS = 200112;

const int _POSIX_SEMAPHORES = -1;

const int _POSIX_SHARED_MEMORY_OBJECTS = -1;

const int _POSIX_SHELL = 200112;

const int _POSIX_SPAWN = 200112;

const int _POSIX_SPIN_LOCKS = -1;

const int _POSIX_SPORADIC_SERVER = -1;

const int _POSIX_SYNCHRONIZED_IO = -1;

const int _POSIX_THREAD_ATTR_STACKADDR = 200112;

const int _POSIX_THREAD_ATTR_STACKSIZE = 200112;

const int _POSIX_THREAD_CPUTIME = -1;

const int _POSIX_THREAD_PRIO_INHERIT = -1;

const int _POSIX_THREAD_PRIO_PROTECT = -1;

const int _POSIX_THREAD_PRIORITY_SCHEDULING = -1;

const int _POSIX_THREAD_PROCESS_SHARED = 200112;

const int _POSIX_THREAD_SAFE_FUNCTIONS = 200112;

const int _POSIX_THREAD_SPORADIC_SERVER = -1;

const int _POSIX_THREADS = 200112;

const int _POSIX_TIMEOUTS = -1;

const int _POSIX_TIMERS = -1;

const int _POSIX_TRACE = -1;

const int _POSIX_TRACE_EVENT_FILTER = -1;

const int _POSIX_TRACE_INHERIT = -1;

const int _POSIX_TRACE_LOG = -1;

const int _POSIX_TYPED_MEMORY_OBJECTS = -1;

const int _POSIX2_C_BIND = 200112;

const int _POSIX2_C_DEV = 200112;

const int _POSIX2_CHAR_TERM = 200112;

const int _POSIX2_FORT_DEV = -1;

const int _POSIX2_FORT_RUN = 200112;

const int _POSIX2_LOCALEDEF = 200112;

const int _POSIX2_PBS = -1;

const int _POSIX2_PBS_ACCOUNTING = -1;

const int _POSIX2_PBS_CHECKPOINT = -1;

const int _POSIX2_PBS_LOCATE = -1;

const int _POSIX2_PBS_MESSAGE = -1;

const int _POSIX2_PBS_TRACK = -1;

const int _POSIX2_SW_DEV = 200112;

const int _POSIX2_UPE = 200112;

const int __ILP32_OFF32 = -1;

const int __ILP32_OFFBIG = -1;

const int __LP64_OFF64 = 1;

const int __LPBIG_OFFBIG = 1;

const int _POSIX_V6_ILP32_OFF32 = -1;

const int _POSIX_V6_ILP32_OFFBIG = -1;

const int _POSIX_V6_LP64_OFF64 = 1;

const int _POSIX_V6_LPBIG_OFFBIG = 1;

const int _POSIX_V7_ILP32_OFF32 = -1;

const int _POSIX_V7_ILP32_OFFBIG = -1;

const int _POSIX_V7_LP64_OFF64 = 1;

const int _POSIX_V7_LPBIG_OFFBIG = 1;

const int _V6_ILP32_OFF32 = -1;

const int _V6_ILP32_OFFBIG = -1;

const int _V6_LP64_OFF64 = 1;

const int _V6_LPBIG_OFFBIG = 1;

const int _XBS5_ILP32_OFF32 = -1;

const int _XBS5_ILP32_OFFBIG = -1;

const int _XBS5_LP64_OFF64 = 1;

const int _XBS5_LPBIG_OFFBIG = 1;

const int _XOPEN_CRYPT = 1;

const int _XOPEN_ENH_I18N = 1;

const int _XOPEN_LEGACY = -1;

const int _XOPEN_REALTIME = -1;

const int _XOPEN_REALTIME_THREADS = -1;

const int _XOPEN_SHM = 1;

const int _XOPEN_STREAMS = -1;

const int _XOPEN_UNIX = 1;

const int _SC_ARG_MAX = 1;

const int _SC_CHILD_MAX = 2;

const int _SC_CLK_TCK = 3;

const int _SC_NGROUPS_MAX = 4;

const int _SC_OPEN_MAX = 5;

const int _SC_JOB_CONTROL = 6;

const int _SC_SAVED_IDS = 7;

const int _SC_VERSION = 8;

const int _SC_BC_BASE_MAX = 9;

const int _SC_BC_DIM_MAX = 10;

const int _SC_BC_SCALE_MAX = 11;

const int _SC_BC_STRING_MAX = 12;

const int _SC_COLL_WEIGHTS_MAX = 13;

const int _SC_EXPR_NEST_MAX = 14;

const int _SC_LINE_MAX = 15;

const int _SC_RE_DUP_MAX = 16;

const int _SC_2_VERSION = 17;

const int _SC_2_C_BIND = 18;

const int _SC_2_C_DEV = 19;

const int _SC_2_CHAR_TERM = 20;

const int _SC_2_FORT_DEV = 21;

const int _SC_2_FORT_RUN = 22;

const int _SC_2_LOCALEDEF = 23;

const int _SC_2_SW_DEV = 24;

const int _SC_2_UPE = 25;

const int _SC_STREAM_MAX = 26;

const int _SC_TZNAME_MAX = 27;

const int _SC_ASYNCHRONOUS_IO = 28;

const int _SC_PAGESIZE = 29;

const int _SC_MEMLOCK = 30;

const int _SC_MEMLOCK_RANGE = 31;

const int _SC_MEMORY_PROTECTION = 32;

const int _SC_MESSAGE_PASSING = 33;

const int _SC_PRIORITIZED_IO = 34;

const int _SC_PRIORITY_SCHEDULING = 35;

const int _SC_REALTIME_SIGNALS = 36;

const int _SC_SEMAPHORES = 37;

const int _SC_FSYNC = 38;

const int _SC_SHARED_MEMORY_OBJECTS = 39;

const int _SC_SYNCHRONIZED_IO = 40;

const int _SC_TIMERS = 41;

const int _SC_AIO_LISTIO_MAX = 42;

const int _SC_AIO_MAX = 43;

const int _SC_AIO_PRIO_DELTA_MAX = 44;

const int _SC_DELAYTIMER_MAX = 45;

const int _SC_MQ_OPEN_MAX = 46;

const int _SC_MAPPED_FILES = 47;

const int _SC_RTSIG_MAX = 48;

const int _SC_SEM_NSEMS_MAX = 49;

const int _SC_SEM_VALUE_MAX = 50;

const int _SC_SIGQUEUE_MAX = 51;

const int _SC_TIMER_MAX = 52;

const int _SC_NPROCESSORS_CONF = 57;

const int _SC_NPROCESSORS_ONLN = 58;

const int _SC_2_PBS = 59;

const int _SC_2_PBS_ACCOUNTING = 60;

const int _SC_2_PBS_CHECKPOINT = 61;

const int _SC_2_PBS_LOCATE = 62;

const int _SC_2_PBS_MESSAGE = 63;

const int _SC_2_PBS_TRACK = 64;

const int _SC_ADVISORY_INFO = 65;

const int _SC_BARRIERS = 66;

const int _SC_CLOCK_SELECTION = 67;

const int _SC_CPUTIME = 68;

const int _SC_FILE_LOCKING = 69;

const int _SC_GETGR_R_SIZE_MAX = 70;

const int _SC_GETPW_R_SIZE_MAX = 71;

const int _SC_HOST_NAME_MAX = 72;

const int _SC_LOGIN_NAME_MAX = 73;

const int _SC_MONOTONIC_CLOCK = 74;

const int _SC_MQ_PRIO_MAX = 75;

const int _SC_READER_WRITER_LOCKS = 76;

const int _SC_REGEXP = 77;

const int _SC_SHELL = 78;

const int _SC_SPAWN = 79;

const int _SC_SPIN_LOCKS = 80;

const int _SC_SPORADIC_SERVER = 81;

const int _SC_THREAD_ATTR_STACKADDR = 82;

const int _SC_THREAD_ATTR_STACKSIZE = 83;

const int _SC_THREAD_CPUTIME = 84;

const int _SC_THREAD_DESTRUCTOR_ITERATIONS = 85;

const int _SC_THREAD_KEYS_MAX = 86;

const int _SC_THREAD_PRIO_INHERIT = 87;

const int _SC_THREAD_PRIO_PROTECT = 88;

const int _SC_THREAD_PRIORITY_SCHEDULING = 89;

const int _SC_THREAD_PROCESS_SHARED = 90;

const int _SC_THREAD_SAFE_FUNCTIONS = 91;

const int _SC_THREAD_SPORADIC_SERVER = 92;

const int _SC_THREAD_STACK_MIN = 93;

const int _SC_THREAD_THREADS_MAX = 94;

const int _SC_TIMEOUTS = 95;

const int _SC_THREADS = 96;

const int _SC_TRACE = 97;

const int _SC_TRACE_EVENT_FILTER = 98;

const int _SC_TRACE_INHERIT = 99;

const int _SC_TRACE_LOG = 100;

const int _SC_TTY_NAME_MAX = 101;

const int _SC_TYPED_MEMORY_OBJECTS = 102;

const int _SC_V6_ILP32_OFF32 = 103;

const int _SC_V6_ILP32_OFFBIG = 104;

const int _SC_V6_LP64_OFF64 = 105;

const int _SC_V6_LPBIG_OFFBIG = 106;

const int _SC_IPV6 = 118;

const int _SC_RAW_SOCKETS = 119;

const int _SC_SYMLOOP_MAX = 120;

const int _SC_ATEXIT_MAX = 107;

const int _SC_IOV_MAX = 56;

const int _SC_PAGE_SIZE = 29;

const int _SC_XOPEN_CRYPT = 108;

const int _SC_XOPEN_ENH_I18N = 109;

const int _SC_XOPEN_LEGACY = 110;

const int _SC_XOPEN_REALTIME = 111;

const int _SC_XOPEN_REALTIME_THREADS = 112;

const int _SC_XOPEN_SHM = 113;

const int _SC_XOPEN_STREAMS = 114;

const int _SC_XOPEN_UNIX = 115;

const int _SC_XOPEN_VERSION = 116;

const int _SC_XOPEN_XCU_VERSION = 121;

const int _SC_XBS5_ILP32_OFF32 = 122;

const int _SC_XBS5_ILP32_OFFBIG = 123;

const int _SC_XBS5_LP64_OFF64 = 124;

const int _SC_XBS5_LPBIG_OFFBIG = 125;

const int _SC_SS_REPL_MAX = 126;

const int _SC_TRACE_EVENT_NAME_MAX = 127;

const int _SC_TRACE_NAME_MAX = 128;

const int _SC_TRACE_SYS_MAX = 129;

const int _SC_TRACE_USER_EVENT_MAX = 130;

const int _SC_PASS_MAX = 131;

const int _SC_PHYS_PAGES = 200;

const int _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 2;

const int _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 3;

const int _CS_POSIX_V6_ILP32_OFF32_LIBS = 4;

const int _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 5;

const int _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 6;

const int _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 7;

const int _CS_POSIX_V6_LP64_OFF64_CFLAGS = 8;

const int _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 9;

const int _CS_POSIX_V6_LP64_OFF64_LIBS = 10;

const int _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 11;

const int _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 12;

const int _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 13;

const int _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = 14;

const int _CS_XBS5_ILP32_OFF32_CFLAGS = 20;

const int _CS_XBS5_ILP32_OFF32_LDFLAGS = 21;

const int _CS_XBS5_ILP32_OFF32_LIBS = 22;

const int _CS_XBS5_ILP32_OFF32_LINTFLAGS = 23;

const int _CS_XBS5_ILP32_OFFBIG_CFLAGS = 24;

const int _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 25;

const int _CS_XBS5_ILP32_OFFBIG_LIBS = 26;

const int _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 27;

const int _CS_XBS5_LP64_OFF64_CFLAGS = 28;

const int _CS_XBS5_LP64_OFF64_LDFLAGS = 29;

const int _CS_XBS5_LP64_OFF64_LIBS = 30;

const int _CS_XBS5_LP64_OFF64_LINTFLAGS = 31;

const int _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 32;

const int _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 33;

const int _CS_XBS5_LPBIG_OFFBIG_LIBS = 34;

const int _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 35;

const int _CS_DARWIN_USER_DIR = 65536;

const int _CS_DARWIN_USER_TEMP_DIR = 65537;

const int _CS_DARWIN_USER_CACHE_DIR = 65538;

const int F_ULOCK = 0;

const int F_LOCK = 1;

const int F_TLOCK = 2;

const int F_TEST = 3;

const int __DARWIN_FD_SETSIZE = 1024;

const int __DARWIN_NBBY = 8;

const int __DARWIN_NFDBITS = 32;

const int FD_SETSIZE = 1024;

const int SYNC_VOLUME_FULLSYNC = 1;

const int SYNC_VOLUME_WAIT = 2;

const int FPDF_OBJECT_UNKNOWN = 0;

const int FPDF_OBJECT_BOOLEAN = 1;

const int FPDF_OBJECT_NUMBER = 2;

const int FPDF_OBJECT_STRING = 3;

const int FPDF_OBJECT_NAME = 4;

const int FPDF_OBJECT_ARRAY = 5;

const int FPDF_OBJECT_DICTIONARY = 6;

const int FPDF_OBJECT_STREAM = 7;

const int FPDF_OBJECT_NULLOBJ = 8;

const int FPDF_OBJECT_REFERENCE = 9;

const int FPDF_POLICY_MACHINETIME_ACCESS = 0;

const int FPDF_ERR_SUCCESS = 0;

const int FPDF_ERR_UNKNOWN = 1;

const int FPDF_ERR_FILE = 2;

const int FPDF_ERR_FORMAT = 3;

const int FPDF_ERR_PASSWORD = 4;

const int FPDF_ERR_SECURITY = 5;

const int FPDF_ERR_PAGE = 6;

const int FPDF_ANNOT = 1;

const int FPDF_LCD_TEXT = 2;

const int FPDF_NO_NATIVETEXT = 4;

const int FPDF_GRAYSCALE = 8;

const int FPDF_DEBUG_INFO = 128;

const int FPDF_NO_CATCH = 256;

const int FPDF_RENDER_LIMITEDIMAGECACHE = 512;

const int FPDF_RENDER_FORCEHALFTONE = 1024;

const int FPDF_PRINTING = 2048;

const int FPDF_RENDER_NO_SMOOTHTEXT = 4096;

const int FPDF_RENDER_NO_SMOOTHIMAGE = 8192;

const int FPDF_RENDER_NO_SMOOTHPATH = 16384;

const int FPDF_REVERSE_BYTE_ORDER = 16;

const int FPDF_CONVERT_FILL_TO_STROKE = 32;

const int FPDFBitmap_Unknown = 0;

const int FPDFBitmap_Gray = 1;

const int FPDFBitmap_BGR = 2;

const int FPDFBitmap_BGRx = 3;

const int FPDFBitmap_BGRA = 4;

const int FPDFBitmap_BGRA_Premul = 5;

const int FORMTYPE_NONE = 0;

const int FORMTYPE_ACRO_FORM = 1;

const int FORMTYPE_XFA_FULL = 2;

const int FORMTYPE_XFA_FOREGROUND = 3;

const int FORMTYPE_COUNT = 4;

const int JSPLATFORM_ALERT_BUTTON_OK = 0;

const int JSPLATFORM_ALERT_BUTTON_OKCANCEL = 1;

const int JSPLATFORM_ALERT_BUTTON_YESNO = 2;

const int JSPLATFORM_ALERT_BUTTON_YESNOCANCEL = 3;

const int JSPLATFORM_ALERT_BUTTON_DEFAULT = 0;

const int JSPLATFORM_ALERT_ICON_ERROR = 0;

const int JSPLATFORM_ALERT_ICON_WARNING = 1;

const int JSPLATFORM_ALERT_ICON_QUESTION = 2;

const int JSPLATFORM_ALERT_ICON_STATUS = 3;

const int JSPLATFORM_ALERT_ICON_ASTERISK = 4;

const int JSPLATFORM_ALERT_ICON_DEFAULT = 0;

const int JSPLATFORM_ALERT_RETURN_OK = 1;

const int JSPLATFORM_ALERT_RETURN_CANCEL = 2;

const int JSPLATFORM_ALERT_RETURN_NO = 3;

const int JSPLATFORM_ALERT_RETURN_YES = 4;

const int JSPLATFORM_BEEP_ERROR = 0;

const int JSPLATFORM_BEEP_WARNING = 1;

const int JSPLATFORM_BEEP_QUESTION = 2;

const int JSPLATFORM_BEEP_STATUS = 3;

const int JSPLATFORM_BEEP_DEFAULT = 4;

const int FXCT_ARROW = 0;

const int FXCT_NESW = 1;

const int FXCT_NWSE = 2;

const int FXCT_VBEAM = 3;

const int FXCT_HBEAM = 4;

const int FXCT_HAND = 5;

const int FPDFDOC_AACTION_WC = 16;

const int FPDFDOC_AACTION_WS = 17;

const int FPDFDOC_AACTION_DS = 18;

const int FPDFDOC_AACTION_WP = 19;

const int FPDFDOC_AACTION_DP = 20;

const int FPDFPAGE_AACTION_OPEN = 0;

const int FPDFPAGE_AACTION_CLOSE = 1;

const int FPDF_FORMFIELD_UNKNOWN = 0;

const int FPDF_FORMFIELD_PUSHBUTTON = 1;

const int FPDF_FORMFIELD_CHECKBOX = 2;

const int FPDF_FORMFIELD_RADIOBUTTON = 3;

const int FPDF_FORMFIELD_COMBOBOX = 4;

const int FPDF_FORMFIELD_LISTBOX = 5;

const int FPDF_FORMFIELD_TEXTFIELD = 6;

const int FPDF_FORMFIELD_SIGNATURE = 7;

const int FPDF_FORMFIELD_COUNT = 8;

const int FPDF_ANNOT_UNKNOWN = 0;

const int FPDF_ANNOT_TEXT = 1;

const int FPDF_ANNOT_LINK = 2;

const int FPDF_ANNOT_FREETEXT = 3;

const int FPDF_ANNOT_LINE = 4;

const int FPDF_ANNOT_SQUARE = 5;

const int FPDF_ANNOT_CIRCLE = 6;

const int FPDF_ANNOT_POLYGON = 7;

const int FPDF_ANNOT_POLYLINE = 8;

const int FPDF_ANNOT_HIGHLIGHT = 9;

const int FPDF_ANNOT_UNDERLINE = 10;

const int FPDF_ANNOT_SQUIGGLY = 11;

const int FPDF_ANNOT_STRIKEOUT = 12;

const int FPDF_ANNOT_STAMP = 13;

const int FPDF_ANNOT_CARET = 14;

const int FPDF_ANNOT_INK = 15;

const int FPDF_ANNOT_POPUP = 16;

const int FPDF_ANNOT_FILEATTACHMENT = 17;

const int FPDF_ANNOT_SOUND = 18;

const int FPDF_ANNOT_MOVIE = 19;

const int FPDF_ANNOT_WIDGET = 20;

const int FPDF_ANNOT_SCREEN = 21;

const int FPDF_ANNOT_PRINTERMARK = 22;

const int FPDF_ANNOT_TRAPNET = 23;

const int FPDF_ANNOT_WATERMARK = 24;

const int FPDF_ANNOT_THREED = 25;

const int FPDF_ANNOT_RICHMEDIA = 26;

const int FPDF_ANNOT_XFAWIDGET = 27;

const int FPDF_ANNOT_REDACT = 28;

const int FPDF_ANNOT_FLAG_NONE = 0;

const int FPDF_ANNOT_FLAG_INVISIBLE = 1;

const int FPDF_ANNOT_FLAG_HIDDEN = 2;

const int FPDF_ANNOT_FLAG_PRINT = 4;

const int FPDF_ANNOT_FLAG_NOZOOM = 8;

const int FPDF_ANNOT_FLAG_NOROTATE = 16;

const int FPDF_ANNOT_FLAG_NOVIEW = 32;

const int FPDF_ANNOT_FLAG_READONLY = 64;

const int FPDF_ANNOT_FLAG_LOCKED = 128;

const int FPDF_ANNOT_FLAG_TOGGLENOVIEW = 256;

const int FPDF_ANNOT_APPEARANCEMODE_NORMAL = 0;

const int FPDF_ANNOT_APPEARANCEMODE_ROLLOVER = 1;

const int FPDF_ANNOT_APPEARANCEMODE_DOWN = 2;

const int FPDF_ANNOT_APPEARANCEMODE_COUNT = 3;

const int FPDF_FORMFLAG_NONE = 0;

const int FPDF_FORMFLAG_READONLY = 1;

const int FPDF_FORMFLAG_REQUIRED = 2;

const int FPDF_FORMFLAG_NOEXPORT = 4;

const int FPDF_FORMFLAG_TEXT_MULTILINE = 4096;

const int FPDF_FORMFLAG_TEXT_PASSWORD = 8192;

const int FPDF_FORMFLAG_CHOICE_COMBO = 131072;

const int FPDF_FORMFLAG_CHOICE_EDIT = 262144;

const int FPDF_FORMFLAG_CHOICE_MULTI_SELECT = 2097152;

const int FPDF_ANNOT_AACTION_KEY_STROKE = 12;

const int FPDF_ANNOT_AACTION_FORMAT = 13;

const int FPDF_ANNOT_AACTION_VALIDATE = 14;

const int FPDF_ANNOT_AACTION_CALCULATE = 15;

const int FLATTEN_FAIL = 0;

const int FLATTEN_SUCCESS = 1;

const int FLATTEN_NOTHINGTODO = 2;

const int FLAT_NORMALDISPLAY = 0;

const int FLAT_PRINT = 1;

const int FPDF_INCREMENTAL = 1;

const int FPDF_NO_INCREMENTAL = 2;

const int FPDF_REMOVE_SECURITY = 3;

const int PDFACTION_UNSUPPORTED = 0;

const int PDFACTION_GOTO = 1;

const int PDFACTION_REMOTEGOTO = 2;

const int PDFACTION_URI = 3;

const int PDFACTION_LAUNCH = 4;

const int PDFACTION_EMBEDDEDGOTO = 5;

const int PDFDEST_VIEW_UNKNOWN_MODE = 0;

const int PDFDEST_VIEW_XYZ = 1;

const int PDFDEST_VIEW_FIT = 2;

const int PDFDEST_VIEW_FITH = 3;

const int PDFDEST_VIEW_FITV = 4;

const int PDFDEST_VIEW_FITR = 5;

const int PDFDEST_VIEW_FITB = 6;

const int PDFDEST_VIEW_FITBH = 7;

const int PDFDEST_VIEW_FITBV = 8;

const int FPDF_COLORSPACE_UNKNOWN = 0;

const int FPDF_COLORSPACE_DEVICEGRAY = 1;

const int FPDF_COLORSPACE_DEVICERGB = 2;

const int FPDF_COLORSPACE_DEVICECMYK = 3;

const int FPDF_COLORSPACE_CALGRAY = 4;

const int FPDF_COLORSPACE_CALRGB = 5;

const int FPDF_COLORSPACE_LAB = 6;

const int FPDF_COLORSPACE_ICCBASED = 7;

const int FPDF_COLORSPACE_SEPARATION = 8;

const int FPDF_COLORSPACE_DEVICEN = 9;

const int FPDF_COLORSPACE_INDEXED = 10;

const int FPDF_COLORSPACE_PATTERN = 11;

const int FPDF_PAGEOBJ_UNKNOWN = 0;

const int FPDF_PAGEOBJ_TEXT = 1;

const int FPDF_PAGEOBJ_PATH = 2;

const int FPDF_PAGEOBJ_IMAGE = 3;

const int FPDF_PAGEOBJ_SHADING = 4;

const int FPDF_PAGEOBJ_FORM = 5;

const int FPDF_SEGMENT_UNKNOWN = -1;

const int FPDF_SEGMENT_LINETO = 0;

const int FPDF_SEGMENT_BEZIERTO = 1;

const int FPDF_SEGMENT_MOVETO = 2;

const int FPDF_FILLMODE_NONE = 0;

const int FPDF_FILLMODE_ALTERNATE = 1;

const int FPDF_FILLMODE_WINDING = 2;

const int FPDF_FONT_TYPE1 = 1;

const int FPDF_FONT_TRUETYPE = 2;

const int FPDF_LINECAP_BUTT = 0;

const int FPDF_LINECAP_ROUND = 1;

const int FPDF_LINECAP_PROJECTING_SQUARE = 2;

const int FPDF_LINEJOIN_MITER = 0;

const int FPDF_LINEJOIN_ROUND = 1;

const int FPDF_LINEJOIN_BEVEL = 2;

const int FPDF_PRINTMODE_EMF = 0;

const int FPDF_PRINTMODE_TEXTONLY = 1;

const int FPDF_PRINTMODE_POSTSCRIPT2 = 2;

const int FPDF_PRINTMODE_POSTSCRIPT3 = 3;

const int FPDF_PRINTMODE_POSTSCRIPT2_PASSTHROUGH = 4;

const int FPDF_PRINTMODE_POSTSCRIPT3_PASSTHROUGH = 5;

const int FPDF_PRINTMODE_EMF_IMAGE_MASKS = 6;

const int FPDF_PRINTMODE_POSTSCRIPT3_TYPE42 = 7;

const int FPDF_PRINTMODE_POSTSCRIPT3_TYPE42_PASSTHROUGH = 8;

const int FXFONT_ANSI_CHARSET = 0;

const int FXFONT_DEFAULT_CHARSET = 1;

const int FXFONT_SYMBOL_CHARSET = 2;

const int FXFONT_SHIFTJIS_CHARSET = 128;

const int FXFONT_HANGEUL_CHARSET = 129;

const int FXFONT_GB2312_CHARSET = 134;

const int FXFONT_CHINESEBIG5_CHARSET = 136;

const int FXFONT_GREEK_CHARSET = 161;

const int FXFONT_VIETNAMESE_CHARSET = 163;

const int FXFONT_HEBREW_CHARSET = 177;

const int FXFONT_ARABIC_CHARSET = 178;

const int FXFONT_CYRILLIC_CHARSET = 204;

const int FXFONT_THAI_CHARSET = 222;

const int FXFONT_EASTERNEUROPEAN_CHARSET = 238;

const int FXFONT_FF_FIXEDPITCH = 1;

const int FXFONT_FF_ROMAN = 16;

const int FXFONT_FF_SCRIPT = 64;

const int FXFONT_FW_NORMAL = 400;

const int FXFONT_FW_BOLD = 700;

const int PDF_LINEARIZATION_UNKNOWN = -1;

const int PDF_NOT_LINEARIZED = 0;

const int PDF_LINEARIZED = 1;

const int PDF_DATA_ERROR = -1;

const int PDF_DATA_NOTAVAIL = 0;

const int PDF_DATA_AVAIL = 1;

const int PDF_FORM_ERROR = -1;

const int PDF_FORM_NOTAVAIL = 0;

const int PDF_FORM_AVAIL = 1;

const int PDF_FORM_NOTEXIST = 2;

const int FPDF_RENDER_READY = 0;

const int FPDF_RENDER_TOBECONTINUED = 1;

const int FPDF_RENDER_DONE = 2;

const int FPDF_RENDER_FAILED = 3;

const int FPDF_MATCHCASE = 1;

const int FPDF_MATCHWHOLEWORD = 2;

const int FPDF_CONSECUTIVE = 4;

const int FPDF_UNSP_DOC_XFAFORM = 1;

const int FPDF_UNSP_DOC_PORTABLECOLLECTION = 2;

const int FPDF_UNSP_DOC_ATTACHMENT = 3;

const int FPDF_UNSP_DOC_SECURITY = 4;

const int FPDF_UNSP_DOC_SHAREDREVIEW = 5;

const int FPDF_UNSP_DOC_SHAREDFORM_ACROBAT = 6;

const int FPDF_UNSP_DOC_SHAREDFORM_FILESYSTEM = 7;

const int FPDF_UNSP_DOC_SHAREDFORM_EMAIL = 8;

const int FPDF_UNSP_ANNOT_3DANNOT = 11;

const int FPDF_UNSP_ANNOT_MOVIE = 12;

const int FPDF_UNSP_ANNOT_SOUND = 13;

const int FPDF_UNSP_ANNOT_SCREEN_MEDIA = 14;

const int FPDF_UNSP_ANNOT_SCREEN_RICHMEDIA = 15;

const int FPDF_UNSP_ANNOT_ATTACHMENT = 16;

const int FPDF_UNSP_ANNOT_SIG = 17;

const int PAGEMODE_UNKNOWN = -1;

const int PAGEMODE_USENONE = 0;

const int PAGEMODE_USEOUTLINES = 1;

const int PAGEMODE_USETHUMBS = 2;

const int PAGEMODE_FULLSCREEN = 3;

const int PAGEMODE_USEOC = 4;

const int PAGEMODE_USEATTACHMENTS = 5;
